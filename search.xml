<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/3eeb.html</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>2015年1月，本站使用wordpres工具在阿里云虚拟主机搭建。<br>2016年9月，由于嫌wordpress太不像一个博客，阿里云的免费主机不稳定等原因，转移到静态博客Hexo。</p>
<p>搭建博客让我在互联网认识了不少有趣的人，厉害的人，神一样存在的人，形形色色。原来以为自己很厉害，后来意识到比自己厉害的人多了去了，真是天外有天，人外有人，自己还是太浮躁，需要沉下去多多积淀。</p>
<p>自己搭建博客，并没有什么特别的目的，只是想着通过这样一种方式去记录自己一种体验，一种心态，一种经历。也许有些文章显得愤青不知天高地厚，这也不正由于年轻所以才热血么？我只是以一种自己喜欢的方式来记录罢了，像一本日记，又像一本笔记，也许以后会向像一个技术站。没关系，我不是为了讨好谁，自己舒服就好。</p>
<p>如果你喜欢我的博客，可以存为书签，我会经常更新的。</p>
]]></content>
  </entry>
  <entry>
    <title>51单片机与PC通信方法总结</title>
    <url>/blog/d48d.html</url>
    <content><![CDATA[<p>51单片机的串口，是个全双工的串口，发送数据的同时，还可以接收数据。<br>当串行发送完毕后，将在标志位 TI 置 1，同样，当收到了数据后，也会在 RI 置 1。</p>
<p> 无论 RI 或 TI 出现了 1，只要串口中断处于开放状态，单片机都会进入串口中断处理程序。<br>在中断程序中，要区分出来究竟是发送引起的中断，还是接收引起的中断，然后分别进行处理。</p>
<p>常用的方法有：<br>    接收数据时，使用“中断方式”，清除 RI 后，用一个变量通知主函数，收到新数据。<br>    发送数据时，也用“中断方式”，清除 TI 后，用另一个变量通知主函数，数据发送完毕。<br>    这样一来，收、发两者基本一致，编写程序也很规范、易懂。<br>    更重要的是，主函数中，不用在那儿死等发送完毕，可以有更多的时间查看其它的标志。<br>PC与单片机串口通信的程序，要求如下：<br>    1、如果在电脑上发送以$开始的字符串，则将整个字符串原样返回（字符串长度不是固定的）。<br>    2、如果接收到1，则将P00置高电平，接收到0，P10置低电平。（用来控制一个LED）<br>单片机是STC89C52RC/晶振11.0592/波特率要求是9600或4800。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &amp;amp;lt;reg52.h&amp;amp;gt;</span><br><span class="line">sbit LED = P0^0;</span><br><span class="line">unsigned char UART_buff;</span><br><span class="line">bit New_rec = 0, Send_ed = 1, Money = 0;</span><br><span class="line">void main ()</span><br><span class="line">&#123;</span><br><span class="line">    SCON = 0x50; //串口方式1, 10位UART（一个起始位“0”八个数据位一个停止位“1”）, 允许接收.</span><br><span class="line">    TMOD = 0x20; //T1方式2</span><br><span class="line">    TH1 = 0xFD; //装入自动重加载的处置，9600bps@11.0592MHz</span><br><span class="line">    TL1 = 0xFD; //装入初值</span><br><span class="line">    TR1 = 1; //启动定时器</span><br><span class="line">    T1ES = 1; //开串口中断，但不开定时器中断，不允许定时器中断</span><br><span class="line">    EA = 1;</span><br><span class="line">    while(Money == 0); //等着交费，呵呵，等着接收$.</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if ((New_rec == 1) &amp;amp;amp;&amp;amp;amp; (Send_ed == 1))</span><br><span class="line">        &#123;               </span><br><span class="line">            SBUF = UART_buff; //那就发送.</span><br><span class="line">            New_rec = 0;</span><br><span class="line">            Send_ed = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//----------------------------------------------</span><br><span class="line">void ser_int() interrupt 4</span><br><span class="line">&#123;</span><br><span class="line">    if(RI == 1) //如果收到.</span><br><span class="line">    &#123;</span><br><span class="line">        RI = 0; //清除标志.</span><br><span class="line">        New_rec = 1;</span><br><span class="line">        UART_buff = SBUF; //接收.</span><br><span class="line">        if(UART_buff == &#x27;1&#x27;)</span><br><span class="line">            LED = 1;</span><br><span class="line">        if(UART_buff == &#x27;0&#x27;)</span><br><span class="line">            LED = 0;</span><br><span class="line">        if(UART_buff == &#x27;$&#x27;)</span><br><span class="line">            Money = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else //如果送毕.</span><br><span class="line">    &#123;</span><br><span class="line">        TI = 0; //清除标志.</span><br><span class="line">        Send_ed = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>语音交互式家居控制系统的设计</title>
    <url>/blog/1aa0.html</url>
    <content><![CDATA[<p>我的毕业设计选题是『交互式语音家居控制系统的设计』，从16年12月底着手开始设计制作以及调试，到了今天也算告一段落了。实现了语音识别、人机对话、无线控制、语音报时、时间温度显示，设置闹钟等功能。<br>现在还存在的bug有语音报时中间停歇的时间稍长。原因是MP3模块的指定文件播放需要反应时间，根据实际测试，大约需要800ms的延时才可以播放下一段录音，也就是说两段录音之间的间隔要800ms，目前还正在寻找解决的方案。</p>
<p>项目主页 <a href="https://github.com/immapan/Graduation-Project">https://github.com/immapan/Graduation-Project</a></p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>语音识别模块</li>
<li>MP3播放模块</li>
<li>蓝牙HC-05模块 x 2</li>
<li>继电器模块 x 1</li>
<li>时钟模块</li>
</ul>
<blockquote>
<p>DS3231模块<br>DS1302</p>
</blockquote>
<ul>
<li>电容</li>
</ul>
<blockquote>
<p>100uF x 1<br>10uF x 1<br>104 x 1</p>
</blockquote>
<ul>
<li>功放模块 x 1</li>
<li>STC12C5A60S2  x 2</li>
<li>0.5w 8ohm扬声器 x 2</li>
<li>晶振</li>
</ul>
<blockquote>
<p>32.768KHz晶振 x 1<br>22.1184MHz晶振 x 2</p>
</blockquote>
<ul>
<li>LCD1602液晶屏</li>
<li>2000mA锂电池充放电模块</li>
<li>按键 </li>
</ul>
<blockquote>
<p>点动按键 X 4<br>长按键 x 2 </p>
</blockquote>
<ul>
<li>3mm铜柱 x 15</li>
<li>3mm螺母 x 8</li>
<li>3mm螺丝 x 12</li>
<li>覆铜板 x 2</li>
<li>杜邦线 若干</li>
<li>纸盒 x 1</li>
<li>贴纸 若干</li>
<li>开关</li>
</ul>
<blockquote>
<p>船型开关 x 1<br>自锁开关 x 1</p>
</blockquote>
<ul>
<li>5V 200mA 电源适配器 x 1</li>
<li>SDcard x 1</li>
<li>纽扣电池 x 1</li>
<li>温度传感器 DS18B20 X 1 </li>
<li>10kohm电位器</li>
<li>共阴极雾状RGB全彩灯珠 x 1</li>
<li>排母 若干</li>
<li>排针 若干</li>
<li>10kohm排阻 x 1</li>
</ul>
<h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><p>通过语音识别模块来识别我们说出的话（普通话最好，河南话也可），识别结果通过串口返回单片机，单片机控制MP3模块播放相应语音 、进行相应的蓝牙数据传送。<br>其中主要涉及到的是串口通信协议，IIC协议等<br>———————割————————–</p>
<p>下面是手工制作的步骤</p>
<h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p>主控制板<br>!()[]<br><img class="lazy" src="02.jpg" data-original="02.jpg" width="640" height="340"></p>
<p>从控制板<br><img class="lazy" src="03.jpg" data-original="03.jpg" width="640" height="267"></p>
<h1 id="PCB图"><a href="#PCB图" class="headerlink" title="PCB图"></a>PCB图</h1><p>主控制板<br><img class="lazy" src="01.jpg" data-original="01.jpg" width="640" height="317"></p>
<p>从控制板<br><img class="lazy" src="04.jpg" data-original="04.jpg" width="640" height="712"></p>
<h1 id="手工制作步骤"><a href="#手工制作步骤" class="headerlink" title="手工制作步骤"></a>手工制作步骤</h1><p>打印到转印纸<br><img class="lazy" src="05.jpg" data-original="05.jpg" width="640" height="473"></p>
<p>使用熨斗熨烫到覆铜板<br><img class="lazy" src="06.jpg" data-original="06.jpg" width="640" height="864"></p>
<p>冷却后 揭下转印纸，墨完全转印到覆铜板上<br><img class="lazy" src="07.jpg" data-original="07.jpg" width="640" height="864"></p>
<p>切割成合适的大小<br><img class="lazy" src="08.jpg" data-original="08.jpg" width="640" height="473"></p>
<p>准备腐蚀<br><img class="lazy" src="09.jpg" data-original="09.jpg" width="640" height="864"></p>
<p>正在腐蚀<br><img class="lazy" src="10.jpg" data-original="10.jpg" width="640" height="864"></p>
<p>多余的铜已经基本腐蚀掉了<br><img class="lazy" src="11.jpg" data-original="11.jpg" width="640" height="864"></p>
<p>打捞出来洗净晾干<br><img class="lazy" src="13.jpg" data-original="13.jpg" width="640" height="473"></p>
<p>准备打孔，用自己DIY的手钻<br><img class="lazy" src="12.jpg" data-original="12.jpg" width="640" height="473"></p>
<p>焊接上贴片单片机<br><img class="lazy" src="14.jpg" data-original="14.jpg" width="640" height="473"></p>
<p>成品图<br><img class="lazy" src="15.jpg" data-original="15.jpg" width="640" height="473"></p>
<p>从控制板过程也是这样<br><img class="lazy" src="16.jpg" data-original="16.jpg" width="640" height="473"></p>
<p>过程省略，效果图如下<br><img class="lazy" src="18.jpg" data-original="18.jpg" width="640" height="864"></p>
<img class="lazy" src="17.jpg" data-original="17.jpg" width="640" height="864">

<p>程序流程图</p>
<p>主程序<br><img class="lazy" src="22.jpg" data-original="22.jpg" width="460" height="704"></p>
<p>循环模式<br><img class="lazy" src="21.jpg" data-original="21.jpg" width="447" height="657"></p>
<p>口令模式<br><img class="lazy" src="20.jpg" data-original="20.jpg" width="538" height="865"></p>
<p>报时模式<br><img class="lazy" src="19.jpg" data-original="19.jpg" width="197" height="342"></p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>按键的研究</title>
    <url>/blog/694e.html</url>
    <content><![CDATA[<p>利用一个IO口，接一个按键，实现3功能操作：单击 + 双击 + 长按<br>用户基本操作定义： </p>
<ul>
<li>短按操作：按键按下，按下时间&lt;1s，属于一次短按操作 </li>
<li>长按操作：按键按下，按下时间&gt;1s，属于一次长按操作</li>
</ul>
<p>在正常0.5s内无按键操作为启始按键扫描条件下，扫描按键将产生以下3种按键事件： </p>
<ul>
<li>长按事件：任何1次出现的长按操作都属于长按事件 </li>
<li>单击事件：1次短按操作后，间隔0.5内没有短按操作 </li>
<li>双击事件：2次短按操作间隔时间&lt;0.5s，则2次短按操作为1次双击事件，且2次短按都取消</li>
</ul>
<p>特别操作情况定义： </p>
<ul>
<li>短按操作和长按操作间隔&lt;0.5s，以及，长按操作和短按操作间隔&lt;0.5s，均不产生双击事件 </li>
<li>连续n次（n为奇数）短按操作，且间隔均&lt;0.5s，产生(n-1)/2次双击事件+1次单击事件 </li>
<li>连续n次（n为偶数）短按操作，且间隔均&lt;0.5s，产生n/2次双击事件</li>
</ul>
<p>对按键操作者的建议： </p>
<p>由于按键的多功能性质，建议操作者每次在单击/长按/双击按键事件发生后，隔0.5s后再进行下一次的按键操作。因为在特别操作情况下，程序是保证按定义进行判断和处理的，主要是怕操作者自己记不清楚导致操作失误。</p>
<p>对软件设计者的要求： </p>
<ul>
<li>应该全面进行分析，给出严格定义和判断条件，如上所示。如果自己都不清楚，你的设计出的系统就不稳定，不可靠。 </li>
<li>在1的基础上，编写出符合要求的程序，并进行全面测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*================================================================================</span><br><span class="line">低层按键（I/0）扫描函数，即低层按键设备驱动，只返回无键、短按和长按。具体双击不在此处判断。</span><br><span class="line">=================================================================================*/ </span><br><span class="line"></span><br><span class="line">#define key_input    PIND.7    // 按键输入口 </span><br><span class="line"></span><br><span class="line">#define N_key    0             //无键</span><br><span class="line">#define S_key    1             //单键</span><br><span class="line">#define D_key    2             //双键</span><br><span class="line">#define L_key    3             //长键 </span><br><span class="line"></span><br><span class="line">#define key_state_0 0</span><br><span class="line">#define key_state_1 1</span><br><span class="line">#define key_state_2 2 </span><br><span class="line"></span><br><span class="line">unsigned char key_driver(void)</span><br><span class="line">&#123;</span><br><span class="line">    static unsigned char key_state = key_state_0, key_time = 0;</span><br><span class="line">    unsigned char key_press, key_return = N_key; </span><br><span class="line"></span><br><span class="line">    key_press = key_input;                    // 读按键I/O电平 </span><br><span class="line"></span><br><span class="line">    switch (key_state)</span><br><span class="line">    &#123;</span><br><span class="line">      case key_state_0:                               // 按键初始态</span><br><span class="line">        if (!key_press) key_state = key_state_1;      // 键被按下，</span><br><span class="line">        break;                                        //状态转换到按键消抖和确认状态 </span><br><span class="line"></span><br><span class="line">      case key_state_1:                      // 按键消抖与确认态</span><br><span class="line">        if (!key_press)</span><br><span class="line">        &#123;</span><br><span class="line">             key_time = 0;</span><br><span class="line">             key_state = key_state_2;       // 按键仍然处于按下，消抖完成，状态转换到按</span><br><span class="line">                                            //下键时间的计时状态，但返回的还是无键事件</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">             key_state = key_state_0;   // 按键已抬起，转换到按键初始态。此处完成和实现</span><br><span class="line">                                        //软件消抖，其实按键的按下和释放都在此消抖的。</span><br><span class="line">        break; </span><br><span class="line"></span><br><span class="line">      case key_state_2:</span><br><span class="line">        if(key_press)</span><br><span class="line">        &#123;</span><br><span class="line">             key_return = S_key;      // 此时按键释放，说明是产生一次短操作，回送S_key</span><br><span class="line">             key_state = key_state_0; // 转换到按键初始态</span><br><span class="line">        &#125;</span><br><span class="line">        else if (++key_time &amp;gt;= 100)   // 继续按下，计时加10ms（10ms为本函数循环执行间隔）</span><br><span class="line">        &#123;</span><br><span class="line">             key_return = L_key;      // 按下时间&amp;gt;1000ms，此按键为长按操作，返回长键事件</span><br><span class="line">             key_state = key_state_3; // 转换到等待按键释放状态</span><br><span class="line">        &#125;</span><br><span class="line">        break; </span><br><span class="line"></span><br><span class="line">      case key_state_3:               //等待按键释放状态，此状态只返回无按键事件</span><br><span class="line">        if (key_press) key_state = key_state_0; //按键已释放，转换到按键初始态</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return key_return;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*=============================================================</span><br><span class="line">中间层按键处理函数，调用低层函数一次，处理双击事件的判断，返回上层正确的</span><br><span class="line">无键、单键、双键、长键4个按键事件。 本函数由上层循环调用，间隔10ms</span><br><span class="line">==============================================================*/ </span><br><span class="line"></span><br><span class="line">unsigned char key_read(void)</span><br><span class="line">&#123;</span><br><span class="line">    static unsigned char key_m = key_state_0, key_time_1 = 0;</span><br><span class="line">    unsigned char key_return = N_key,key_temp; </span><br><span class="line"></span><br><span class="line">    key_temp = key_driver(); </span><br><span class="line"></span><br><span class="line">    switch(key_m)</span><br><span class="line">    &#123;</span><br><span class="line">        case key_state_0:</span><br><span class="line">            if (key_temp == S_key )</span><br><span class="line">            &#123;</span><br><span class="line">                 key_time_1 = 0;               // 第1次单击，不返回，</span><br><span class="line">                 key_m = key_state_1;          //到下个状态判断后面是否出现双击</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                 key_return = key_temp;        // 对于无键、长键，返回原事件</span><br><span class="line">            break; </span><br><span class="line"></span><br><span class="line">        case key_state_1:</span><br><span class="line">            if (key_temp == S_key)             // 又一次单击（间隔肯定&amp;lt;500ms）</span><br><span class="line">            &#123;</span><br><span class="line">                key_return = D_key;            // 返回双击键事件，回初始状态</span><br><span class="line">                key_m = key_state_0;</span><br><span class="line">            &#125;</span><br><span class="line">            else               // 这里500ms内肯定读到的都是无键事件，因为长键&amp;gt;1000ms</span><br><span class="line">            &#123;                  //在1s前低层返回的都是无键</span><br><span class="line">                if(++key_time_1 &amp;gt;= 50)</span><br><span class="line">                &#123;</span><br><span class="line">                     key_return = S_key;//0.5s内没再次出现单键事件，返回上次单键事件</span><br><span class="line">                     key_m = key_state_0; // 返回初始状态</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return key_return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，根据程序分析按键事件的反映时间：</p>
<ul>
<li><p>对于长键，按下超过1s马上响应，反映最快。</p>
</li>
<li><p>对于双键，第2次按键释放后马上得到反映。</p>
</li>
<li><p>对于单键，释放后延时拖后500ms才能响应，反映最慢。</p>
</li>
</ul>
<p>反应的速度与需要判断后面是否有双击操作有关，只能这样。实际应用中，可以调整两次单击间隔时间定义，比如为300ms，这样单击的响应回快一点，单按键操作人员需要加快按键的操作过程。如果产品是针对老年人的，这个时间不易太短，因为年纪大的人，反映和动作都比较慢。</p>
<p>当然，上面两段可以合在一起。我这样做的目的，是为了可以方便的扩展为N击（当然，需要做修改）。可是最底层的就是最基本的操作处理短按和长按，不用改动的。至于双击，还是N击，在中间层处理。这就是程序设计中分层结构的优点。<br>测试代码环境如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">interrupt [TIM0_COMP] void timer0_comp_isr(void)       // 定时器10ms中断服务</span><br><span class="line">&#123;</span><br><span class="line">       time_10ms_ok = 1;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">main(viod)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while</span><br><span class="line">    &#123;</span><br><span class="line">        if (time_10ms_ok)            //每10ms执行一次，</span><br><span class="line">        &#123;</span><br><span class="line">             time_10ms_ok =0;</span><br><span class="line">             key = key_read();       //《====== 10ms一次调用按键中间层函数，根据返回键值，</span><br><span class="line">                                     //点亮不同的LED灯，全面测试按键操作是否正常</span><br><span class="line">             if (key == L_key)</span><br><span class="line">                 ........//点亮A_LED，关闭B_LED和C_LED</span><br><span class="line">             else if(key == D_key)</span><br><span class="line">                 ........//点亮B_LED，关闭A_LED和C_LED</span><br><span class="line">             else if(key == S_key)</span><br><span class="line">                 ........//点亮C_LED，关闭A_LED和B_LED</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>两个IO端口连接一个矩阵键盘</title>
    <url>/blog/565a.html</url>
    <content><![CDATA[<h1 id="使用两个I-O端口连接4×3的矩阵键盘"><a href="#使用两个I-O端口连接4×3的矩阵键盘" class="headerlink" title="使用两个I/O端口连接4×3的矩阵键盘"></a>使用两个I/O端口连接4×3的矩阵键盘</h1><p>矩阵键盘是微处理器基本的输入设备，搭建一个矩阵键盘最常规的方法需要使用多个微处理器I/O端口，然后往MCU中编写一个扫描算法程序来识别是哪一个键被按下。这种方法的一个缺点是它需要大量的I/O端口。例如，要连接一个4×3的矩阵键盘需要7个数字I/O引脚。当MCU的端口少或者不够用时就出问题了。<br>针对这个问题有两种可行的解决方案：很容易想到使用I/O扩展芯片或者用电阻网络分配一个唯一的电压值给每一个按键，然后使用一个模拟引脚来读取电压值来确定是哪一个按键被按下。每个解决方法都有自己的缺点。<br>因多数I/O扩展需要一个特殊的通讯协议（例如：I2C或SPI）来完成读写数据的操作，MCU得有相关的通信模型来支持，或者用户必须编写实现相关的通讯协议程序，这明显会增加处理器的系统开销。另外，使用电阻网络给每一个按键分配唯一的电压的缺点是当需要很多按键时，电压之间分布紧凑，一旦温度发生变化将会导致误读。再者开关的抖动在其中也起很大的作用，这种方法的另一个最主要的不足是：我们使用的MCU必须有模拟输入引脚。<br>下面介绍的这种方法可以克服以上所有的问题并且还有很多优点：无论连接多大规模的键盘只需要2个I/O端口；不需要特殊的通讯协议；也无需模拟输入端口。这个设计思路基于两片非常通用且便宜的CD4017计数器。</p>

<p>图1展示4×3矩阵键盘的电路原理图。<br>R1，R4，R5和R6用于限流，R7，D4，D5，D6组成一个或门。</p>

<p>图2描述了如何读取4×3矩阵键盘的键值。<br>一个计数器用于控制键盘的行，另一个用于控制键盘的列。<br>MCU产生一个时钟脉冲信号作为计数器的脉冲输入来控制键盘的列。开始时，行计数器和列计数器的0号输出端口都是高电平，由于不断接受到脉冲信号列计数器的计数值增加。当接受到第四个时钟脉冲时，列计数器复位同时以此作为一个脉冲来控制行计数器。每次列计数器复位，行计数器的计数值增加直到接收到第五个脉冲时复位。在产生脉冲信号的同时MCU应该设置一个计数变量给脉冲计数。键盘的输出端接到MCU的一个外部中断引脚。<br>只有当一个按键被按下，这时按键所对应的行列都处在低电平，才会触发中断。如果行列中只有一个处在低电平不会触发中断。<br>当中断发生时，这时MCU读取计数值，根据计数值来判断是哪一个位置的按键被按下。<br>MCU中的时钟计数变量，随脉冲的产生而递增，它的数值与按键的次序对应，流程图见图2。<br>注意，尽管这个示例展示了一个4×3的矩阵键盘，通过利用4017其他的输出端口，你可以最多读取一个10×10的键盘。另外你也可以根据需要，级联更多的4017来扩展更大的规模的矩阵键盘。<br><span style="font-size: 8pt; font-family: 宋体;">本文来自果壳网</span></p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>MapReduce之wordcount</title>
    <url>/blog/dd40.html</url>
    <content><![CDATA[<p>新建maven项目<br>注入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--pom.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>log4j.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">INFO, stdout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br><span class="line"><span class="attr">log4j.appender.logfile</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="attr">log4j.appender.logfile.File</span>=<span class="string">target/spring.log</span></span><br><span class="line"><span class="attr">log4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WcDriver.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WcDriver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取一个job实例</span></span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.设置类路径</span></span><br><span class="line">        job.setJarByClass(WcDriver.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 设置Mapper和Reducer</span></span><br><span class="line">        job.setMapperClass(WcMapper.class);</span><br><span class="line">        job.setReducerClass(WcReducer.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 设置Mapper的输出类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(IntWritable.class);</span><br><span class="line">        <span class="comment">// 设置reducer的输出类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 设置输入输出文件</span></span><br><span class="line">        FileInputFormat.setInputPaths(job,<span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job,<span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 提交job</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> job.waitForCompletion(<span class="literal">true</span>);</span><br><span class="line">        System.exit(b ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WcMapper.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数据变成一行一行的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WcMapper</span> <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;LongWritable,Text, Text, IntWritable&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(LongWritable key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 把输入的一行数据，按照空格分隔。</span></span><br><span class="line">        String[] words = value.toString().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增强for遍历所有word，通过write把所有单词输出</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="built_in">this</span>.word.set(word);</span><br><span class="line">            context.write(<span class="built_in">this</span>.word,<span class="built_in">this</span>.one);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WcReducer.java</span></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WcReducer</span> <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text, IntWritable,Text, IntWritable&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">total</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        total.set(sum);</span><br><span class="line">        <span class="comment">// 返回key的数量</span></span><br><span class="line">        context.write(key,total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入文件<br>helllo.txt</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">我爱 北京 天安门</span><br><span class="line">天安门 太阳 </span><br><span class="line">我爱 小红</span><br><span class="line">小红 爱我</span><br><span class="line">我 是 一个 好人</span><br><span class="line">天安门 前 太阳 升起 厉害</span><br><span class="line">天安门 北京 你好 世界</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	File System Counters</span><br><span class="line">		FILE: Number of bytes read=1240</span><br><span class="line">		FILE: Number of bytes written=561726</span><br><span class="line">		FILE: Number of read operations=0</span><br><span class="line">		FILE: Number of large read operations=0</span><br><span class="line">		FILE: Number of write operations=0</span><br><span class="line">	Map-Reduce Framework</span><br><span class="line">		Map input records=7</span><br><span class="line">		Map output records=22</span><br><span class="line">		Map output bytes=245</span><br><span class="line">		Map output materialized bytes=295</span><br><span class="line">		Input split bytes=89</span><br><span class="line">		Combine input records=0</span><br><span class="line">		Combine output records=0</span><br><span class="line">		Reduce input groups=15</span><br><span class="line">		Reduce shuffle bytes=295</span><br><span class="line">		Reduce input records=22</span><br><span class="line">		Reduce output records=15</span><br><span class="line">		Spilled Records=44</span><br><span class="line">		Shuffled Maps =1</span><br><span class="line">		Failed Shuffles=0</span><br><span class="line">		Merged Map outputs=1</span><br><span class="line">		GC time elapsed (ms)=0</span><br><span class="line">		Total committed heap usage (bytes)=768606208</span><br><span class="line">	Shuffle Errors</span><br><span class="line">		BAD_ID=0</span><br><span class="line">		CONNECTION=0</span><br><span class="line">		IO_ERROR=0</span><br><span class="line">		WRONG_LENGTH=0</span><br><span class="line">		WRONG_MAP=0</span><br><span class="line">		WRONG_REDUCE=0</span><br><span class="line">	File Input Format Counters </span><br><span class="line">		Bytes Read=165</span><br><span class="line">	File Output Format Counters </span><br><span class="line">		Bytes Written=141</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>输出文件</p>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// part-r-00000</span><br><span class="line">一个	1</span><br><span class="line">世界	1</span><br><span class="line">你好	1</span><br><span class="line">前	1</span><br><span class="line">北京	2</span><br><span class="line">升起	1</span><br><span class="line">厉害	1</span><br><span class="line">天安门	4</span><br><span class="line">太阳	2</span><br><span class="line">好人	1</span><br><span class="line">小红	2</span><br><span class="line">我	1</span><br><span class="line">我爱	2</span><br><span class="line">是	1</span><br><span class="line">爱我	1</span><br></pre></td></tr></table></figure>



<p>天安门出现了4次，太阳、北京、我爱、小红各出现了2次。其他词汇各出现了一次。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>编码方式的探讨</title>
    <url>/blog/270.html</url>
    <content><![CDATA[<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是<code>255</code>（二进制11111111=十进制<code>255</code>），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</p>
<p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是<code>65</code>，小写字母z的编码是<code>122</code>。</p>
<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。</p>
<p>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>
<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>
<p>字母A用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p>
<p>字符0用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符’0’和整数0是不同的；</p>
<p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p>
<p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是<code>00000000 01000001</code>。</p>
<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">ASCII</th>
<th align="center">Unicode</th>
<th align="center">UTF-8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">01000001</td>
<td align="center">00000000 01000001</td>
<td align="center">01000001</td>
</tr>
<tr>
<td align="center">中</td>
<td align="center">X</td>
<td align="center">01001110 00101101</td>
<td align="center">11100100 10111000 10101101</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>关于博客的探讨</title>
    <url>/blog/1fe.html</url>
    <content><![CDATA[<p>好久没有更新博客了，最近在看一个与<a href="http://www.crazepony.com/">四轴飞行器</a>的有关网站时候，发现了一个好玩的<a href="http://beiyuu.com/">博客</a>。进一步了解后，知道github可以建立一个博客并绑定自己的域名。</p>
<p>百度关键词<code>hexo+github</code>，按照教程，终于自己也建立了一个<a href="http://mapan.win/">静态博客</a>，感觉清爽简洁许多。之前自己用的是wordpress博客，但是越用越感觉臃肿，再三思索后埔决定把Wordpress博客的内容全部转移过来。然后就弄成了现在的样子。</p>
<p><strong>按照网上流行的说法：</strong></p>
<blockquote>
<ul>
<li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li>
</ul>
</blockquote>
<p> 相信大多数博主都处于前两个阶段，现在github提供了一个page的服务，你可以随意用它做你想做的任何事情，当然包括搭建一个静态博客。国内的gitcaft是一个和github相仿的网站，想在被coding收购后，提供的服务更稳定了。由于是中文的，所以添加了许多个性化的设定和内容。相信国内的朋友选择conding也是一个很不错的选择。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>基于Arduino的蓝牙控制小车</title>
    <url>/blog/ae14.html</url>
    <content><![CDATA[<p>上学期买的小车套件和Arduino板子都还在吃灰，昨天兴致来了就准备一步步的整一个<br>首先找资料把ADXL345三轴加速度传感器调通了<br>然后把Arduino UNO板子和L293D电机驱动扩展板程序调通了<br>最后把蓝牙模块HC-05程序调通了。<br>三轴加速度传感器暂时还没想好怎么使用，so暂时来个蓝牙控制的小车好了。</p>
<p>手机下载蓝牙串口助手，设置串口发送 1 2 3 4 四个数字分别代表前进、后退、右拐、左拐</p>
<p>关于Arduino的编程语言<br>我想说和C语言对比，爽太多。<br>你根本不需要了解硬件怎么连接的，内部协议是什么。<br>因为有很多集成库，只需要会调用其中的API接口即可。<br>在8位单片机上搞面向对象开发，适合DIYer，适合初学者。</p>
<h1 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;AFMotor.h&quot;</span><br><span class="line"></span><br><span class="line">AF_DCMotor motor1(1);  //设置一号电机</span><br><span class="line">AF_DCMotor motor2(2);  //设置二号电机</span><br><span class="line">AF_DCMotor motor3(3);  //设置三号电机</span><br><span class="line">AF_DCMotor motor4(4);  //设置四号电机</span><br><span class="line">void setup()</span><br><span class="line">&#123;</span><br><span class="line">	Serial.begin(9600);  //串口设置波特率9600</span><br><span class="line">&#125;</span><br><span class="line">void Goahead(unsigned char i)  //前进</span><br><span class="line">&#123;</span><br><span class="line">	motor1.run(FORWARD);</span><br><span class="line">	motor1.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor2.run(FORWARD);</span><br><span class="line">	motor2.setSpeed(i);            </span><br><span class="line">	</span><br><span class="line">	motor3.run(FORWARD);</span><br><span class="line">	motor3.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor4.run(FORWARD);</span><br><span class="line">	motor4.setSpeed(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Back(unsigned char i)  //后退</span><br><span class="line">&#123;</span><br><span class="line">	motor1.run(BACKWARD);</span><br><span class="line">	motor1.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor2.run(BACKWARD);</span><br><span class="line">	motor2.setSpeed(i);            </span><br><span class="line">	</span><br><span class="line">	motor3.run(BACKWARD);</span><br><span class="line">	motor3.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor4.run(BACKWARD);</span><br><span class="line">	motor4.setSpeed(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Turn_Left(unsigned char i)  //左拐</span><br><span class="line">&#123;</span><br><span class="line">	motor1.run(BACKWARD);</span><br><span class="line">	motor1.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor2.run(FORWARD);</span><br><span class="line">	motor2.setSpeed(i);            </span><br><span class="line">	</span><br><span class="line">	motor3.run(FORWARD);</span><br><span class="line">	motor3.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor4.run(BACKWARD);</span><br><span class="line">	motor4.setSpeed(i);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Turn_Right(unsigned char i)  //右拐</span><br><span class="line">&#123;</span><br><span class="line">	motor1.run(FORWARD);</span><br><span class="line">	motor1.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor2.run(BACKWARD);</span><br><span class="line">	motor2.setSpeed(i);            </span><br><span class="line">	</span><br><span class="line">	motor3.run(BACKWARD);</span><br><span class="line">	motor3.setSpeed(i);  </span><br><span class="line">	</span><br><span class="line">	motor4.run(FORWARD);</span><br><span class="line">	motor4.setSpeed(i);  </span><br><span class="line">&#125;</span><br><span class="line">void stop()  //停止</span><br><span class="line">&#123;</span><br><span class="line">	motor1.run(RELEASE);</span><br><span class="line">	motor2.run(RELEASE);</span><br><span class="line">	motor3.run(RELEASE);</span><br><span class="line">	motor4.run(RELEASE);</span><br><span class="line">&#125;</span><br><span class="line">void loop()</span><br><span class="line">&#123;</span><br><span class="line">	while (Serial.available() &gt; 0) </span><br><span class="line">	&#123;</span><br><span class="line">		int inChar = Serial.read();</span><br><span class="line">		inChar=inChar-0x30;</span><br><span class="line">		if(inChar == 1)  //前进</span><br><span class="line">		&#123;</span><br><span class="line">			Goahead(250);</span><br><span class="line">			delay(300);</span><br><span class="line">			stop();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(inChar == 2)  //后退</span><br><span class="line">		&#123;</span><br><span class="line">			Back(250);</span><br><span class="line">			delay(300);</span><br><span class="line">			stop();</span><br><span class="line">		&#125;</span><br><span class="line">		else if(inChar == 3)  //右转</span><br><span class="line">		&#123;</span><br><span class="line">			Turn_Right(250);</span><br><span class="line">			delay(300);</span><br><span class="line">			stop();</span><br><span class="line">		&#125; </span><br><span class="line">		else if(inChar == 4)  //左转</span><br><span class="line">		&#123;</span><br><span class="line">			Turn_Left(250);</span><br><span class="line">			delay(300);</span><br><span class="line">			stop();</span><br><span class="line">		&#125; </span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			stop();  //停止</span><br><span class="line">		&#125; </span><br><span class="line">	</span><br><span class="line">		inChar=0; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>Arduino Uno</li>
<li>L293D模块</li>
<li>小车底盘模块</li>
<li>18650电池 x 2</li>
<li>HC-05 蓝牙模块</li>
</ul>
<p>视频暂时还没录制，等哪天有心情了录一个。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo+Github二级域名的设置</title>
    <url>/blog/b1fb.html</url>
    <content><![CDATA[<p>见到有的博主用二级目录或者二级域名做了博客中英文双版本<br>自己想弄一个二级域名把主页和博客分开。这样主页可以写个人介绍，自己喜欢的话，博客的链接···<br>whatever you want！</p>
<p> 双语言、子目录方法</p>
<blockquote>
<ul>
<li>中文在<code>domain.com/cn</code> </li>
<li>英文在<code>domain.com/en</code> </li>
</ul>
</blockquote>
<p> 子域名方法</p>
<blockquote>
<ul>
<li>首页页在<code>www.domain.com</code></li>
<li>博客在<code>blog.doami.com</code></li>
</ul>
</blockquote>
<p>当然不限于 <code>首页和博客</code> 、<code>中文和英文</code>  anything you want！</p>
<p>在百度找教程然后自己摸索，总结一下我设置子域名的方法<br>假设你注册了domain.com域名，来建立hexo博客。并且想在github和coding双部署实现国内海外分流</p>
<p>我在在万网注册的域名。设置如下：</p>
<table>
<thead>
<tr>
<th align="center">记录类型</th>
<th align="center">主机记录</th>
<th align="center">解析线路</th>
<th align="center">记录值</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CNAME</td>
<td align="center">@</td>
<td align="center">默认</td>
<td align="center">pages.coding.me.</td>
<td align="center">(国内线路)<br>domain.com<br>解析到coding</td>
</tr>
<tr>
<td align="center">CNAME</td>
<td align="center">blog</td>
<td align="center">默认</td>
<td align="center">pages.coding.me.</td>
<td align="center">(国内线路)<br>blog.domain.com<br>解析到coding</td>
</tr>
<tr>
<td align="center">CNAME</td>
<td align="center">@</td>
<td align="center"><strong>海外</strong></td>
<td align="center">xxx.github.io.</td>
<td align="center">(海外线路)<br>domain.com<br>解析到github</td>
</tr>
<tr>
<td align="center">CNAME</td>
<td align="center">blog</td>
<td align="center"><strong>海外</strong></td>
<td align="center">xxx.github.io.</td>
<td align="center">(海外线路)<br>blog.domain.com<br>解析到github</td>
</tr>
</tbody></table>
<p>（其中<em>xxx为你的github用户名</em>）</p>
<p>如果只需要设置coding，只需要前两项记录就可以了，github是后两项。<br>双部署的就是4项全设置。</p>
<p>双部署的话，coding和github都需要设置，coding和github方法大致一样，我只介绍github的部署<br>在github分别建立两个repository</p>
<blockquote>
<ul>
<li><code>博客repo</code></li>
<li><code>首页repo</code></li>
</ul>
</blockquote>
<p>姑且先这样称呼这两个repository。</p>
<p>其中</p>
<blockquote>
<p><code>博客repo</code>的名字为 yourusername.github.io<br><code>首页ropo</code> 的名字随意起， 我写的是home</p>
</blockquote>
<p>.</p>
<blockquote>
<p><code>博客ropo</code>中在master分支来建立博客内容，CNAME文件中写入  <code>blog.domain.com</code><br><code>博客ropo</code>中的CNAME的作用是把 blog.domain.com —&gt;  user.github.io  </p>
</blockquote>
<p>.</p>
<blockquote>
<p><code>首页ropo</code>在<code>gh-page</code>分支（master分支也可以）建立index.html文件(自定义),CNAME文件中写入<code>domain.com</code></p>
</blockquote>
<blockquote>
<p><code>首页ropo</code>中是一定要有index.html文件的，我是直接找到一份自己喜欢的静态html然后fork。可以直接upload上去，或者代码粘贴到github，此时可以通过域名username.github.io/home 直接当问该静态网页。 (<code>home</code>是<code>首页ropo</code>的名称)</p>
</blockquote>
<blockquote>
<p><code>首页ropo</code>中的CNAME文件作用是把 domain.com —&gt; username.github.io/home </p>
</blockquote>
<p>然后设置coding，过程和github基本一样，不再赘述，只说下不同点：</p>
<p>当然这是我目前的方法，如果你有更简单方便的方法，欢迎分享。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>语音合成</title>
    <url>/blog/2fd4.html</url>
    <content><![CDATA[<p>毕设题目这几天就要确定了，我要做的是 <strong>交互式语音家居控制系统的设计</strong><br>由于需要<em>文字</em>—&gt;<em>语音</em>的转换，刚开始想用自己的声音用手机录，后来感觉自己的声音不太好听，也没有一个标准。所以就打算使用合成语音。</p>
<p>在网上搜索了下，找到的是 <a href="http://www.xfyun.cn/default/online_demo/">科大讯飞</a> 和 <a href="http://yuyin.baidu.com/#try">百度语音</a>两家提供语音转文字的服务商，两个网站均只能在网站上试用，不能生成MP3等音频文件。</p>
<p>改变关键词再次搜索后找到了一个比较好用的软件<a href="http://www.443w.com/tts/"><strong>朗读女</strong></a> ，下载安装后，可以使用本地发音人(离线使用)，或者科大讯飞的在线语音合成服务(必须联网)，其中<code>童声楠楠</code>这个声音比较好听，所以决定使用这个作为我的毕业设计制作的发音人。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>旋转星空作为网页背景</title>
    <url>/blog/a414.html</url>
    <content><![CDATA[<p>最近看到一个网站首页网址是cpasem点com，背景动画特别炫，旋转星空的背景。经过分析，完全是使用js代码实现。有点厉害了！</p>
<p>所以决定爬下来，一探究竟。页面做的保护措施很好，鼠标不能右键单击，F12看源码，许多代码也隐藏的很深。不过，有句话叫做：没有爬不到的网站。</p>
<p>我的做法是直接CTRL+s保存全部网页内容，在本地一点点的分析查看。可无奈有些内容根本下载不了好伐！（看来防护措施做的还挺好，站主还是有一些水平的）比如一些特效的图片，这样的话，一个鼠标经过的特效就没有了。不过怎么能难的倒我，方法总是有的。F12继续查看图片的绝对地址，复制后浏览器新窗口打开，然后右键保存。这样图片问题就解决了。</p>
<p>然后就是删除一堆无用的Js，诸如CNZZ统计，BGM，还有别的一些不知道干嘛使的JS。最后修改网站的内容，大致结构保持不变，按照本博客的首页排版，做了一个页面，预览<a href="/night/index.html">demo</a>。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>HEX和BCD互转</title>
    <url>/blog/2817.html</url>
    <content><![CDATA[<p>在一些时钟芯片当中，常常使用BCD码来存储年月日时分秒的数据<br>这个时候为了方便操作，我们就需要进行BCD⇔HEX相互的转换</p>
<p>BCD→HEX的子程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char BCD2HEX(uchar val)</span><br><span class="line">&#123;</span><br><span class="line">	return	((val&gt;&gt;4)*10)+(val&amp;0x0f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HEX→BCD的子程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char HEX2BCD(uchar val)</span><br><span class="line">&#123;</span><br><span class="line">	return	(((val%100)/10)&lt;&lt;4)|(val%10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用C语言编写，可以直接移植到想要使用的地方。<br>使用方法不再赘述。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>单片机IO口模拟I2C时序驱动AT24C32</title>
    <url>/blog/e12d.html</url>
    <content><![CDATA[<p>AT24C32和驱动和AT24C02基本一致。由于容量增加了，数据地址的地址由原来的8位也相应的增加到16位。</p>
<table>
<thead>
<tr>
<th align="center">芯片</th>
<th align="center">容量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AT24C01</td>
<td align="center">128字节</td>
</tr>
<tr>
<td align="center">AT24C02</td>
<td align="center">256字节</td>
</tr>
<tr>
<td align="center">AT24C04</td>
<td align="center">512字节</td>
</tr>
<tr>
<td align="center">AT24C08</td>
<td align="center">1K字节</td>
</tr>
<tr>
<td align="center">AT24C016</td>
<td align="center">2K字节</td>
</tr>
<tr>
<td align="center">AT24C0132</td>
<td align="center">4K字节</td>
</tr>
<tr>
<td align="center">AT24C064</td>
<td align="center">8K字节</td>
</tr>
<tr>
<td align="center">AT24C0128</td>
<td align="center">16K字节</td>
</tr>
<tr>
<td align="center">AT24C0256</td>
<td align="center">32K字节</td>
</tr>
<tr>
<td align="center">AT24C0512</td>
<td align="center">64K字节</td>
</tr>
</tbody></table>
<p>1字节 = 1 Byte</p>
<p>以下程序适用于上面型号的EEPROM芯片<br>使用22.1184MHz晶振、读出的数据送P0口显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;reg52.h&quot; </span><br><span class="line">#include &quot;intrins.h&quot;  </span><br><span class="line"></span><br><span class="line">#define uchar unsigned char </span><br><span class="line">#define uint unsigned int </span><br><span class="line"></span><br><span class="line">sbit sda=P3^7;//;模拟I2C 数据 </span><br><span class="line">sbit scl=P3^6;//;模拟I2C 时钟 </span><br><span class="line"></span><br><span class="line">void delay1(uint z)//延时为 1ms </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a,b,i;</span><br><span class="line">	for(i=0;i&lt;z;i++)</span><br><span class="line">		for(b=80;b&gt;0;b--)</span><br><span class="line">			for(a=10;a&gt;0;a--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void delay()//5us延时 </span><br><span class="line">  //22.1184误差 -0.1171875us</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char a;</span><br><span class="line">    for(a=3;a&gt;0;a--);</span><br><span class="line">&#125;</span><br><span class="line">void star()//开始 </span><br><span class="line">&#123; </span><br><span class="line">	sda=1; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line">	scl=1; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line">	sda=0; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void stop()//停止 </span><br><span class="line">&#123; </span><br><span class="line">	sda=0; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line">	scl=1; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line">	sda=1; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void ack()//应答 </span><br><span class="line">&#123; </span><br><span class="line">	uchar z=0; </span><br><span class="line">	while((sda==1)&amp;&amp;(z&lt;50))z++;//条件判断， sda=1，则没有应答。如果没有应答则延时：z&lt;50，z++;后返回 </span><br><span class="line">	scl=0; </span><br><span class="line">	delay();//5us延时 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void write(uchar slave_write_address,uchar byte_High_address,uchar byte_Low_address,uchar data_data)//写一个数据 </span><br><span class="line">&#123; </span><br><span class="line">	uchar temp,temp1,i,ii; </span><br><span class="line"></span><br><span class="line">	star();//开始 </span><br><span class="line"></span><br><span class="line">	for(ii=0;ii&lt;4;ii++)//根据 24CXX文档资料，和时序图，按顺序送：器件写地址，字节地址，数据 </span><br><span class="line">	&#123;  </span><br><span class="line">		if(ii==0) </span><br><span class="line">		&#123; </span><br><span class="line">		temp=slave_write_address;//送 器件写地址 </span><br><span class="line">		temp1=slave_write_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==1) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=byte_High_address;//送 字节高地址 </span><br><span class="line">			temp1=byte_High_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==2) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=byte_Low_address;//送 字节低地址 </span><br><span class="line">			temp1=byte_Low_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==3) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=data_data;//送 数据 </span><br><span class="line">			temp1=data_data; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for(i=0;i&lt;8;i++) </span><br><span class="line">		&#123; </span><br><span class="line">			scl=0; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			temp=temp1; </span><br><span class="line">			temp=temp&amp;0x80;// 相 与 后，把不相关的位清零 </span><br><span class="line"></span><br><span class="line">			if(temp==0x80)//根据前面 相 与 后，判断 temp是否等于0x80，是则该位为 1 </span><br><span class="line"></span><br><span class="line">			sda=1;  </span><br><span class="line">			else </span><br><span class="line">			sda=0; </span><br><span class="line"></span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			scl=1; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			scl=0; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			temp1=temp1&lt;&lt;1;//向左移出1位 </span><br><span class="line"></span><br><span class="line">		&#125; </span><br><span class="line">		sda=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		scl=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		ack(); </span><br><span class="line">	&#125; </span><br><span class="line">	stop();//停止 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(uchar slave_write_address,byte_High_address,byte_Low_address,uchar slave_read_address)//读一个数据 </span><br><span class="line">&#123; </span><br><span class="line">	uchar temp,temp1,i,ii,x,data_data; </span><br><span class="line"></span><br><span class="line">	star();//开始 </span><br><span class="line"></span><br><span class="line">	for(ii=0;ii&lt;4;ii++)//根据 24CXX文档资料，和时序图，按顺序送：器件写地址，字节地址，器件读地址 </span><br><span class="line">	&#123;  </span><br><span class="line">		if(ii==0) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=slave_write_address;//送 器件写地址 </span><br><span class="line">			temp1=slave_write_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==1) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=byte_High_address;//送 字节高地址 </span><br><span class="line">			temp1=byte_High_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==2) </span><br><span class="line">		&#123; </span><br><span class="line">			temp=byte_Low_address;//送 字节低地址 </span><br><span class="line">			temp1=byte_Low_address; </span><br><span class="line">		&#125; </span><br><span class="line">		else if(ii==3) </span><br><span class="line">		&#123;  </span><br><span class="line">			star();//开始 </span><br><span class="line"></span><br><span class="line">			temp=slave_read_address;//送 器件读地址 </span><br><span class="line">			temp1=slave_read_address; </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">		  </span><br><span class="line"></span><br><span class="line">		for(i=0;i&lt;8;i++)//开始读数据 </span><br><span class="line">		&#123; </span><br><span class="line">			scl=0; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			temp=temp1; </span><br><span class="line">			temp=temp&amp;0x80;// 相 与 后，把不相关的位清零 </span><br><span class="line"></span><br><span class="line">			if(temp==0x80)//根据前面 相 与 后，判断 temp是否等于0x80，是则该位为 1 </span><br><span class="line"></span><br><span class="line">			sda=1;  </span><br><span class="line">			else </span><br><span class="line">			sda=0; </span><br><span class="line"></span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			scl=1; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			scl=0; </span><br><span class="line">			delay();//5us延时 </span><br><span class="line">			temp1=temp1&lt;&lt;1;//向左移出1位 </span><br><span class="line">		&#125; </span><br><span class="line">		sda=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		scl=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		ack();//应答 </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	for(x=0;x&lt;8;x++) </span><br><span class="line">	&#123; </span><br><span class="line">		data_data=data_data&lt;&lt;1;//向左移入1位 </span><br><span class="line"></span><br><span class="line">		sda=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		scl=0; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line">		scl=1; </span><br><span class="line">		delay();//5us延时 </span><br><span class="line"></span><br><span class="line">		if(sda==1)//判断 数据线是否是高电平 </span><br><span class="line">		data_data|=0x01;//把读到的数据 或 0X01  </span><br><span class="line">		//else  </span><br><span class="line">		//data_data|=0x00; </span><br><span class="line">	&#125; </span><br><span class="line">	ack();//应答 </span><br><span class="line">	stop();//停止 </span><br><span class="line">	return data_data;//返回读到的数据 </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void main() </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">	write(0xa0,0x00,0x01,0xaa);//向器件写一个数据: </span><br><span class="line">	//（0xa0 是器件写地址；0x00 是字节高地址；0x01 是字节低地址；0x66 是待写入的数据） </span><br><span class="line"></span><br><span class="line">	delay1(5);//写与读的时间间隔应大于5ms,取决于器件 24C02的响应速度 </span><br><span class="line"></span><br><span class="line">	//向器件读一个数据 </span><br><span class="line">	//把读出的数据送 P1口显示 </span><br><span class="line">	P0=read(0xa0,0x00,0x01,0xa1);//向器件读一个数据： </span><br><span class="line">	//（0xa0 是器件写地址；0x00 是字节高地址；0x01 是字节低地址；0xa1 是器件读地址） </span><br><span class="line"></span><br><span class="line">	while(1);//跳转，相当于汇编指令 JUMP $ </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>基于51单片机的心形全彩灯</title>
    <url>/blog/b1d.html</url>
    <content><![CDATA[<p>这是2014年做的，想要做这个已经想了很久，从构思到设计焊接完成大概花了1个多月的课余时间。</p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/blog/b1d/005vwoCygy1fl3zv41ailj30hs0daadd.jpg" class="">

<p>放在我的电脑上面</p>
<img src="/blog/b1d/005vwoCygy1fl3zvdqtd6j30hs0daq65.jpg" class="">


<p>特殊的<em>三层板</em>。。底层是起固定和保护作用的。最上面的小板是51的最小系统。中间的才是主要的驱动层。</p>
<p>再来一张正面照片</p>
<img src="/blog/b1d/005vwoCygy1fl3zvjnv0lj30d90hs0vg.jpg" class="">

<p>欣赏完效果图 我就来简单说一下制作过程吧。</p>
<h3 id="BOM-："><a href="#BOM-：" class="headerlink" title="BOM ："></a>BOM ：</h3><ul>
<li>51单片机最小系统（其他单片机也可以，我选的是STC89C52RC）</li>
<li>74HC595锁存器 5个</li>
<li>74HC573锁存器 3个</li>
<li>共阴三色彩灯 40个</li>
<li>四位共阴数码管 1个</li>
<li>10cm X 15cm覆铜板两块</li>
<li>排针 若干</li>
<li>导线 若干（跳线用到）</li>
<li>限流电阻若干15个左右 （约500欧姆）</li>
<li>按键2个</li>
</ul>
<p>我把 原理图 和 走线图 贴上来供大家参考，我相信我做的不是最好，希望想仿制的朋友能够进行改进</p>
<p>这是74HC595的接法（我用的是贴片的，体积小 易焊接，价格合适）</p>
<img src="/blog/b1d/005vwoCygy1fl3zvw6tk9j30hs05kq41.jpg" class="">

<p>这是三色雾状彩灯的接法。上面的0805是限流电阻，我用的是贴片封装的，比较省空间</p>
<img src="/blog/b1d/005vwoCygy1fl3zw6ett3j30hs0d0jv1.jpg" class="">

<p>这是51系统小板和74HC573的接法了，为了提高速度，充分利用GPIO口，我直接把OE接低电平 LE接到高电平了。这样使用相当于74HC573是透明的，仅仅起驱动（放大电流）作用。</p>
<img src="/blog/b1d/005vwoCygy1fl3zwdm9w3j30hs0bumzy.jpg" class="">


<p>这是51系统小板的PCB布局走线，可以拿来参考下。</p>
<img src="/blog/b1d/005vwoCygy1fl3zwnnopsj30hs07g0um.jpg" class="">

<p>下面是重头戏了。每个灯都是四个引脚，一个共阴极脚，三个颜色的阳极脚。有40个彩灯，分为5组，每组的同样的颜色引脚接一起（采用搭桥式焊接法，布 线的时候我并没有接）。所有灯的阴极全部引出，接到74HC595锁存器上面。5组灯，每组三种颜色，引出三条线，5组即3 X 5=15条线 ， 接到两个74HC573的输出端。剩下的一个74HC573用来驱动共阴数码管。</p>
<img src="/blog/b1d/005vwoCygy1fl3zwvdl0dj30hs0cjn1r.jpg" class="">


<h3 id="灯引脚的折法"><a href="#灯引脚的折法" class="headerlink" title="灯引脚的折法"></a>灯引脚的折法</h3><p>灯买回来的时候间距是50mil，我们手工做不出来这么精细的板子。所以要把引脚折一下，方便焊接 也同时增大了引脚间距（折成100mil）。</p>
<img src="/blog/b1d/005vwoCygy1fl3zx43yxdj30hs09sdh4.jpg" class="">


<p>总结一下：</p>
<blockquote>
<p>采用51单片机接5个74HC595 进行阴极驱动。2个74HC573驱动灯的阳极，剩下一个74HC573驱动数码管阳极.</p>
</blockquote>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>第一版透明灯珠<br><video  width="100%" height="100%" src="https://mpn.gitee.io/video/bd10.mp4" controls="controls"><br>第1版<br></video></p>
<p>第二版 雾灯珠<br><video  width="100%" height="100%" src="https://mpn.gitee.io/video/b1d.mp4" controls="controls"><br>改进版<br></video></p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Java方法重载</title>
    <url>/blog/3e88.html</url>
    <content><![CDATA[<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>我们假设要在程序中实现一个对数字求和的方法，由于参与求和数字的个数和类型都不确定，因此要针对不同的情况去设计不同的方法。接下来通过一个案例来实现对两个整数相加、对三个整数相加以及对两个小数相加的功能，具体实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo02</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面是针对求和方法的调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> add01(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> add02(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum3</span> <span class="operator">=</span> add03(<span class="number">1.2</span>, <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 下面的代码是打印求和的结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sum1=&quot;</span> + sum1);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum2=&quot;</span> + sum2);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum3=&quot;</span> + sum3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的方法实现了两个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add01</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面的方法实现了三个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add02</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面的方法实现了两个小数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add03</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示。</p>
<p>从上述代码不难看出，程序需要针对每一种求和的情况都定义一个方法，如果每个方法的名称都不相同，在调用时就很难分清哪种情况该调用哪个方法。<br><strong>为了解决这个问题，Java允许在一个类中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。</strong></p>
<p>下面的三个方法互为重载关系</p>
<blockquote>
<p><code>public static int add(int x,int y) &#123;逻辑&#125; //两个整数加法</code><br><code>public static int add(int x,int y,int z) &#123;逻辑&#125; //三个整数加法</code><br><code>public static int add(double x,double y) &#123;逻辑&#125; //两个小数加法</code></p>
</blockquote>
<p>接下来通过方法重载的方式进行修改，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodDemo03</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面是针对求和方法的调用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum2</span> <span class="operator">=</span> add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum3</span> <span class="operator">=</span> add(<span class="number">1.2</span>, <span class="number">2.3</span>);</span><br><span class="line">        <span class="comment">// 下面的代码是打印求和的结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sum1=&quot;</span> + sum1);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum2=&quot;</span> + sum2);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum3=&quot;</span> + sum3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的方法实现了两个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面的方法实现了三个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y + z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面的方法实现了两个小数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果和MethodDemo03.java一样，如下图所示。</p>
<p>上述代码中定义了三个同名的add()方法，它们的参数个数或类型不同，从而形成了方法的重载。<br>在main()方法中调用add()方法时，通过传入不同的参数便可以确定调用哪个重载的方法，如add(1,2)调用的是两个整数求和的方法。值得注意的是，方法的重载与返回值类型无关，它只有两个条件，一是方法名相同，二是参数个数或参数类型不相同。</p>
<h2 id="a-重载的注意事项"><a href="#a-重载的注意事项" class="headerlink" title="a)重载的注意事项"></a>a)重载的注意事项</h2><h5 id="重载方法参数必须不同："><a href="#重载方法参数必须不同：" class="headerlink" title="重载方法参数必须不同："></a>重载方法参数必须不同：</h5><blockquote>
<p>参数个数不同，如<code>method(int x)与method(int x,int y)</code>不同<br>参数类型不同，如<code>method(int x)与method(double x)</code>不同<br>参数顺序不同，如<code>method(int x,double y)与method(double x,int y)</code>不同</p>
</blockquote>
<h5 id="重载只与方法名与参数类型相关与返回值无关"><a href="#重载只与方法名与参数类型相关与返回值无关" class="headerlink" title="重载只与方法名与参数类型相关与返回值无关"></a>重载只与方法名与参数类型相关与返回值无关</h5><blockquote>
<p>如<code>void method(int x)</code>与<code>int method(int y)</code>不是方法重载，不能同时存在</p>
</blockquote>
<h5 id="重载与具体的变量标识符无关"><a href="#重载与具体的变量标识符无关" class="headerlink" title="重载与具体的变量标识符无关"></a>重载与具体的变量标识符无关</h5><blockquote>
<p>如<code>method(int x)</code>与<code>method(int y)</code>不是方法重载，不能同时存在</p>
</blockquote>
<h2 id="b-参数传递"><a href="#b-参数传递" class="headerlink" title="b)参数传递"></a>b)参数传递</h2><p>参数传递，可以理解当我们要调用一个方法时，我们会把指定的数值，传递给方法中的参数，这样方法中的参数就拥有了这个指定的值，可以使用该值，在方法中运算了。这种传递方式，我们称为参数传递。</p>
<p>在这里，定义方法时，参数列表中的变量，我们称为形式参数</p>
<p>调用方法时，传入给方法的数值，我们称为实际参数</p>
<p>我们看下面的两段代码，来明确下参数传递的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgumentsDemo01</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line">        change(a, b);<span class="comment">//调用方法时，传入的数值称为实际参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//方法中指定的多个参数称为形式参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">200</span>;</span><br><span class="line">        b=<span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>程序的运行结果如下：
</code></pre>
<p>再看另一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArgumentsDemo02</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        change(arr);<span class="comment">// 调用方法时，传入的数值称为实际参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &amp;lt; arr.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> <span class="comment">// 方法中指定的多个参数称为形式参数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &amp;lt; arr.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">             arr[i] *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果如下：</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java键盘输入函数</title>
    <url>/blog/e997.html</url>
    <content><![CDATA[<p>和C语言中的<code>scanf</code>函数一样，Java中同样有键盘键入的库<br>测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入数字：&quot;</span>);</span><br><span class="line">		<span class="comment">//通过对象调方法</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sd.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;您刚才输入的数字是&quot;</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面一个计算年龄的程序，输入自己的出生年份，会计算输出自己的年龄，有一个判断简单的判断，如果键入的出生年份不合法会要求重新输入，当然代码的鲁棒性还有待提高，如果输入一个非数字字符，程序依然会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入出生年份：&quot;</span>);</span><br><span class="line">		<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> pq.nextInt();</span><br><span class="line">		<span class="keyword">while</span>(i&gt;<span class="number">2019</span>||i&lt;<span class="number">1900</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;年龄输入错误，请重新输入&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入出生年份：&quot;</span>);</span><br><span class="line">			i = pq.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;你的年龄是&quot;</span>+(<span class="number">2019</span>-i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运算结果如下</p>
<p>另外发现Java的代码规范有不同的习惯，可以分为两种。<br>一种如下，这是Java官方推荐的代码规范，左花括号直接跟在上一行的后面，不在另起一行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++)</span><br><span class="line">            System.out.print(i == <span class="number">0</span> ? args[i] : <span class="string">&quot; &quot;</span> + args[i]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种如下，这是一种C语言风格的规范，花括号上下对应，成对出现。代码格式一目了然，看起来更舒服。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++)</span><br><span class="line">            System.out.print(i == <span class="number">0</span> ? args[i] : <span class="string">&quot; &quot;</span> + args[i]);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于学习的第一门变成语言是C语言，所以个人更倾向于后者的代码格式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>开关三极管的剖析</title>
    <url>/blog/dcaf.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在数字电路设计的中，往往需要把数字信号经过开关扩流器件来驱动一些蜂鸣器、LED、继电器等需要较大电流的器件，用得最多的开关扩流器件要数三极 管。然而 在使用的过程中，如果电路设计不当，三极管无法工作在正常的开关状态，就达不到预期的目的，有时就是因为这些小小的错误而导致重新打板，导致浪费。本人在 这个方面就吃过亏，所以把自己使用三极管的一些经验以及一些常见的误区给大家分享一下，在电路设计的过程中可以减少一些不必要的麻烦。</p>
<img src="/blog/dcaf/005vwoCygy1fl3zrcs294j30b408cjrn.jpg" class="各种三极管">



<p>下面来看几个三极管做开关的常用电路画法。几个例子都是蜂鸣器作为被驱动器件。</p>
<img src="/blog/dcaf/005vwoCygy1fl3zo0gp41j30of0bb40b.jpg" class="图一">


<p>图一的a 电路用的是NPN管，注意蜂鸣器接在三极管的集电极，驱动信号可以是常见的3.3V或者5VTTL，高电平开通，电阻按照经验法可以取4.7K。 例如a电路，开通时假设为高电平5V，基极电流Ib=(5V-0.7V)/4.7K=0.9mA，可以使三极管完全饱和。b 电路用的是PNP管，同样把 蜂鸣器接在三极管的集电极，不同的是驱动信号是5V的TTL电平。以上这两个都可以正常工作，只要PWM驱动信号工作在合适的频率，蜂鸣器（有源）都会发 出最大的声音。</p>
<img src="/blog/dcaf/005vwoCygy1fl3zsexf1qj30m009tmyn.jpg" class="" title="图二">

<p>图二的这两个电路相比图一来说，最大的区别在于被驱动器件接在三极管的发射极。同样看c电路，开通时假设为高电平5V，基极电流Ib=(5V- 0.7V- UL)/4.7K，其中UL为被驱动器件上的压降。可以看到，同样取基极电阻为4.7K，流过的基极电流会比图一a电路的要小，小多少要看UL是多少。如 果UL比较大，那么相应的Ib就小，很有可能导致三极管无法工作在饱和状态，使得被驱动器件无法动作。有人会说把基极电阻减小就可以了呀，可是被驱动器件 的压降是很难获知的，有些被驱动器件的压降是变动的，这样一来基极电阻就较难选择合适的值，阻值选择太大就会驱动失败，选择太小，损耗又变大。所以，在非 不得已的情况下，不建议选用图二的这两种电路。</p>
<img src="/blog/dcaf/005vwoCygy1fl3zt3t9caj30oa0apwg4.jpg" class="" title="图三">

<p>我们再来看图三这两个电路。驱动信号为3.3VTTL电平，而被驱动器件开通电压需要5V。在3.3V的MCU电路中，不小心的话很容易就设计出这 两种电 路，而这两种电路都是错误的。先分析e电路，这是典型的“发射极正偏，集电极反偏”的放大电路，或者叫射极输出器。当PWM信号为3.3V时，三极管发射 极电压为3.3V-0.7V = 2.6V，无法达到期望的5V。图三f电路也是一个很失败的电路，首先这个电路开通是没有问题的，当驱动信号为低电平 时，被驱动器件可以正常动作。然而这个电路是无法关断的，当驱动信号PWM为3.3V高电平的时候，Ube = 5V – 3.3V = 1.7V仍然可 以使三极管开通，于是无法关断。在这里，有人会说用过这个电路，没有问题啊，而且MCU的电压也是3.3V。我说你用的肯定是OD（开漏）驱动方式，而且 是真正的OD或者是5V容忍的OD，比如STM32的很多IO口都可以设置为5V容忍的OD驱动方式（但是有些是不行的）。当驱动信号为OD门驱动方式 时，输出高电平，信号就变成了高阻态，流过基极的电流为零，三极管可以有效关断，这个时候f电路依然有效。</p>
<img src="/blog/dcaf/005vwoCygy1fl3ztj5htxj30oa0csq4y.jpg" class="" title="图四">

<p>综合以上几种电路的情况分析，得到图四这两种个人认为是最优的驱动电路，与图一不同的是，图四在基极与发射极之间多加了一个100K的电阻，这个电 阻也是有 一定作用的，可以让三极管有一个已知的默认状态。当输入信号去除的时候，三极管还处于关断状态。在安全和稳定的方面考虑，多加的这个电阻还是很有必要的， 或者说可以让三极管工作在更好的开关状态。<br>三极管作为开关器件，虽然驱动电路很简单，要使电路工作更加稳定可靠，还是不能掉以轻心。为了不容易出错，个人建议是优先采用图四的电路，尽量不采用图二的电路，避免使用图三的工作状况。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Java循环应用</title>
    <url>/blog/172d.html</url>
    <content><![CDATA[<h3 id="一、-通过for循环遍历1-100共计100个整数，求出其中偶数的和。代码如下："><a href="#一、-通过for循环遍历1-100共计100个整数，求出其中偶数的和。代码如下：" class="headerlink" title="一、 通过for循环遍历1-100共计100个整数，求出其中偶数的和。代码如下："></a>一、 通过for循环遍历1-100共计100个整数，求出其中偶数的和。代码如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：求出1-100之间偶数和</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 		A:定义求和变量，初始化值是0</span></span><br><span class="line"><span class="comment"> * 		B:获取1-100之间的数据，用for循环实现</span></span><br><span class="line"><span class="comment"> * 		C:把获取到的数据进行判断，看是否是偶数</span></span><br><span class="line"><span class="comment"> * 			如果是，就累加</span></span><br><span class="line"><span class="comment"> * 		D:输出求和结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuShu</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//获取1-100之间的数据，用for循环实现</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=<span class="number">100</span>; x++) &#123;</span><br><span class="line">			<span class="comment">//把获取到的数据进行判断，看是否是偶数</span></span><br><span class="line">			<span class="keyword">if</span>(x%<span class="number">2</span> ==<span class="number">0</span>) &#123;</span><br><span class="line">				sum += x;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;一百以内的偶数的和是：&quot;</span>+sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二-、for循环实现在控制台打印水仙花数"><a href="#二-、for循环实现在控制台打印水仙花数" class="headerlink" title="二 、for循环实现在控制台打印水仙花数"></a>二 、for循环实现在控制台打印水仙花数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：在控制台输出所有的”水仙花数”</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 		什么是水仙花数呢?</span></span><br><span class="line"><span class="comment"> * 			所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。</span></span><br><span class="line"><span class="comment"> *			举例：153就是一个水仙花数。</span></span><br><span class="line"><span class="comment"> *			153 = 1*1*1 + 5*5*5 + 3*3*3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		A:三位数其实就告诉了我们水仙花数的范围</span></span><br><span class="line"><span class="comment"> *			100-999</span></span><br><span class="line"><span class="comment"> *		B:如何获取一个数据的每一个位上的数呢?</span></span><br><span class="line"><span class="comment"> *			举例：我有一个数据153，请问如何获取到个位，十位，百位</span></span><br><span class="line"><span class="comment"> *			个位：153%10 = 3;</span></span><br><span class="line"><span class="comment"> *			十位：153/10%10 = 5;</span></span><br><span class="line"><span class="comment"> *			百位：153/10/10%10 = 1;</span></span><br><span class="line"><span class="comment"> *			千位：...</span></span><br><span class="line"><span class="comment"> *			万位：...</span></span><br><span class="line"><span class="comment"> *		C:让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//通过循环获取到每一个三位数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">100</span>; x&lt;<span class="number">1000</span>; x++) &#123;</span><br><span class="line">			<span class="comment">//获取个位，十位，百位</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> x%<span class="number">10</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">shi</span> <span class="operator">=</span> x/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">bai</span> <span class="operator">=</span> x/<span class="number">10</span>/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">			<span class="comment">//让每个位上的立方和相加，并和该数据进行比较，如果相等，就说明该数据是水仙花数，在控制台输出</span></span><br><span class="line">			<span class="keyword">if</span>((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) &#123;</span><br><span class="line">				System.out.println(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-、-while循环实现1-100之间数据求和"><a href="#三-、-while循环实现1-100之间数据求和" class="headerlink" title="三 、 while循环实现1-100之间数据求和"></a>三 、 while循环实现1-100之间数据求和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 求1-100之和。</span></span><br><span class="line"><span class="comment"> * 练习：统计水仙花个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhileTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;	</span><br><span class="line">		<span class="comment">//while循环实现</span></span><br><span class="line">		<span class="comment">//定义求和变量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(x&lt;=<span class="number">100</span>) &#123;</span><br><span class="line">			sum += x;</span><br><span class="line">			x++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;1-100的和是：&quot;</span>+sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>  <code>while</code> <code>do...while</code>三种循环的区别<br>区别概述<br>虽然可以完成同样的功能，但是还是有小区别：</p>
<ul>
<li><code>do…while</code>循环至少会执行一次循环体。</li>
<li>for<code>循环和</code>while`循环只有在条件成立的时候才会去执行循环体</li>
<li><code>for</code>循环语句和<code>while</code>循环语句的小区别：</li>
</ul>
<p>使用区别：</p>
<ul>
<li>控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了</li>
<li><code>while</code>循环结束还可以继续使用，如果你想继续使用，就用<code>while</code>，否则推荐使用<code>for</code>。原因是<code>for</code>循环结束，该变量就从内存中消失，能够提高内存的使用效率。</li>
</ul>
<h3 id="四、控制跳转语句练习"><a href="#四、控制跳转语句练习" class="headerlink" title="四、控制跳转语句练习"></a>四、控制跳转语句练习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopDemo4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>; x&lt;=<span class="number">10</span>; x++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//2次输出</span></span><br><span class="line">				<span class="comment">//continue;//7次输出</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;x:&quot;</span>+x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if语句</code>里面是<code>break</code>的时候，输出如下：<br>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:1</span><br><span class="line">x:2</span><br></pre></td></tr></table></figure>

<p><code>if语句</code>里面是<code>continue</code>的时候时候，输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:1</span><br><span class="line">x:2</span><br><span class="line">x:4</span><br><span class="line">x:5</span><br><span class="line">x:7</span><br><span class="line">x:8</span><br><span class="line">x:10</span><br></pre></td></tr></table></figure>
<p>通过上面的例程可以区分 <code>break</code>和<code>continue</code>的作用。<br>其中<code>break</code>表示<strong>结束循环</strong>，<code>continue</code> 表示<strong>跳出本次循环</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java随机数生成</title>
    <url>/blog/c6cc.html</url>
    <content><![CDATA[<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDome</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="comment">//通过对象调方法，其中 r.nextInt(10)表示获取数据的返回范围是[0,10)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成3个100-999之间的随机数"><a href="#生成3个100-999之间的随机数" class="headerlink" title="生成3个100-999之间的随机数"></a>生成3个100-999之间的随机数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomDome</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建对象</span></span><br><span class="line">		<span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="comment">//通过对象调方法 ,其中 r.nextInt(10),表示获取数据的返回范围是[0,10)</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r.nextInt(<span class="number">900</span>);</span><br><span class="line">				<span class="comment">//此处(i+100)为了调整随机数的生成范围为100-999</span></span><br><span class="line">				System.out.println(<span class="string">&quot;i:&quot;</span>+(i+<span class="number">100</span>));</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行三次结果如下：</p>
<ul>
<li>第一次：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i:623</span><br><span class="line">i:778</span><br><span class="line">i:699</span><br></pre></td></tr></table></figure></li>
<li>第二次：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i:193</span><br><span class="line">i:763</span><br><span class="line">i:499</span><br></pre></td></tr></table></figure></li>
<li>第三次：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i:584</span><br><span class="line">i:114</span><br><span class="line">i:449</span><br></pre></td></tr></table></figure>
可以看出每次运行产生的随机数都是不同的。</li>
</ul>
<hr>
<p>（当然这里产生的随机数，个人直觉告诉我并不是真正的随机，而是伪随机，以后再研究。）</p>
<h3 id="猜数字的游戏"><a href="#猜数字的游戏" class="headerlink" title="猜数字的游戏"></a>猜数字的游戏</h3><blockquote>
<p>电脑随机生成0-100的整数，我们通过键盘输入来猜。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	猜数字小游戏，系统产生一个1-100之间的随机数，请猜出这个数据是多少。</span></span><br><span class="line"><span class="comment"> * 	分析：</span></span><br><span class="line"><span class="comment"> * 		A：系统产生一个1~100之间的数据，</span></span><br><span class="line"><span class="comment"> * 		B:键盘录入我们要猜的数据</span></span><br><span class="line"><span class="comment"> * 		C:比较这两个数据，用if语句实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="comment">//生成一个随机数 【0，99】</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">RandomNumber</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>);</span><br><span class="line">		<span class="comment">//调整随机数的范围【1，100】</span></span><br><span class="line">		RandomNumber += <span class="number">1</span>; </span><br><span class="line">		<span class="comment">//初始化 GuessNumber</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">GuessNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(GuessNumber != RandomNumber) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入要猜的数字：&quot;</span>);</span><br><span class="line">			GuessNumber = sc.nextInt();</span><br><span class="line">			<span class="keyword">if</span>(GuessNumber&gt;RandomNumber) &#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;你猜大了，&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(GuessNumber&lt;RandomNumber)&#123;</span><br><span class="line">				System.out.print(<span class="string">&quot;你猜小了，&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;恭喜你，你猜中了！，要猜的数字是：&quot;</span>+RandomNumber);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请输入要猜的数字：</span><br><span class="line">50</span><br><span class="line">你猜小了，请输入要猜的数字：</span><br><span class="line">75</span><br><span class="line">你猜小了，请输入要猜的数字：</span><br><span class="line">87</span><br><span class="line">你猜大了，请输入要猜的数字：</span><br><span class="line">82</span><br><span class="line">你猜大了，请输入要猜的数字：</span><br><span class="line">79</span><br><span class="line">你猜大了，请输入要猜的数字：</span><br><span class="line">77</span><br><span class="line">恭喜你，你猜中了！，要猜的数字是：77</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>自制遥控玩具车</title>
    <url>/blog/348d.html</url>
    <content><![CDATA[<p>看图说话</p>
<img src="/blog/348d/005vwoCygy1fl40fa9kvrj30qw1007g0.jpg" class="">

<p>底盘使用了一块10cm x 15cm的覆铜板</p>
<p>另使用 两个马达减速箱作为后轮驱动。</p>
<img src="/blog/348d/005vwoCygy1fl40f8reklj30hs08jjsc.jpg" class="">

<p>加上自制的51最小系统板</p>
<img src="/blog/348d/005vwoCygy1fl40fa0nf4j30kq0rzn4i.jpg" class="">

<p>两节18620锂电池</p>
<p>和一块L298N电机驱动小板</p>
<img src="/blog/348d/005vwoCygy1fl40f9j94wj30hs07hq48.jpg" class="">

<p>一个无线键控的的小遥控</p>
<img src="/blog/348d/005vwoCygy1fl40f9jcf5j30hs07jta2.jpg" class="">


<p>前轮使用了室友友情赞助的乒乓球。</p>
<p>三轮车转向使用差速转向。</p>
<p>（左转：右轮转速&gt;&gt;左轮转速，右转：左轮转速&gt;&gt;右轮转速，后退就是两个轮同时倒转）</p>
<p>转速的控制使用脉冲宽度调制的方法，就是我们所说的PWM。现在很多单片机已经片内集成了PWM了，只需简单的程序调用即可使用。我用的单片机没有这个功能，不过通过软件实现也并非难事。</p>
<p>如果马力全开 速度还是挺快的，只不过L298N芯片就吃不消了，散热片比较烫手。</p>
<p>所以我通过程序把最高速度设定到全速的50%，这样就没有那么热了。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Java练习</title>
    <url>/blog/3999.html</url>
    <content><![CDATA[<h1 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h1><h2 id="打印心形，中心有-I-Love-Java-字样"><a href="#打印心形，中心有-I-Love-Java-字样" class="headerlink" title="打印心形，中心有 I Love Java 字样"></a>打印心形，中心有 I Love Java 字样</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析： 通过print语句直接打印即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ILoveJava</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 手工画图法画出浪漫心形，表达对Java的热爱</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;   *  * *      * * *     &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;  *         *       *    &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;  *   I Love Java   *    &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;   *               *     &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;    *             *      &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;     *           *       &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;      *         *        &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;        *     *          &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;          * *            &quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;           *             &quot;</span>);</span><br><span class="line">		<span class="comment">//嗯嗯，很赞！</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><h2 id="打印20-8的矩形"><a href="#打印20-8的矩形" class="headerlink" title="打印20*8的矩形"></a>打印20*8的矩形</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********</span><br><span class="line">********</span><br><span class="line">  ···</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析： 可以通过两个for循环自定义任意长宽的矩形，通过不换行打印矩形最基本的单位“*”，使用换行符分隔每一行</span></span><br><span class="line"><span class="comment">		定义四个变量，两个自增变量k和l，两个行和列的变量i,j。</span></span><br><span class="line"><span class="comment">		后续只需要修改i和j的初始值即可修改矩形的行列数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">juxing</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">8</span>; 				 <span class="comment">//定义列的数目</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;				 <span class="comment">//定义行的数目</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; 			 	 <span class="comment">//自增变量，勿动</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;				 <span class="comment">//自增变量，勿动</span></span><br><span class="line">		<span class="keyword">for</span>(; l &lt; j; l++)&#123; 					<span class="comment">//外部循环，决定了行数</span></span><br><span class="line">			<span class="keyword">for</span>(; k &lt; i; k++)&#123; 				<span class="comment">//外部循环，决定了列数</span></span><br><span class="line">				System.out.print(<span class="string">&quot;*&quot;</span>); 		<span class="comment">//矩形的最基本单位 “*”</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(<span class="string">&quot;\n&quot;</span>); 		<span class="comment">// 换行</span></span><br><span class="line">			k = <span class="number">0</span>;				<span class="comment">// 自增列变量，恢复初值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><h2 id="打印高度为5的等腰三角形"><a href="#打印高度为5的等腰三角形" class="headerlink" title="打印高度为5的等腰三角形"></a>打印高度为5的等腰三角形</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    *</span><br><span class="line">   ***</span><br><span class="line">  *****</span><br><span class="line"> *******</span><br><span class="line">*********</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	分析：</span></span><br><span class="line"><span class="comment">		五行的等腰三角形：</span></span><br><span class="line"><span class="comment">			第1行：4空格，1个*</span></span><br><span class="line"><span class="comment">			第2行：3空格，3个*		</span></span><br><span class="line"><span class="comment">			第3行：2空格，5个*</span></span><br><span class="line"><span class="comment">			第4行：1空格，7个*</span></span><br><span class="line"><span class="comment">			第5行：0空格，9个*</span></span><br><span class="line"><span class="comment">		不难看出规律，共计5行，作为一个大循环，空格递减作为一个小循环，*个数递增作为一个小循环。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">triangle</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> i , j , k;</span><br><span class="line">		<span class="comment">// i 为 最下面一行打印*的个数， j为各行打印*的个数， k为各行打印空格的个数。</span></span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">9</span> ; i+=<span class="number">2</span>)&#123;<span class="comment">//打印*的个数，大循环</span></span><br><span class="line">			<span class="keyword">for</span>(k = <span class="number">0</span>;k &lt; (<span class="number">9</span>-i)/<span class="number">2</span> ; k++ )&#123;</span><br><span class="line">				<span class="comment">//打印空格的个数，每行递减</span></span><br><span class="line">				System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; i ; j++)&#123;</span><br><span class="line">				<span class="comment">//打印*，递增2</span></span><br><span class="line">				System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//换行</span></span><br><span class="line">			System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><h2 id="声明两个double型变量var1和var2并赋值-然后再用var1保存两者之和-再用var2保存两者之差-分析过程"><a href="#声明两个double型变量var1和var2并赋值-然后再用var1保存两者之和-再用var2保存两者之差-分析过程" class="headerlink" title="声明两个double型变量var1和var2并赋值. 然后再用var1保存两者之和, 再用var2保存两者之差, 分析过程"></a>声明两个double型变量var1和var2并赋值. 然后再用var1保存两者之和, 再用var2保存两者之差, 分析过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	分析：本题目类似于 “不通过第三个变量，交换两个变量的值”问题，借鉴改题目的思路</span></span><br><span class="line"><span class="comment">		  首先出于生活常识，两个变量之和等于 （变量1 + 变量2），两者之差等于 （变量1 - 变量2） </span></span><br><span class="line"><span class="comment">		  其中把两者之和保存到变量1里，var1 = var1 + var2;</span></span><br><span class="line"><span class="comment">		  然后（两者之和 - 变量1 = 变量2，两者之差 = 变量1 - 变量2）</span></span><br><span class="line"><span class="comment">		  故两者之差 var2  =  var1 - var2 - var 2 ，即 var2 = var1 - var2 * 2;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">three</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">// 随机设置 两个double变量</span></span><br><span class="line">		<span class="type">double</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">357878.1544d</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="number">11454.64785d</span>;</span><br><span class="line">		<span class="comment">// 求出两者之和</span></span><br><span class="line">		var1 = var1 + var2;</span><br><span class="line">		<span class="comment">// 求出两者之差</span></span><br><span class="line">		var2 = var1 - var2 * <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 打印结果</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两者之和是：&quot;</span>+var1);</span><br><span class="line">		System.out.println(<span class="string">&quot;两者之差是：&quot;</span>+var2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java变量取值范围探讨</title>
    <url>/blog/8f58.html</url>
    <content><![CDATA[<p>探讨Java中的变量取值范围，通过Java自带的函数直接求出其最大值和最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">floattest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> Byte.MAX_VALUE;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> Byte.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte的取值范围是：&quot;</span>+b2+<span class="string">&quot; ~ &quot;</span>+b1);</span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> Short.MAX_VALUE;</span><br><span class="line">        <span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> Short.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;short的取值范围是：&quot;</span>+s2+<span class="string">&quot; ~ &quot;</span>+s1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;int的取值范围是：&quot;</span>+i2+<span class="string">&quot; ~ &quot;</span>+i1);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;long的取值范围是：&quot;</span>+l2+<span class="string">&quot; ~ &quot;</span>+l1);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> Float.MAX_VALUE;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> Float.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;float的取值范围是：&quot;</span>+f2+<span class="string">&quot; ~ &quot;</span>+f1);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Double.MAX_VALUE;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> Double.MIN_VALUE;</span><br><span class="line">        System.out.println(<span class="string">&quot;double的取值范围是：&quot;</span>+d2+<span class="string">&quot; ~ &quot;</span>+d1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte的取值范围是：-128 ~ 127</span><br><span class="line">short的取值范围是：-32768 ~ 32767</span><br><span class="line">int的取值范围是：-2147483648 ~ 2147483647</span><br><span class="line">long的取值范围是：-9223372036854775808 ~ 9223372036854775807</span><br><span class="line">float的取值范围是：1.4E-45 ~ 3.4028235E38</span><br><span class="line">double的取值范围是：4.9E-324 ~ 1.7976931348623157E308</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>计时器制作</title>
    <url>/blog/bcb8.html</url>
    <content><![CDATA[<p>这次来做一个不用电路板的制作</p>
<h1 id="作品欣赏"><a href="#作品欣赏" class="headerlink" title="作品欣赏"></a>作品欣赏</h1><img src="/blog/bcb8/005vwoCygy1fl40lbkn5bj30ii0c8tiz.jpg" class="">


<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><ul>
<li>蜂鸣器</li>
<li>晶振</li>
<li>电池盒</li>
<li>4位共阳极数码管</li>
<li>主控STC12C5A60S2</li>
<li>5号电池x3</li>
</ul>
<p>如下图所示，就这么几个东西</p>
<img src="/blog/bcb8/005vwoCygy1fl40larcl6j30ox0ig7l6.jpg" class="">



<p>蜂鸣器直接接到P1.0和VCC上。晶振直接焊接到18、19引脚上。</p>
<img src="/blog/bcb8/005vwoCygy1fl40lc1f3kj30lm0gd7lf.jpg" class="">

<p>数码管和MCU”对接”</p>
<img src="/blog/bcb8/005vwoCygy1fl40ldxukjj30sc0kr1h2.jpg" class="">

<p>对准位置后焊接，引脚间距都是2.54mm  [100mil]</p>
<img src="/blog/bcb8/005vwoCygy1fl40lacsr8j30mz0ecnbc.jpg" class="">



<p>数码管需要共阳装，0.5英寸大小的。需要注意尺寸</p>
<img src="/blog/bcb8/005vwoCygy1fl40l7yomxj30pj0afq79.jpg" class="">

<p>下载程序时候需要勾选复位脚用作IO口</p>
<img src="/blog/bcb8/005vwoCygy1fl40l6kucmj30m70g7t9r.jpg" class="">



<p>最后附上原理图：</p>
<img src="/blog/bcb8/005vwoCygy1fl40la17gsj31120fi0ze.jpg" class="">

<hr>
<p>———————————–割——————————————-<br>干电池不环保，块头又大，后来就改了一个充电宝供电。<br>在某东以￥9.9/个的价格秒了几个2200mAh的充电宝，直接拆了从电池引出两根线，实测电压4.12V。充电部分没有动，可以直接用microUSB数据线对其充电。<br>单片机数据手册上标工作电压为3.3-5.5V，所以直接通过一个船型开关就接上单片机。用热熔胶把充电宝和单片机固定到一起。效果图如下：</p>
<img src="/blog/bcb8/005vwoCygy1fl40lb0lavj30t40lkqd1.jpg" class="">


<p>这个定时器被我用来煮粥使用，现有一电饭煲，加米加水后定时1小时，到时间蜂鸣器会鸣响，提醒关火，防止溢出。</p>
<p>自从有了它，粥再也没有溢的满地都是了。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>递归求和</title>
    <url>/blog/7120.html</url>
    <content><![CDATA[<p>我所理解的递归：</p>
<p>【上楼梯问题】<br>爬楼梯问题，即一个N阶的楼梯，每次能走1～2阶，问走到N阶一共多少种走法。<br>第n阶的走法等于 <strong>(n-1)阶</strong> 和 <strong>(n-2)阶</strong> 的和。<br>(先走到第(n-2)阶然后走两阶，或者先走上第(n-1)阶然后走一阶)。</p>
<p>其中 <strong>(n-1)阶楼梯的走法</strong>等于 <strong>(n-2)阶</strong> 和 <strong>(n-3)阶</strong> 走法的和。</p>
<p><strong>(n-2)阶楼梯的走法</strong> 等于 <strong>(n-3)阶</strong> 和 <strong>(n-4)阶</strong> 走法的和。<br>·<br>·<br>·<br>·<br>2阶楼梯有两种走法，走一阶梯再走一阶梯，直接走两阶梯。</p>
<h2 id="求和问题"><a href="#求和问题" class="headerlink" title="求和问题"></a>求和问题</h2><h3 id="普通正常1-100求和方式"><a href="#普通正常1-100求和方式" class="headerlink" title="普通正常1~100求和方式"></a>普通正常1~100求和方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sum3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span> ; i ++ )&#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用递归方式求整数1-100的和。"><a href="#使用递归方式求整数1-100的和。" class="headerlink" title="使用递归方式求整数1~100的和。"></a>使用递归方式求整数1~100的和。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sum</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">demo1</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>(demo1(i-<span class="number">1</span>)+i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> demo1(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;1-100的和:&quot;</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="普通方式求1-100之内奇数的和"><a href="#普通方式求1-100之内奇数的和" class="headerlink" title="普通方式求1~100之内奇数的和"></a>普通方式求1~100之内奇数的和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sum3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100</span> ; i += <span class="number">2</span> )&#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归方式求1-100之内的奇数的和"><a href="#递归方式求1-100之内的奇数的和" class="headerlink" title="递归方式求1-100之内的奇数的和"></a>递归方式求1-100之内的奇数的和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sum2</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="title function_">demo2</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">			i -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span>(demo2(i-<span class="number">2</span>)+i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> demo2(<span class="number">100</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;100以内的奇数的和:&quot;</span>+i);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>基于51单片机的万年历『1』</title>
    <url>/blog/9491.html</url>
    <content><![CDATA[<p>大二暑假时期，制作了一个51单片机主控的万年历。</p>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><ul>
<li>使用了LCD1602作为显示屏</li>
<li>DS18B20温度传感器</li>
<li>DS1302时钟芯片</li>
<li>主控芯片是STC89c52RC(贴片)</li>
<li>外围器件：点动开关、蜂鸣器、电位器等等</li>
</ul>
<p>这个是第一版成品图，用了mini版的1602显示器.</p>
<img src="/blog/9491/005vwoCygy1fl40hd1iilj30c10cudiw.jpg" class="">

<p>侧面图，底板仅仅作为加固和保护内部电路作用，无电气属性。中间用铜柱连接</p>
<img src="/blog/9491/005vwoCygy1fl40hch1k7j30dc0hugpd.jpg" class="">

<p>屏幕和电路板对比，纽扣电池给DS1302供电</p>
<img src="/blog/9491/005vwoCygy1fl40hchvx6j30d90hsjuc.jpg" class="">

<p>这个是第二版，使用了普通版的LCD1602，PCB也进行了重新优化</p>
<img src="/blog/9491/005vwoCygy1fl40hdbqbjj30hs0dagp9.jpg" class="">

<p>反面如图所示，有署名和时间，同样这版DS1302也采用贴片规格。由一对铜柱使其倾斜便于观看</p>
<img src="/blog/9491/005vwoCygy1fl40heq3moj30i00dg7m2.jpg" class="">

<p>第二版做了两个，由于铜柱的作用，角度倾斜所以显的大小不同。除了屏幕颜色，两个完全一样。</p>
<img src="/blog/9491/005vwoCygy1fl40hdlqyzj30hs0dajv3.jpg" class="">

<p>全家福</p>
<img src="/blog/9491/005vwoCygy1fl40hd7ja1j30hs0a90vc.jpg" class="">

<p>原理图</p>
<img src="/blog/9491/005vwoCygy1fl40hc7kq0j30hs09mq4m.jpg" class="">

<p>第一版PCB</p>
<img src="/blog/9491/005vwoCygy1fl40hce5m1j30gy0fdta6.jpg" class="">

<p>第二版PCB</p>
<img src="/blog/9491/005vwoCygy1fl40hce27yj30hs05wwgq.jpg" class="">

<blockquote>
<p>第一版的万年历送给了一个对我有帮助的老师<br>第二版的两个：</p>
</blockquote>
<ul>
<li>一个送给了朋友作为生日礼物</li>
<li>另一个放在家里  给爷爷看时间</li>
</ul>
<p><a href="https://mapan.tech/cn/d091.html">大屏升级版万年历</a></p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>指针万用表的使用技巧</title>
    <url>/blog/9a17.html</url>
    <content><![CDATA[<p>1、指针表内的电池：</p>
<img src="/blog/9a17/005vwoCygy1fl40p768osj30sg0hz77f.jpg" class="" title="使用万用表的技巧">

<p>一般有两块电池，一块低电压的1.5V，一块是高电压的9V或15V，其黑表笔相对红表笔来说是正端。数字表则常用一块6V或9V的电池。在电阻档，指针 表的表笔输出电流相对数字表来说要大很多，用R×1Ω档可以使扬声器发出响亮的“哒”声，用R×10kΩ档甚至可以点亮发光二极管（LED）。</p>
<p>2、指针表读取精度较差，但指针摆动的过程比较直观，其摆动速度幅度有时也能比较客观地反映了被测量的大小（比如测电视机数据总线（SDL）在传送数据时的轻微抖动）；数字表读数直观，但数字变化的过程看起来很杂乱，不太容易观看。</p>
<p>3、测量精度较差：</p>
<p>在电压档，指针表内阻相对数字表来说比较小，测量精度相比较差。某些高电压微电流的场合甚至无法测准，因为其内阻会对被测电路造成影响（比如在测电视机显 像管的加速级电压时测量值会比实际值低很多）。数字表电压档的内阻很大，至少在兆欧级，对被测电路影响很小。但极高的输出阻抗使其易受感应电压的影响，在 一些电磁干扰比较强的场合测出的数据可能是虚的。 　　总之，在相对来说大电流高电压的模拟电路测量中适用指针表，比如电视机、音响功放。在低电压小电流的数字电路测量中适用数字表，比如BP机、手机等。 不是绝对的，可根据情况选用指针表和数字表。</p>
<p>二、测量技巧（如不作说明，则指用的是指针表）：</p>
<p>1、测电容：</p>
<p>用电阻档，根据电容容量选择适当的量程，并注意测量时对于电解电容黑表笔要接电容正极。</p>
<p>①、 估测微波法级电容容量的大小：可凭经验或参照相同容量的标准电容，根据指针摆动的最大幅度来判定。所参照的电容不必耐压值也一样，只要容量相同即可，例如 估测一个100μF/250V的电容可用一个100μF/25V的电容来参照，只要它们指针摆动最大幅度一样，即可断定容量一样。</p>
<p>②、估测皮法级电容容量大小：要用R×10kΩ档，但只能测到1000pF以上的电容。对1000pF或稍大一点的电容，只要表针稍有摆动，即可认为容量够了。</p>
<p>③、 测电容是否漏电：对一千微法以上的电容，可先用R×10Ω档将其快速充电，并初步估测电容容量，然后改到R×1kΩ档继续测一会儿，这时指针不应回返，而 应停在或十分接近∞处，否则就是有漏电现象。对一些几十微法以下的定时或振荡电容（比如彩电开关电源的振荡电容），对其漏电特性要求非常高，只要稍有漏电 就不能用，这时可在R×1kΩ档充完电后再改用R×10kΩ档继续测量，同样表针应停在∞处而不应回返。</p>
<p>2、测喇叭、耳机、动圈式话筒：</p>
<p>用R×1Ω档，任一表笔接一端，另一表笔点触另一端，正常时会发出清脆响量的“哒”声。如果不响，则是线圈断了，如果响声小而尖，则是有擦圈问题，也不能用。</p>
<p>3、在路测二极管、三极管、稳压管好坏：</p>
<p>因为在实际电路中，三极管的偏置电阻或二极管、稳压管的周边电阻一般都比较大，大都在几百几千欧姆以上，这样，我们就可以用万用表的R×10Ω或R×1Ω 档来在路测量PN结的好坏。在路测量时，用R×10Ω档测PN结应有较明显的正反向特性（如果正反向电阻相差不太明显，可改用R×1Ω档来测），一般正向 电阻在R×10Ω档测时表针应指示在200Ω左右，在R×1Ω档测时表针应指示在30Ω左右（根据不同表型可能略有出入）。如果测量结果正向阻值太大或反 向阻值太小，都说明这个PN结有问题，这个管子也就有问题了。这种方法对于维修时特别有效，可以非常快速地找出坏管，甚至可以测出尚未完全坏掉但特性变坏 的管子。比如当你用小阻值档测量某个PN结正向电阻过大，如果你把它焊下来用常用的R×1kΩ档再测，可能还是正常的，其实这个管子的特性已经变坏了，不 能正常工作或不稳定了。</p>
<p>4、测电阻：</p>
<p>重要的是要选好量程，当指针指示于1/3～2/3满量程时测量精度最高，读数最准确。要注意的是，在用R×10k电阻档测兆欧级的大阻值电阻时，不可将手指捏在电阻两端，这样人体电阻会使测量结果偏小。</p>
<p>5 、测三极管：</p>
<p>通常我们要用R×1kΩ档，不管是NPN管还是PNP管，不管是小功率、中功率、大功率管，测其be结cb结都应呈现与二极管完全相同的单向导电性，反向 电阻无穷大，其正向电阻大约在10K左右。为进一步估测管子特性的好坏，必要时还应变换电阻档位进行多次测量，方法是：置R×10Ω档测PN结正向导通电 阻都在大约200Ω左右；置R×1Ω档测PN结正向导通电阻都在大约30Ω左右，（以上为47型表测得数据，其它型号表大概略有不同，可多试测几个好管总 结一下，做到心中有数）如果读数偏大太多，可以断定管子的特性不好。还可将表置于 R×10kΩ再测，耐压再低的管子（基本上三极管的耐压都在30V以上），其cb结反向电阻也应在∞，但其be结的反向电阻可能会有些，表针会稍有偏转 （一般不会超过满量程的1/3，根据管子的耐压不同而不同）。同样，在用R×10kΩ档测ec间(对NPN管）或ce间（对PNP管）的电阻时，表针可能 略有偏转，但这不表示管子是坏的。但在用R×1kΩ以下档测ce或ec间电阻时，表头指示应为无穷大，否则管子就是有问题。应该说明一点的是，以上测量是 针对硅管而言的，对锗管不适用。不过现在锗管也很少见了。另外，所说的“反向”是针对PN结而言，对NPN管和PNP管方向实际上是不同的。</p>
<p>现在常见的三极管大部分是塑封的，如何准确判断三极管的三只引脚哪个是b、c、e？三极管的b极很容易测出来，但怎么断定哪个是c哪个是e？这里推荐三种 方法：第一种方法：对于有测三极管hFE插孔的指针表，先测出b极后，将三极管随意插到插孔中去（当然b极是可以插准确的），测一下hFE值，然后再将管 子倒过来再测一遍，测得hFE值比较大的一次，各管脚插入的位置是正确的。第二种方法：对无hFE测量插孔的表，或管子太大不方便插入插孔的，可以用这种 方法：对NPN管，先测出b极（管子是NPN还是PNP以及其b脚都很容易测出，是吧？），将表置于R×1kΩ档，将红表笔接假设的e极（注意拿红表笔的 手不要碰到表笔尖或管脚），黑表笔接假设的c极，同时用手指捏住表笔尖及这个管脚，将管子拿起来，用你的舌尖舔一下b极，看表头指针应有一定的偏转，如果 你各表笔接得正确，指针偏转会大些，如果接得不对，指针偏转会小些，差别是很明显的。由此就可判定管子的c、e极。对PNP管，要将黑表笔接假设的e极 （手不要碰到笔尖或管脚），红表笔接假设的c极，同时用手指捏住表笔尖及这个管脚，然后用舌尖舔一下b极，如果各表笔接得正确，表头指针会偏转得比较大。 当然测量时表笔要交换一下测两次，比较读数后才能最后判定。这个方法适用于所有外形的三极管，方便实用。根据表针的偏转幅度，还可以估计出管子的放大能 力，当然这是凭经验的。第三种方法：先判定管子的NPN或PNP类型及其b极后，将表置于R×10kΩ档，对NPN管，黑表笔接e极，红表笔接c极时，表 针可能会有一定偏转，对PNP管，黑表笔接c极，红表笔接e极时，表针可能会有一定的偏转，反过来都不会有偏转。由此也可以判定三极管的c、e极。不过对 于高耐压的管子，这个方法就不适用了。</p>
<p>对于常见的进口型号的大功率塑封管，其c极基本都是在中间（我还没见过b在中间的）。中、小功率管有的b极可能在中间。比如常用的9014三极管及其系列 的其它型号三极管、2SC1815、2N5401、2N5551等三极管，其b极有的在就中间。当然它们也有 c极在中间的。所以在维修更换三极管时，尤其是这些小功率三极管，不可拿来就按原样直接安上，一定要先测一下。</p>
<p>6 、测稳压二极管：</p>
<p>我们通常所用到的稳压管的稳压值一般都大于1.5V，而指针表的R×1k以下的电阻档是用表内的1.5V电池供电的，这样，用R×1k以下的电阻档测量稳 压管就如同测二极管一样，具有完全的单向导电性。但指针表的R×10k档是用9V或15V电池供电的，在用R×10k测稳压值小于9V或15V的稳压管 时，反向阻值就不会是∞，而是有一定阻值，但这个阻值还是要大大高于稳压管的正向阻值的。如此，我们就可以初步估测出稳压管的好坏。但是，好的稳压管还要 有个准确的稳压值，业余条件下怎么估测出这个稳压值呢？不难，再去找一块指针表来就可以了。方法是：先将一块表置于R×10k档，其黑、红表笔分别接在稳 压管的阴极和阳极，这时就模拟出稳压管的实际工作状态，再取另一块表置于电压档V×10V或V×50V（根据稳压值）上，将红、黑表笔分别搭接到刚才那块 表的的黑、红表笔上，这时测出的电压值就基本上是这个稳压管的稳压值。说“基本上”，是因为第一块表对稳压管的偏置电流相对正常使用时的偏置电流稍小些， 所以测出的稳压值会稍偏大一点，但基本相差不大。这个方法只可估测稳压值小于指针表高压电池电压的稳压管。如果稳压管的稳压值太高，就只能用外加电源的方 法来测量了（这样看来，我们在选用指针表时，选用高压电池电压为15V的要比9V的更适用些）。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>CUBE 8 光立方制作</title>
    <url>/blog/4dd6.html</url>
    <content><![CDATA[<p>千呼万唤始出来,计划了良久而又一拖再拖的光立方终于在今天完工了。前前后后花了大概一周的时间。</p>
<img src="/blog/4dd6/005vwoCygy1fl40qaexqxj30hs0dcadw.jpg" class="">

<p>下面是驱动板。纯手工制作，单面板。看起来挺美的。</p>
<img src="/blog/4dd6/005vwoCygy1fl40qa6qp7j30hs0dcdjj.jpg" class="">

<p>刚腐蚀出来的板子，还没有打孔。是不是很精致呢</p>
<img src="/blog/4dd6/005vwoCygy1fl40q9ozrlj30dc0hstc1.jpg" class="">

<p>灯的折法:</p>
<img src="/blog/4dd6/005vwoCygy1fl40qadcrdj30dc0hsq5a.jpg" class="">

<p>一共8层这样的。每层64个，合计512个LED</p>


<p>还有惨不忍睹的飞线（表示做过第一个绝不会再想做第二个）</p>
<img src="/blog/4dd6/005vwoCygy1fl40qam33rj30dc0hrae1.jpg" class="">

<p>还有，驱动层之间的飞线</p>
<img src="/blog/4dd6/005vwoCygy1fl40qb016mj30hs0dc0w1.jpg" class="">

<p>看完虐心的飞线，来欣赏两张效果图平复一下心情。相信一切的付出都是值得的。</p>
<img src="/blog/4dd6/005vwoCygy1fl40qavh46j30dc0hsgmc.jpg" class="">

<p>是不是很唯美？</p>
<img src="/blog/4dd6/005vwoCygy1fl40q9ahobj30dc0hsaan.jpg" class="">

<p>看图不过瘾？</p>
<p>我们欣赏视频</p>
<video width="100%" height="100%"  src="https://mpn.gitee.io/video/4dd6.mp4" controls="controls">
CUBE8光立方
</video>]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Java多线程的两种实现方式</title>
    <url>/blog/2e2b.html</url>
    <content><![CDATA[<p>Java创建多线程有两种方式：</p>
<ul>
<li>1、继承Thread类的方式</li>
<li>2、实现Runnable接口的方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	使用实现Runnable接口的方式,实现三个窗口卖票程序</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 不需要加Static就可以实现三个窗口买共同的100张票</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为：&quot;</span> + ticket);</span><br><span class="line">				ticket--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Window1</span> <span class="variable">w1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window1</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w1);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w1);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w1);</span><br><span class="line"></span><br><span class="line">		t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">		t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过Thread类的对象调用start():①启动线程 ②调用当前线程的run();</span></span><br><span class="line"></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>汇编初识</title>
    <url>/blog/c6d9.html</url>
    <content><![CDATA[<p>大学时候学习的单片机原理和微机原理有用到汇编语言，但是当时觉得太过晦涩难懂，就没有学太懂。最近开始学习汇编语言，决定把汇编好好学习一下，网友介绍了王爽老师的<a href="https://pan.baidu.com/s/1leYR_IiEVU8l1jpQApxTcg">《汇编语言》</a>第三版 (提取码nc3c)，但为了学习还是买了一本实体书，这样更便于学习和翻阅。</p>
<p>汇编环境要求比较古老，所以在虚拟机装了一个XP。<br>首先是带x的寄存器（常用16位寄存器）<br>AX，BX，CX，DX</p>
<p>另有CS:IP<br>CS是段寄存器，段寄存器是羞涩的姑娘，不可以直接赋值，只能间接赋值。<br>CS:IP是当前执行的指令在内存中的地址。IP中存放为偏移地址。<br>计算方法：指向地址 =（CS）x10H +(IP)</p>
<p>DS是数据 段寄存器<br>SS为堆栈 段寄存器  SP为堆栈偏移地址，计算方法和CS:IP类似。</p>
<p>每个16位寄存器都是由两个八位寄存器组成，比如AX是有AH和AL组成，以此类推….</p>
<p>最简单且常用的指令有:</p>
<p>|指令|作用|举例|含义|<br>|:—:|:—:|:—:|:—:|:—:|<br>|MOV|赋值|MOV AX,BX|(AX)=(BX)|<br>|ADD|加法|ADD AX,CX|(AX)=(AX)+(CX)|<br>|SUB|减法|SUB AH,BH|(AH)=(AH)-(BH)|</p>
<p>按照国际惯例第一个程序应该是’hello world’才对，但是对于masm5.0来说‘hello world’已经相当复杂了。</p>
<h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 计算（0123h + 0456h) x 2的值</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:wahaha     <span class="comment">;wahaha程序入口地址</span></span><br><span class="line"></span><br><span class="line">wahaha <span class="meta">segment</span>   <span class="comment">;代码段开始</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0123h</span>  <span class="comment">; 0123h赋值给AX</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0456h</span>  <span class="comment">; 0456赋值给BX</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">bx</span>   <span class="comment">; BX的值加到AX中去</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span>   <span class="comment">; AX的两倍放到AX中去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span>  <span class="comment">;程序结束返回</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">wahaha ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>依次执行<code>masm 1.asm</code>和<code>link 1.obj</code>如下图</p>
<img src="/blog/c6d9/005vwoCyly1ft1cshmohbj30fi07fdgh.jpg" class="">

<p>进如debug进行调试<br>使用u命令查看汇编指令，使用r命令查看当前当前CPU寄存器的状态，使用t命令执行一条指令，如下图</p>
<img src="/blog/c6d9/005vwoCyly1ft1cw1kq9yj30hv0eggo1.jpg" class="">

<p>遇到<code>int 21</code>使用p命令进行结束<br>最后使用q命令退出debug模式</p>
<img src="/blog/c6d9/005vwoCyly1ft1czkzhn8j30hw03a74e.jpg" class="">

<h3 id="第二个程序："><a href="#第二个程序：" class="headerlink" title="第二个程序："></a>第二个程序：</h3><p>计算2x2的值，并保存在ax中</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2</span>   <span class="comment">;把2放到AX中</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span>  <span class="comment">;AX自加一次，也可以用 inc ax</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span> <span class="comment">; 程序结束，返回</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>deug查看寄存器中的值，</p>
<img src="/blog/c6d9/005vwoCyly1ft1dszeespj30hu0eedib.jpg" class="">
<p>我们有发现ds：0B26,但是程序存放在0B36起始的地址中，那么这265个（0B36H x 10H - B26H x 10H = 100H）个字节的空间跑哪里去了呢？<br>其实这256字节的空间叫做PSP，是debug程序需要占用的一段内存。</p>
<h3 id="第三个程序：计算5x4的值"><a href="#第三个程序：计算5x4的值" class="headerlink" title="第三个程序：计算5x4的值"></a>第三个程序：计算5x4的值</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:wusi</span><br><span class="line">wusi <span class="meta">segment</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">5h</span>   <span class="comment">;赋初值</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0h</span>   <span class="comment">;累加到BX，bx置0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>    <span class="comment">;第一次累加</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="built_in">ax</span>    <span class="comment">;第四次累加</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00H</span>   <span class="comment">;程序返回</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">wusi ends             <span class="comment">;这一段程序结束</span></span><br><span class="line">end                   <span class="comment">;所有程序结束</span></span><br></pre></td></tr></table></figure>
<img src="/blog/c6d9/005vwoCyly1ft1emj4k8hj30hs0gl0vn.jpg" class="">
<p>计算机是非常笨的，他不会做乘法，乘法是通过一次次累加得出的。<br>计算5x4需要5 累加4次，如果5x100呢？<br>换个思路100x5,可以用100累加5次，那如果88568x58755呢？难道累加五万多次？<br>很好，和C语言一样，汇编也有自己的循环程序，只需要写一段代码，让他循环五万多次就可以了</p>
<h3 id="第四个程序：-计算285x168"><a href="#第四个程序：-计算285x168" class="headerlink" title="第四个程序： 计算285x168"></a>第四个程序： 计算285x168</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:laila</span><br><span class="line">laila <span class="meta">segment</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>       <span class="comment">;累加器置零</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">168</span>     <span class="comment">;循环次数168</span></span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">s:</span>	<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">286</span>    <span class="comment">;循环体</span></span><br><span class="line">	<span class="keyword">loop</span> s        <span class="comment">;若cx不等于0 跳转执行s</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span>   <span class="comment">;程序结束，返回</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	</span><br><span class="line">laila ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<img src="/blog/c6d9/005vwoCyly1ft1f3br5wdj30ht0guacq.jpg" class="">
<p>使用lopp循环168次，循环次数默认存放在CX中</p>
<img src="/blog/c6d9/005vwoCyly1ft1fo0l6rsj30hu07tt9t.jpg" class="">
<p>结果是BX中存放的BBB0H<br>十进制就是48048,可以用计算器验证一下,算的没错。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>立体旋转显示LED屏</title>
    <url>/blog/8258.html</url>
    <content><![CDATA[<p>这是一个旋转的屏幕。黄色的电路板上有32个贴片LED灯。</p>
<p>侧面有16个贴片LED灯。</p>
<p>当电路板转起来的时候，通过MCU控制不同灯的亮灭来显示不同的字体或图案。</p>
<p>利用了我们人眼的视觉暂留效应，才能让我们看起来是一个平面。<br>由于是早期制作的（14年），制作期间还没有本博客，所以制作时候并记录制作过程</p>
<h3 id="成品图"><a href="#成品图" class="headerlink" title="成品图"></a>成品图</h3><img src="/blog/8258/005vwoCygy1fl40spin61j310a0r8jyk.jpg" class="">

<img src="/blog/8258/005vwoCygy1fl40sq15dbj310a0r8gub.jpg" class="">

<h3 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h3><img src="/blog/8258/005vwoCygy1fl40sq0dmcj310a0r8n7r.jpg" class="">

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><video width="100%" height="100%"  src="https://mpn.gitee.io/video/8258.mp4" controls="controls">
CUBE8光立方
</video>


<p>上面的字都可以修改的，大约可以显示120个字左右。</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>Java单例模式</title>
    <url>/blog/5cd6.html</url>
    <content><![CDATA[<p>所谓单例模式，就是采取一定的方法保证在整个软件系统中，对某个类智能存在一个对象实例。</p>
<p>实现单例模式的思路是：<br>一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名 称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们 还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。 </p>
<p>实现单利模式的原则和过程： </p>
<ul>
<li>1.单例模式：确保一个类只有一个实例，自行实例化并向系统提供这个实例 </li>
<li>2.单例模式分类：饿单例模式（类加载时实例化一个对象给自己的引用），懒单例模式（调用取得实例的方法如getInstance时才会实例化对象）（java中饿单例模式性能优于懒单例模式，c++中一般使用懒单例模式） </li>
<li>3.单例模式要素： <blockquote>
<p>a.私有构造方法<br>b.私有静态引用指向自己实例<br>c.以自己实例为返回值的公有静态方法 </p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	单例模式: 饿汉式</span></span><br><span class="line"><span class="comment"> * 	食用方法：</span></span><br><span class="line"><span class="comment"> * 	1、 私有化类的内部构造器</span></span><br><span class="line"><span class="comment"> * 	2、创建私有的类的唯一的对象。</span></span><br><span class="line"><span class="comment"> * 	3、提供公共的类的调用方法，返回类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line">	<span class="comment">// 1、私有化类的内部构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	<span class="comment">// 2、提供类内部私有静态方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">	<span class="comment">// 3、提供公共的静态方法，返回类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式二，使用静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用静态代码块，饿汉式单例模式</span></span><br><span class="line"><span class="comment"> * @author mapan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明当前类对象，没有初始化</span></span><br><span class="line">    <span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式：使用静态化代码块</span></span><br><span class="line"><span class="comment"> * 线程是不安全的，使用时需要注意</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order2</span> &#123;</span><br><span class="line">    <span class="comment">//1、私有化类的构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Order2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">    <span class="comment">//4.此对象也必须声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.声明public、static 的返回当前类对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加了synchronized同步锁来解决线程安全的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程安全的单例模式：懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式应用场景</p>
<blockquote>
<ol>
<li>Windows的Task Manager就是很典型的单例模式；</li>
<li>windows的Recycle Bin也是典型的单例应用；</li>
<li>网站的计数器如访客数，不蒜子计数器等。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java集合练习</title>
    <url>/blog/bc5d.html</url>
    <content><![CDATA[<h1 id="斗地主发牌问题"><a href="#斗地主发牌问题" class="headerlink" title="斗地主发牌问题"></a>斗地主发牌问题</h1><h3 id="1-1使用Java集合的知识，模拟斗地主发牌"><a href="#1-1使用Java集合的知识，模拟斗地主发牌" class="headerlink" title="1.1使用Java集合的知识，模拟斗地主发牌"></a>1.1使用Java集合的知识，模拟斗地主发牌</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PokerTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义了一个数组，存放扑克牌里面的13张牌大小。</span></span><br><span class="line">		String[] num = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;K&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义了一个一维数组，存放扑克牌里面的花色。</span></span><br><span class="line">		String[] color = &#123; <span class="string">&quot;方片&quot;</span>, <span class="string">&quot;梅花&quot;</span>, <span class="string">&quot;红桃&quot;</span>, <span class="string">&quot;黑桃&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;String&gt; poker = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (String s1 : color) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String s2 : num) &#123;</span><br><span class="line">				poker.add(s1.concat(<span class="string">&quot; &quot;</span> + s2));<span class="comment">//遍历所有牌的花色和大小，除了大小王</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 添加大小王</span></span><br><span class="line">		poker.add(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line">		poker.add(<span class="string">&quot;大王&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 洗牌</span></span><br><span class="line">		Collections.shuffle(poker);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 新建4个ArrayList,其中有三个人各17张牌，底牌有3张，共计54张</span></span><br><span class="line">		ArrayList&lt;String&gt; Tom = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		ArrayList&lt;String&gt; Jerry = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		ArrayList&lt;String&gt; me = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 底牌</span></span><br><span class="line">		ArrayList&lt;String&gt; lastCards = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//发牌，如果牌数剩余大于3张，</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poker.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= poker.size() - <span class="number">3</span>) &#123;</span><br><span class="line">				lastCards.add(poker.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				Tom.add(poker.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				Jerry.add(poker.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				me.add(poker.get(i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 看牌</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Tom：\n&quot;</span> + Tom);</span><br><span class="line">		System.out.println(<span class="string">&quot;Jerry：\n&quot;</span> + Jerry);</span><br><span class="line">		System.out.println(<span class="string">&quot;me：\n&quot;</span> + me);</span><br><span class="line">		System.out.println(<span class="string">&quot;底牌：\n&quot;</span> + lastCards);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tom：</span><br><span class="line">[梅花 K, 红桃 J, 黑桃 2, 方片 10, 梅花 4, 红桃 3, 黑桃 Q, 红桃 A, 黑桃 7, 方片 7, 黑桃 5, 梅花 8, 方片 J, 方片 8, 红桃 4, 红桃 7, 黑桃 3]</span><br><span class="line">Jerry：</span><br><span class="line">[方片 Q, 方片 9, 梅花 6, 梅花 J, 红桃 8, 梅花 3, 黑桃 J, 梅花 2, 黑桃 K, 梅花 A, 红桃 K, 红桃 2, 方片 4, 红桃 10, 黑桃 4, 方片 6, 红桃 5]</span><br><span class="line">me：</span><br><span class="line">[方片 K, 梅花 5, 黑桃 A, 梅花 9, 红桃 9, 梅花 Q, 黑桃 6, 梅花 10, 黑桃 10, 方片 3, 方片 2, 方片 A, 大王, 小王, 黑桃 8, 方片 5, 梅花 7]</span><br><span class="line">底牌：</span><br><span class="line">[黑桃 9, 红桃 Q, 红桃 6]</span><br></pre></td></tr></table></figure>

<h3 id="扩展，模拟斗地主发牌，并每个人的牌进行排序。"><a href="#扩展，模拟斗地主发牌，并每个人的牌进行排序。" class="headerlink" title="扩展，模拟斗地主发牌，并每个人的牌进行排序。"></a>扩展，模拟斗地主发牌，并每个人的牌进行排序。</h3><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PokerTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] num = &#123; <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;2&quot;</span> &#125;;</span><br><span class="line">		String[] color = &#123; <span class="string">&quot;方片&quot;</span>, <span class="string">&quot;梅花&quot;</span>, <span class="string">&quot;红桃&quot;</span>, <span class="string">&quot;黑桃&quot;</span> &#125;;</span><br><span class="line">		HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 存储索引和扑克牌</span></span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 索引的开始值</span></span><br><span class="line">		<span class="keyword">for</span> (String s1 : num) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String s2 : color) &#123;</span><br><span class="line">				map.put(index, s2.concat(<span class="string">&quot; &quot;</span> + s1)); <span class="comment">// 将索引和扑克牌添加到HashMap中</span></span><br><span class="line">				list.add(index); <span class="comment">// 将索引添加到ArrayList集合中</span></span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(index, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">		list.add(index);</span><br><span class="line">		index++;</span><br><span class="line">		map.put(index, <span class="string">&quot;大王&quot;</span>);</span><br><span class="line">		list.add(index);</span><br><span class="line">		<span class="comment">// 洗牌</span></span><br><span class="line">		Collections.shuffle(list);</span><br><span class="line">		<span class="comment">// 发牌</span></span><br><span class="line">		TreeSet&lt;Integer&gt; Tom = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		TreeSet&lt;Integer&gt; Jerry = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		TreeSet&lt;Integer&gt; me = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		TreeSet&lt;Integer&gt; lastCards = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= list.size() - <span class="number">3</span>) &#123;</span><br><span class="line">				lastCards.add(list.get(i)); <span class="comment">// 将list集合中的索引添加到TreeSet集合中会自动排序</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				Tom.add(list.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				Jerry.add(list.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				me.add(list.get(i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 看牌</span></span><br><span class="line">		lookPoker(<span class="string">&quot;Tom&quot;</span>, Tom, map);</span><br><span class="line">		lookPoker(<span class="string">&quot;Jerry&quot;</span>, Jerry, map);</span><br><span class="line">		lookPoker(<span class="string">&quot;康师傅&quot;</span>, me, map);</span><br><span class="line">		lookPoker(<span class="string">&quot;底牌&quot;</span>, lastCards, map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookPoker</span><span class="params">(String name, TreeSet&lt;Integer&gt; ts, HashMap&lt;Integer, String&gt; map)</span> &#123;</span><br><span class="line">		System.out.println(name + <span class="string">&quot;的牌是:&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (Integer index : ts) &#123;</span><br><span class="line">			System.out.print(map.get(index) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC相关</title>
    <url>/blog/a3b2.html</url>
    <content><![CDATA[<p>JDBC（Java Database Connectivity）是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p>
<p>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</p>
<p>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p>
<img src="/blog/a3b2/1558446641293.png" class="JDBC的调用原理">

<p>只要提供了接口的实现就可以连接，Java就可以连接各种类型的数据库.</p>
<p>下面程序用来连接数据库，进行查询操作，删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTest</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取链接</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">		<span class="comment">//3.连接数据库</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		System.out.println(connection);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/myemployees&quot;</span>;</span><br><span class="line">		<span class="comment">//2.获取链接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		<span class="comment">//3、创建Statement对象</span></span><br><span class="line">		<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">		<span class="comment">//4.写sql语句</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from myemp1 where id = 145&quot;</span>;</span><br><span class="line">		<span class="comment">//5.执行增删改</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> st.executeUpdate(sql);</span><br><span class="line">		System.out.println(count &gt; <span class="number">0</span> ? <span class="string">&quot;成功&quot;</span> : <span class="string">&quot;失败&quot;</span>);</span><br><span class="line">		<span class="comment">//6.关闭链接和Statement</span></span><br><span class="line">		connection.close();</span><br><span class="line">		st.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/myemployees&quot;</span>;</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		<span class="comment">//3.创建Steamment对象</span></span><br><span class="line">		<span class="type">Statement</span> <span class="variable">createStatement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">		<span class="comment">//4.写sql语句</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from myemp1&quot;</span>;</span><br><span class="line">		<span class="comment">//5.执行一次查询</span></span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">executeQuery</span> <span class="operator">=</span> createStatement.executeQuery(sql);</span><br><span class="line">		<span class="comment">//6.获取结果集</span></span><br><span class="line">		<span class="keyword">while</span>(executeQuery.next()) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> executeQuery.getInt(<span class="number">1</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> executeQuery.getString(<span class="number">2</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">salary</span> <span class="operator">=</span> executeQuery.getInt(<span class="number">3</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;员工编号:&quot;</span>+id + <span class="string">&quot;,员工姓名:&quot;</span> + name + <span class="string">&quot;,员工薪资:&quot;</span> + salary + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">			<span class="comment">//封装myemp1对象</span></span><br><span class="line">			<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,name,salary);</span><br><span class="line">			<span class="comment">//打印数每一个User对象</span></span><br><span class="line">			System.out.println(user)；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>SQL练习</title>
    <url>/blog/5048.html</url>
    <content><![CDATA[<p>学习到SQL相关的知识，记录下最常用的SQl语句。<br>插入表操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> book(</span><br><span class="line">isbn,NAME,stock</span><br><span class="line">),</span><br><span class="line"><span class="keyword">VALUE</span> (<span class="number">10011</span>,<span class="string">&#x27;诸葛亮&#x27;</span>,<span class="number">99</span>);</span><br></pre></td></tr></table></figure>
<p>创建表操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line"> NAME <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> balance <span class="keyword">DOUBLE</span>(<span class="number">11</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>删除表操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> emp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>基于51单片机的万年历『2』</title>
    <url>/blog/d091.html</url>
    <content><![CDATA[<p>相比<a href="9491.html">第一版</a>，升级了屏幕和功能。使用LCD12864屏幕。某宝有卖，下面的电路板是手工制作的，为了能与LCD匹配，大小我特意制作的和LCD屏幕一样大。安装好显得刚刚好</p>
<img src="/blog/d091/005vwoCygy1fl40txyo1rj30hs0axdi0.jpg" class="">

<p>从中间角度看</p>
<img src="/blog/d091/005vwoCygy1fl40tzg0k4j30c00sqdjj.jpg" class="">


<p>前面留有micro-USB供电接口和下载程序排针接口。普通安卓数据线就可以供电了。</p>
<img src="/blog/d091/005vwoCygy1fl40u0rc5yj30t30endlf.jpg" class="">

<p>首先用电脑画出印刷电路板的样图，花了一个下午的时间。</p>
<img src="/blog/d091/005vwoCygy1fl40tztp3qj30hs0dh426.jpg" class="">

<p>转印到覆铜板，准备腐蚀，用了一个饭盒，是透明的。</p>
<img src="/blog/d091/005vwoCygy1fl40ty080uj30qo0k0di8.jpg" class="">

<p>加入沸水，只需要三五分钟 即可腐蚀完成。</p>
<img src="/blog/d091/005vwoCygy1fl40ty9nhvj30hs0dcgod.jpg" class="">

<p>腐蚀完毕，捞出来擦干，打磨掉走线上的墨粉</p>
<img src="/blog/d091/005vwoCygy1fl40u1rojuj30hs0cr0us.jpg" class="">

<p>下面打孔，由于用了贴片元件，因此减少了很多过孔。</p>
<img src="/blog/d091/005vwoCygy1fl40tycybsj30hs0hzgnn.jpg" class="">

<p>手工焊接贴片元件是比较困难的。所以首先焊接贴片芯片，焊接前要在焊盘上镀一层焊锡，这样容易焊接</p>
<img src="/blog/d091/005vwoCygy1fl40tz15rkj30hs0dcdih.jpg" class="">

<p>焊接完成，使用万用表蜂鸣档测试，没有虚焊和连锡。</p>
<img src="/blog/d091/005vwoCygy1fl40u0cpf9j30hs0dc77f.jpg" class="">

<p>焊接基本完成，为了防止走线氧化，我把铜线上镀了一层锡。</p>
<img src="/blog/d091/005vwoCygy1fl40tyz0wsj30dc0hsq5s.jpg" class="">

<p>然后就是很长很长的代码要写，</p>
<hr>
<p>省略三千行代码先</p>
<p>在坛友提供的资料和程序中调试良久，程序终于适配了我的硬件</p>
<p>欣赏</p>
<img src="/blog/d091/005vwoCygy1fl40txli5dj30f409gq44.jpg" class="">

<p>这个兔斯基是我在百度上搜索的图片，然后用PS修出细致轮廓。再用软件转成代码，写到程序里面。</p>
<img src="/blog/d091/005vwoCygy1fl40ty9066j30c80hsgn1.jpg" class="">

<p>同样 ，这个也是。只是感觉挺可爱的，正好大小也合适，所以就选择了这个图</p>
<img src="/blog/d091/005vwoCygy1fl40txk2p6j30d00hsmyf.jpg" class="">




<p>下图为节日提醒功能。支持节日自定义（农历阳历均可）。<br>方法：在程序相应代码段添加相应代码即可<br>其中农历是完全靠算法实现的，没有使用专业芯片</p>
<img src="/blog/d091/005vwoCygy1fl40ty4hy3j30hs09pq4b.jpg" class="">

<p>开机启动界面</p>
<img src="/blog/d091/005vwoCygy1fl40tym453j30ak0hsq48.jpg" class="">

<p>大字体模式一</p>
<img src="/blog/d091/005vwoCygy1fl40tzduhfj30hs0cbjss.jpg" class="">

<p>大字体模式二</p>
<img src="/blog/d091/005vwoCygy1fl40tzsf36j30hs0ceac0.jpg" class="">

<p>正常模式</p>
<img src="/blog/d091/005vwoCygy1fl40tzsdsxj30hs0butak.jpg" class="">
<p>设置界面</p>
<img src="/blog/d091/005vwoCygy1fl40u0709fj30hs0bq0uf.jpg" class="">

<p>闹钟设置界面</p>
<img src="/blog/d091/005vwoCygy1fl40tzwta8j30hs0aqdgn.jpg" class="">
<h2 id="视频效果"><a href="#视频效果" class="headerlink" title="视频效果"></a>视频效果</h2><video  width="100%" height="100%" src="https://mpn.gitee.io/video/d091.mp4" controls="controls">
万年历第二版
</video>]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>汇编基本语法实现</title>
    <url>/blog/fac.html</url>
    <content><![CDATA[<h3 id="第五个程序"><a href="#第五个程序" class="headerlink" title="第五个程序"></a>第五个程序</h3><p>堆栈的学习</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">2000h</span>  	<span class="comment">;地址2000h赋值给ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span>  	<span class="comment">;ax的值传递给段寄存器ss</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0</span>  	<span class="comment">;堆栈指针sp赋初值0</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span>  	<span class="comment">;出栈到ax</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span>  	<span class="comment">;出栈到bx</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">ax</span>  	<span class="comment">;ax入栈</span></span><br><span class="line">	<span class="keyword">push</span> <span class="built_in">bx</span>  	<span class="comment">;bx入栈</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">ax</span>  	<span class="comment">;出栈到ax</span></span><br><span class="line">	<span class="keyword">pop</span> <span class="built_in">bx</span>  	<span class="comment">;出栈到bx</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>首先观察代码段的前256字节称为PSP的内容</p>


<p>通过debug观察各个寄存器的值，通过现象学习堆栈的<em>后进先出</em>的操作规则。</p>
<img src="/blog/fac/005vwoCyly1ftgg3f8onvj30i40grads.jpg" class="">
<p>可以看到进行<br>出栈出栈<br>入栈入栈<br>再出栈出栈<br>之后<br>ax和bx寄存器的值进行了交换。</p>
<p>类似生活中的一瓶糖水，一瓶盐水，现在需要交换两个瓶子的液体。使用“堆栈”这个容器进行了一个中转。</p>
<hr>
<h3 id="第六个程序"><a href="#第六个程序" class="headerlink" title="第六个程序"></a>第六个程序</h3><p>程序功能把内存单元的ffff:0    <del>ffff:b单元的内容复制到0:200</del>0：20b内存单元中。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0ffffh</span>  	<span class="comment">;通过ax中转给段寄存器ds赋初值FFFFH</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0020h</span>  	<span class="comment">;通过ax中转给段寄存器es赋初值20H</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>  	<span class="comment">;bx置零</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">12</span>  	<span class="comment">;循环12次</span></span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">s:</span>  	<span class="keyword">mov</span> <span class="built_in">dl</span>,[<span class="built_in">bx</span>]  	<span class="comment">;循环体s 开始循环12次</span></span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>],<span class="built_in">dl</span>  <span class="comment">;通过dl中转把ds:0-ds:b中的内容复制到es:0-es:b</span></span><br><span class="line">	<span class="keyword">inc</span> <span class="built_in">bx</span>  	<span class="comment">;b自增一</span></span><br><span class="line">	<span class="keyword">loop</span>  		<span class="comment">;循环</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">	<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>总结：此程序类似C语言中的循环,通过段寄存器DS和ES、BX自加、 以及循环，达到复制内存的目的。其中bx的作用就相当于C语言中的自加量i的作用。C代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	ds[i] = es[i];</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h2><p>在计算机运行程序时，程序和数据都是以二进制形式加载到内存中，实际上程序段和数据段对于计算机来说并没有任何不同。但是对于编程人员来说并不是一件好事，我们希望程序和数据以及堆栈分开存放。那么就需要对程序进行分块了。</p>
<h3 id="第七个程序"><a href="#第七个程序" class="headerlink" title="第七个程序"></a>第七个程序</h3><p>交换内存中数据段前两个双字单元的数据</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span>  	<span class="comment">;定义数据段</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0798h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fdeh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span>  	<span class="comment">;定义栈段</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span>  	<span class="comment">;定义代码段</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">start:</span> 		<span class="keyword">mov</span> <span class="built_in">ax</span>,data  	<span class="comment">;数据段地址给到ds</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,stack  	<span class="comment">;栈段地址给到ss</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span>  	<span class="comment">;栈段指针指向栈底</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]  	<span class="comment">;把数据段的ds:[0]单元的双字内容 压入栈</span></span><br><span class="line">		<span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">2</span>]  	<span class="comment">;把数据段的ds:[2]单元的双字内容 压入栈</span></span><br><span class="line">		<span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]  	<span class="comment">;出栈到ds:[0]单元</span></span><br><span class="line">		<span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]  	<span class="comment">;出栈到ds:[2]单元</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过<code>debug调试器</code>可以即将运行的代码看到<code>date段</code>的地址为<code>0b36h</code>,通过<code>d命令</code>查看内存<code>0b36</code>处的内容，正是在程序中定义的数据段<code>0123h，0456h,···，0987h</code><br>栈段地址为0b37h，在内存中<code>0b36:0010</code>单元处即为在程序中定义的全0的栈段。</p>
<img src="/blog/fac/005vwoCyly1ftgkj8qz6sj30ht0fwtd6.jpg" class="">
<p>经过两次入栈和出栈之后，可以看出date段的前两个双字节中的数据已经交换了位置。</p>
<img src="/blog/fac/005vwoCyly1ftgkacor6pj30hs0au0v7.jpg" class="">

<h3 id="第八个程序"><a href="#第八个程序" class="headerlink" title="第八个程序"></a>第八个程序</h3><p>使用push指令将a段中的前八个字形数据逆序存储到b段中</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">a <span class="meta">segment</span>  			<span class="comment">;a段数据</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0ah</span>,<span class="number">0bh</span>,<span class="number">0ch</span>,<span class="number">0dh</span>,<span class="number">0eh</span>,<span class="number">0fh</span>,<span class="number">0ffh</span>  </span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b <span class="meta">segment</span></span><br><span class="line">	<span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  	<span class="comment">;b段数据</span></span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span>  			<span class="comment">;代码段</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">start:</span> 	<span class="keyword">mov</span> <span class="built_in">ax</span>,b  		<span class="comment">;把栈段指针指向b数据段</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,a  	<span class="comment">;数据指针指向a段数据</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span>  	<span class="comment">;设置8次循环</span></span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>  	<span class="comment">;变量bx初值为0</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	s:</span>  <span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="built_in">bx</span>]  	<span class="comment">;开始8次压栈</span></span><br><span class="line">		<span class="keyword">add</span> <span class="built_in">bx</span>,<span class="number">2</span>  	<span class="comment">;bx自加2</span></span><br><span class="line">		<span class="keyword">loop</span> s</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>如图执行数次循环后，a段数据已经逆序存储在b段中</p>
<img src="/blog/fac/005vwoCyly1ftgmdm9gqqj30hm0e6gm9.jpg" class="">]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/blog/63be.html</url>
    <content><![CDATA[<p>数据库事务：<br>JDBC程序中当一个连接对象被创建时，默认情况下是自动提交事务，每次执行一个sql语句时，如果执行成功就会向数据库自动提交，而不能回滚。<br>JDBC程序中为了让多个sql语句作为一个事务执行。</p>
<p>个人理解的事务，做一件事情，有ABCDE…多个步骤，如果后面的步骤中有无法执行的，那么即使前面做过的ABCD几件事情也要撤销，给恢复成原来没有做过的样子，一件事情要么做就做完，要么就不做，万万不能做一半扔下个烂摊子。</p>
<p>普通买书的过程</p>
<img src="/blog/63be/1558533275461.png" class="Javaweb这本书，单价50元">

<p>这本JavaWeb书，单价50元，张飞同学有80元</p>
<img src="/blog/63be/1558533329251.png" class="张飞同学有80元余额">

<p>先买一本,书的库存减少，张飞的账户余额减少。</p>
<img src="/blog/63be/1558533372874.png" class="张飞买了一本书，余额剩余30">



<img src="/blog/63be/1558533571107.png" class="库存减少一本">



<p>张飞剩余30元，这时候他的月不够，但是他尝试买第二本书，这个时候就会出现问题：图书的库存较少了，但是张飞的余额却没有减少，还是30元。</p>
<img src="/blog/63be/1558533700852.png" class="库存又减少一本">



<img src="/blog/63be/1558533738508.png" class="但是张飞的余额却没有减少">



<p>以下是没有添加事务的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTesr</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	买书的操作</span></span><br><span class="line"><span class="comment"> * 	1.每次只能买一本</span></span><br><span class="line"><span class="comment"> * 	2.更新图书的库存</span></span><br><span class="line"><span class="comment"> * 	3.减少用户的账户的余额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///test&quot;</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url , <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		<span class="comment">//3.写sql语句</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update book set stock = stock - 1 where isbn = ?&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="comment">//4.预编译sql</span></span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//5.填充占位符</span></span><br><span class="line">		pst.setString(<span class="number">1</span>, <span class="string">&quot;10023&quot;</span>);</span><br><span class="line">		<span class="comment">//6.执行sql</span></span><br><span class="line">		pst.executeUpdate();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//预编译</span></span><br><span class="line">		pst = conn.prepareStatement(sql2);</span><br><span class="line">		<span class="comment">//填充占位符</span></span><br><span class="line">		pst.setDouble(<span class="number">1</span>, <span class="number">50.00</span>);</span><br><span class="line">		pst.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//执行sql</span></span><br><span class="line">		pst.executeUpdate();</span><br><span class="line">		conn.close();</span><br><span class="line">		pst.close();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>以下是添加事务的程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///test&quot;</span>;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url , <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		<span class="comment">//开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">//3.写sql语句</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update book set stock = stock - 1 where isbn = ?&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update account set balance = balance - ? where id = ?&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//4.预编译sql</span></span><br><span class="line">			pst = conn.prepareStatement(sql);</span><br><span class="line">			<span class="comment">//5.填充占位符</span></span><br><span class="line">			pst.setString(<span class="number">1</span>, <span class="string">&quot;10023&quot;</span>);</span><br><span class="line">			<span class="comment">//6.执行sql</span></span><br><span class="line">			pst.executeUpdate();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//预编译</span></span><br><span class="line">			pst = conn.prepareStatement(sql2);</span><br><span class="line">			<span class="comment">//填充占位符</span></span><br><span class="line">			pst.setDouble(<span class="number">1</span>, <span class="number">50.00</span>);</span><br><span class="line">			pst.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//执行sql</span></span><br><span class="line">			pst.executeUpdate();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//提交事务</span></span><br><span class="line">			conn.commit();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;		</span><br><span class="line">		conn.close();</span><br><span class="line">		pst.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加事务之后，张飞同学的余额不足时候，买书会失败，书的库存不会减少，张飞的月也不会变化。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>德鲁伊数据库连接池</title>
    <url>/blog/51f1.html</url>
    <content><![CDATA[<p>为了提高数据库连接的效率，阿里巴巴提供了Druid数据库连接池组件</p>
<p>Druid是一个JDBC组件，它包括三部分： </p>
<p> 1)DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 </p>
<p> 2)DruidDataSource 高效可管理的数据库连接池。 </p>
<p> 3)SQLParser</p>
<p>下面代码是Druid的使用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="comment">//创建连接池对象</span></span><br><span class="line">	<span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">	<span class="comment">//设置数据用户名</span></span><br><span class="line">	dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	<span class="comment">//设置数据库密码</span></span><br><span class="line">	dataSource.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">	<span class="comment">//设置数据库地址</span></span><br><span class="line">	dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	<span class="comment">//加载数据库驱动</span></span><br><span class="line">	dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	dataSource.setInitialSize(<span class="number">5</span>);</span><br><span class="line">	dataSource.setMaxActive(<span class="number">10</span>);</span><br><span class="line">	dataSource.setMaxWait(<span class="number">5000</span>); </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt; <span class="number">15</span> ; i++) &#123;</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">		System.out.println(connection);</span><br><span class="line">		connection.close();<span class="comment">//关闭连接</span></span><br><span class="line">	&#125;		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>为了再次规范化操作，提高程序的可维护性，可以添加properties配置文件<br>创建名字为config的SourceFolder,把db.properties文件放到配置文件夹里，如下图。</p>
<img src="/blog/51f1/1558584578535.png" class="项目目录结构">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidByFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建Properties对象</span></span><br><span class="line">	<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	<span class="comment">//加载配置文件</span></span><br><span class="line">	pro.load(PoolTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>));</span><br><span class="line">	<span class="comment">//获取数据源</span></span><br><span class="line">	<span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">	<span class="comment">//获取连接</span></span><br><span class="line">	<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">	System.out.println(connection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>事实表基本概念</title>
    <url>/blog/b78f.html</url>
    <content><![CDATA[<p>在多维数据仓库中，保存度量值的详细值或事实的表称为“事实表”。在事实表中，每个度量值都有一个列，不同事实表将有不同的度量值。</p>
<p>事实表中的度量主要分为三种：可加、半可加、不可加</p>
<ul>
<li>可加的度量<br>言外之意，既可以在任意维度下进行累加，例如订单中的订单金额，商品数量等；</li>
<li>半可加的度量<br>即为有的时候可以累加，有的时候不可以累加，学生成绩表中的各科目的成绩，针对每个人是可以进行累加，但是全班进行累加，是没有任何意义的；</li>
<li>不可加的度量<br>即为任何场景下均不可累加，典型的比如比例或者比率，其只针对单行记录有意义，直接累加无意义。</li>
</ul>
<p>一致性可以有两层的理解，一是表内部的一致性，二是表与表之间的一致性</p>
<ul>
<li>表内部的一致性：<br>在同一个表内部，所有记录的粒度、维度等信息均是一致的，每一列的单位，枚举值等均是一致</li>
<li>表与表之间的一致性：<br>如果我们在进行多个表的数据合并时，应该保证彼此之间的对于同一事实的计算，是在同一粒度和维度之下。统计口径一致，为了避免歧义，一个度量只有唯一的业务术语，例如一个度量是<strong>注销费用</strong>，或者<strong>退单费用</strong>。这两个业务术语可能描述的是同一个业务含义，但是只能取一个作为标准业务口径。</li>
</ul>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Flink运行架构</title>
    <url>/blog/6799.html</url>
    <content><![CDATA[<h2 id="Flink运行时的组件"><a href="#Flink运行时的组件" class="headerlink" title="Flink运行时的组件"></a>Flink运行时的组件</h2><p>Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager），以及分发器（Dispatcher）。因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机上。每个组件的职责如下：</p>
<h3 id="作业管理器（JobManager）"><a href="#作业管理器（JobManager）" class="headerlink" title="作业管理器（JobManager）"></a>作业管理器（JobManager）</h3><p>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行。JobManager会先接收到要执行的应用程序，这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包。JobManager会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。JobManager会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</p>
<h3 id="资源管理器（ResourceManager）"><a href="#资源管理器（ResourceManager）" class="headerlink" title="资源管理器（ResourceManager）"></a>资源管理器（ResourceManager）</h3><p>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger插槽是Flink中定义的处理资源单元。Flink为不同的环境和资源管理工具提供了不同资源管理器，比如YARN、Mesos、K8s，以及standalone部署。当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。另外，ResourceManager还负责终止空闲的TaskManager，释放计算资源。</p>
<h3 id="任务管理器（TaskManager）"><a href="#任务管理器（TaskManager）" class="headerlink" title="任务管理器（TaskManager）"></a>任务管理器（TaskManager）</h3><p>Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。</p>
<h3 id="分发器（Dispatcher）"><a href="#分发器（Dispatcher）" class="headerlink" title="分发器（Dispatcher）"></a>分发器（Dispatcher）</h3><p>可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</p>
<h2 id="任务提交流程"><a href="#任务提交流程" class="headerlink" title="任务提交流程"></a>任务提交流程</h2><p>我们来看看当一个应用提交执行时，Flink的各个组件是如何交互协作的：</p>
<img src="/blog/6799/clip_image001.png" class="img">

<p>图 任务提交和组件交互流程</p>
<p>上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如YARN，Mesos，Kubernetes，standalone等），其中一些步骤可以被省略，或是有些组件会运行在同一个JVM进程中。</p>
<p>具体地，如果我们将Flink集群部署到YARN上，那么就会有如下的提交流程：</p>
<img src="/blog/6799/clip_image002.jpg" class="img">

<p>图 Yarn模式任务提交流程</p>
<p>Flink任务提交后，Client向HDFS上传Flink的Jar包和配置，之后向Yarn ResourceManager提交任务，ResourceManager分配Container资源并通知对应的NodeManager启动ApplicationMaster，ApplicationMaster启动后加载Flink的Jar包和配置构建环境，然后启动JobManager，之后ApplicationMaster向ResourceManager申请资源启动TaskManager，ResourceManager分配Container资源后，由ApplicationMaster通知资源所在节点的NodeManager启动TaskManager，NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager，TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务。</p>
<h2 id="任务调度原理"><a href="#任务调度原理" class="headerlink" title="任务调度原理"></a>任务调度原理</h2><img src="/blog/6799/clip_image003.png" class="img">

<p>图 任务调度原理</p>
<p>客户端不是运行时和程序执行的一部分，但它用于准备并发送dataflow(JobGraph)给Master(JobManager)，然后，客户端断开连接或者维持连接以等待接收计算结果。</p>
<p>当 Flink 集群启动后，首先会启动一个 JobManger 和一个或多个的 TaskManager。由 Client 提交任务给 JobManager，JobManager 再调度任务到各个 TaskManager 去执行，然后 TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</p>
<p><strong>Client</strong> 为提交 Job 的客户端，可以是运行在任何机器上（与 JobManager 环境连通即可）。提交 Job 后，Client 可以结束进程（Streaming的任务），也可以不结束并等待结果返回。</p>
<p><strong>JobManager</strong> 主要负责调度 Job 并协调 Task 做 checkpoint，职责上很像 Storm 的 Nimbus。从 Client 处接收到 Job 和 JAR 包等资源后，会生成优化后的执行计划，并以 Task 的单元调度到各个 TaskManager 去执行。</p>
<p><strong>TaskManager</strong> 在启动的时候就设置好了槽位数（Slot），每个 slot 能启动一个 Task，Task 为线程。从 JobManager 处接收需要部署的 Task，部署启动后，与自己的上游建立 Netty 连接，接收数据并处理。</p>
<h3 id="TaskManger与Slots"><a href="#TaskManger与Slots" class="headerlink" title="TaskManger与Slots"></a>TaskManger与Slots</h3><p>Flink中每一个worker(TaskManager)都是一个<strong>JVM进程</strong>，它可能会在<strong>独立的线程</strong>上执行一个或多个subtask。为了控制一个worker能接收多少个task，worker通过task slot来进行控制（一个worker至少有一个task slot）。</p>
<p>每个task slot表示TaskManager拥有资源的<strong>一个固定大小的子集</strong>。假如一个TaskManager有三个slot，那么它会将其管理的内存分成三份给各个slot。资源slot化意味着一个subtask将不需要跟来自其他job的subtask竞争被管理的内存，取而代之的是它将拥有一定数量的内存储备。需要注意的是，这里不会涉及到CPU的隔离，slot目前仅仅用来隔离task的受管理的内存。</p>
<p>通过调整task slot的数量，允许用户定义subtask之间如何互相隔离。如果一个TaskManager一个slot，那将意味着每个task group运行在独立的JVM中（该JVM可能是通过一个特定的容器启动的），而一个TaskManager多个slot意味着更多的subtask可以共享同一个JVM。而在同一个JVM进程中的task将共享TCP连接（基于多路复用）和心跳消息。它们也可能共享数据集和数据结构，因此这减少了每个task的负载。</p>
<img src="/blog/6799/clip_image004.png" class="img">

<p>图 TaskManager与Slot</p>
<img src="/blog/6799/clip_image005.jpg" class="img">

<p>图 子任务共享Slot</p>
<p>默认情况下，Flink允许子任务共享slot，即使它们是不同任务的子任务（前提是它们来自同一个job）。 这样的结果是，一个slot可以保存作业的整个管道。</p>
<p><strong>Task Slot是静态的概念，是指TaskManager具有的并发执行能力</strong>，可以通过参数taskmanager.numberOfTaskSlots进行配置；而<strong>并行度parallelism是动态概念，即TaskManager运行程序时实际使用的并发能力</strong>，可以通过参数parallelism.default进行配置。</p>
<p>也就是说，假设一共有3个TaskManager，每一个TaskManager中的分配3个TaskSlot，也就是每个TaskManager可以接收3个task，一共9个TaskSlot，如果我们设置parallelism.default=1，即运行程序默认的并行度为1，9个TaskSlot只用了1个，有8个空闲，因此，设置合适的并行度才能提高效率。</p>
<img src="https://img-blog.csdn.net/20170824162738505?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTY4MjIzNDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="说明:" title="&#x2F;6799&#x2F;clip_image006.jpg">

<img src="https://img-blog.csdn.net/20170824162117401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTY4MjIzNDI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="说明:" title="&#x2F;6799&#x2F;clip_image007.jpg">

<h3 id="程序与数据流（DataFlow）"><a href="#程序与数据流（DataFlow）" class="headerlink" title="程序与数据流（DataFlow）"></a><strong>程序与数据流（DataFlow）</strong></h3><img src="/blog/6799/clip_image008.png" class="img">

<p>所有的Flink程序都是由三部分组成的：  <strong>Source</strong> 、<strong>Transformation</strong>和<strong>Sink</strong>。</p>
<p>Source负责读取数据源，Transformation利用各种算子进行处理加工，Sink负责输出。</p>
<p>在运行时，Flink上运行的程序会被映射成“逻辑数据流”（dataflows），它包含了这三部分。<strong>每一个dataflow以一个或多个sources开始以一个或多个sinks结束</strong>。dataflow类似于任意的有向无环图（DAG）。在大部分情况下，程序中的转换运算（transformations）跟dataflow中的算子（operator）是一一对应的关系，但有时候，一个transformation可能对应多个operator。</p>
<img src="/blog/6799/clip_image009.png" class="img">

<p>图 程序与数据流</p>
<h3 id="执行图（ExecutionGraph）"><a href="#执行图（ExecutionGraph）" class="headerlink" title="执行图（ExecutionGraph）"></a><strong>执行图（ExecutionGraph）</strong></h3><p>由Flink程序直接映射成的数据流图是StreamGraph，也被称为逻辑流图，因为它们表示的是计算逻辑的高级视图。为了执行一个流处理程序，Flink需要将逻辑流图转换为物理数据流图（也叫执行图），详细说明程序的执行方式。</p>
<p>Flink 中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图。</p>
<p><strong>StreamGraph</strong>：是根据用户通过 Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。</p>
<p><strong>JobGraph</strong>：StreamGraph经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。</p>
<p><strong>ExecutionGraph</strong>：JobManager 根据 JobGraph 生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。</p>
<p><strong>物理执行图</strong>：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。</p>
<img src="/blog/6799/clip_image010.jpg" class="img">

<h3 id="并行度（Parallelism）"><a href="#并行度（Parallelism）" class="headerlink" title="并行度（Parallelism）"></a><strong>并行度（Parallelism）</strong></h3><p>Flink程序的执行具有<strong>并行、分布式</strong>的特性。</p>
<p>在执行过程中，一个流（stream）包含一个或多个分区（stream partition），而每一个算子（operator）可以包含一个或多个子任务（operator subtask），这些子任务在不同的线程、不同的物理机或不同的容器中彼此互不依赖地执行。</p>
<p><strong>一个特定算子的子任务（subtask）的个数被称之为其并行度（parallelism）</strong>。一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中，不同的算子可能具有不同的并行度。</p>
<img src="/blog/6799/clip_image011.png" class="img">

<p>图 并行数据流</p>
<p>Stream在算子之间传输数据的形式可以是one-to-one(forwarding)的模式也可以是redistributing的模式，具体是哪一种形式，取决于算子的种类。</p>
<p><strong>One-to-one</strong>：stream(比如在source和map operator之间)维护着分区以及元素的顺序。那意味着map 算子的子任务看到的元素的个数以及顺序跟source 算子的子任务生产的元素的个数、顺序相同，map、fliter、flatMap等算子都是one-to-one的对应关系。</p>
<h4 id="类似于spark中的窄依赖"><a href="#类似于spark中的窄依赖" class="headerlink" title="类似于spark中的窄依赖"></a>类似于spark中的<strong>窄依赖</strong></h4><p><strong>Redistributing</strong>：stream(map()跟keyBy/window之间或者keyBy/window跟sink之间)的分区会发生改变。每一个算子的子任务依据所选择的transformation发送数据到不同的目标任务。例如，keyBy() 基于hashCode重分区、broadcast和rebalance会随机重新分区，这些算子都会引起redistribute过程，而redistribute过程就类似于Spark中的shuffle过程。</p>
<h4 id="类似于spark中的宽依赖"><a href="#类似于spark中的宽依赖" class="headerlink" title="类似于spark中的宽依赖"></a>类似于spark中的<strong>宽依赖</strong></h4><h3 id="任务链（Operator-Chains）"><a href="#任务链（Operator-Chains）" class="headerlink" title="任务链（Operator Chains）"></a><strong>任务链（Operator Chains）</strong></h3><p><strong>相同并行度的one to one操作</strong>，Flink这样相连的算子链接在一起形成一个task，原来的算子成为里面的一部分。将算子链接成task是非常有效的优化：它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。链接的行为可以在编程API中进行指定。</p>
<img src="/blog/6799/clip_image012.jpg" class="img">

<p>图 task与operator chains</p>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>什么是数据仓库</title>
    <url>/blog/f544.html</url>
    <content><![CDATA[<h1 id="数据仓库发展历史"><a href="#数据仓库发展历史" class="headerlink" title="数据仓库发展历史"></a>数据仓库发展历史</h1><h3 id="萌芽阶段"><a href="#萌芽阶段" class="headerlink" title="萌芽阶段"></a>萌芽阶段</h3><ul>
<li>20世纪70年代MIT提出将业务处理系统和分析系统分开，针对各自不同特点设计不同的架构</li>
</ul>
<h3 id="探索阶段"><a href="#探索阶段" class="headerlink" title="探索阶段"></a>探索阶段</h3><ul>
<li>20世纪80年代中后期DEC结合MIT理论，建立TA2规范定义分析系统的四个组成部分：数据获取、数据访问、目录和用户服务</li>
</ul>
<h3 id="雏形阶段"><a href="#雏形阶段" class="headerlink" title="雏形阶段"></a>雏形阶段</h3><ul>
<li>1988年IBM第一次提出信息仓库的概念并称之为VITAL规范。VITAL定义了85种信息仓库组件，包括PC、图形化界面、面向对象的组件以及局域网等</li>
</ul>
<h3 id="确立阶段"><a href="#确立阶段" class="headerlink" title="确立阶段"></a>确立阶段</h3><ul>
<li>1991年Bill Inmon出版《Build the Data Warehouse》标志着数据仓库概念的确立</li>
</ul>
<p>数据仓库的两本经典著作（中译版）</p>
<img src="/blog/f544/1503507261-1_w_1.jpg" class="img">

<img src="/blog/f544/27907592-1_w_1.jpg" class="img">

<p>第一本书的理念是：<br>数据仓库一个面向主题的<br>（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策（DecisionMaking Support）</p>
<p>第二本书的理念是：<br>数据仓库是一个将源系统数据抽取、清洗、规格化、提交到维度数据存储的系统，为决策的制定提供查询和分析功能的支撑与实现。</p>
<p>这两本书的理念有一些区别，国内的数据仓库是糅合了这两本数的理念，数仓的定位是第一本的理念，而实际操作是按照第二本书的理念来的。</p>
<h3 id="数据-仓库-数据仓库？"><a href="#数据-仓库-数据仓库？" class="headerlink" title="数据 + 仓库 = 数据仓库？"></a>数据 + 仓库 = 数据仓库？</h3><img src="/blog/f544/image-20200523234241897.png" class="image-20200523234241897">



<h3 id="什么时候需要建立数据仓库？"><a href="#什么时候需要建立数据仓库？" class="headerlink" title="什么时候需要建立数据仓库？"></a>什么时候需要建立数据仓库？</h3><ul>
<li>1、当你需要集中化管理你的数据时</li>
<li>2、当你希望以更高效的方式使用数据时</li>
<li>3、当你的数据量和复杂度到了需要一个团队来维护时</li>
<li>4、当你希望想要数据驱动业务时</li>
<li>5、当你想要借助大数据的力量来提升产品竞争力时</li>
<li>6、当你想时刻知道业务发展情况时</li>
</ul>
<h3 id="数据仓库和数据中台关系"><a href="#数据仓库和数据中台关系" class="headerlink" title="数据仓库和数据中台关系"></a>数据仓库和数据中台关系</h3><p>数据仓库是中间的方框部分，是数据中台的基础设施，而数据采集又是数据仓库的基础设施。</p>
<img src="/blog/f544/image-20200523235452060.png" class="image-20200523235452060">



<p>参考：<a href="https://www.bilibili.com/video/BV1Z4411m7NV?p=3">https://www.bilibili.com/video/BV1Z4411m7NV?p=3</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Frp内网穿透实现minecraft远程联机</title>
    <url>/blog/6b1f.html</url>
    <content><![CDATA[<p>过年想在家玩minecraft，公网多人游戏，理论上完全可行，自己琢磨了一下，记录如何配置内网穿透</p>
<blockquote>
<ol>
<li>VPS搭建minecraft服务器。</li>
<li>内网穿透，VPS做TCP端口转发。</li>
</ol>
</blockquote>
<p>第一个方案，服务器端架设成功了，但是不可以加mods和插件。另外由于服务器配置太低，运行一段时间就会崩溃。以失败告终。<br>第二个方案，花点时间琢磨了一下，发现可行。下文为配置方法</p>
<h2 id="实现功能和原理"><a href="#实现功能和原理" class="headerlink" title="实现功能和原理"></a>实现功能和原理</h2><p>minecraft公网联机，公网服务器安装Frps，来实现转发服务。内网主机安装Frpc，来实现穿透。</p>
<h2 id="配置前准备"><a href="#配置前准备" class="headerlink" title="配置前准备"></a>配置前准备</h2><blockquote>
<p>公网服务器一台 ,假设我的服务器IP是155.155.155.156<br>内网电脑一台<br>域名一个 ，假设我的域名是baidu.com</p>
</blockquote>
<h2 id="解析域名到公网服务器的IP"><a href="#解析域名到公网服务器的IP" class="headerlink" title="解析域名到公网服务器的IP"></a>解析域名到公网服务器的IP</h2><p>添加一条A记录，主机记录自定义，我写的是router</p>


<h2 id="安装Frp"><a href="#安装Frp" class="headerlink" title="安装Frp"></a>安装Frp</h2><p><a href="https://github.com/fatedier/frp">项目地址</a></p>
<h3 id="公网服务器端"><a href="#公网服务器端" class="headerlink" title="公网服务器端"></a>公网服务器端</h3><p>找到与自己服务器和本地主机对应版本，下载即可。<br>我的VPS是搬瓦工的低配，如下</p>

<p>安装的是CentOS6_32位系统，所以就下载Linux32位的软件 frp_x.x.x_linux_386.tar.gz<br>下载并解压后得到一个文件夹，里面有七个文件，对于公网服务器来说只有frps和frps.ini是我们必需的。</p>
<h4 id="配置frps-ini"><a href="#配置frps-ini" class="headerlink" title="配置frps.ini"></a>配置frps.ini</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">bind_udp_port = 7001</span><br><span class="line">vhost_http_port = 80</span><br><span class="line">vhost_https_port = 10443</span><br></pre></td></tr></table></figure>
<p>3，4两行是必须配置的，端口可以自定义，5，6两行是其他的服务，可以照抄或者不予理会。<br>使用下面命令运行<br><code>./frps -c ./frps.ini</code><br>我相信你可以通过Screen插件让此服务保持后台运行，此服务建议一直运行。</p>
<h3 id="内网电脑端"><a href="#内网电脑端" class="headerlink" title="内网电脑端"></a>内网电脑端</h3><p>打开minecraft游戏，开启局域网联机，生成一个端口号，记下来。</p>
<p>找到与自己电脑对应的版本，下载即可。我本地电脑win_x64系统，所以下载frp_0.22.0_windows_amd64.zip。<br>和之前一样解压得到7个文件，只有frpc.exe和frpc.ini是我们必需的。</p>
<h4 id="配置frpc-ini"><a href="#配置frpc-ini" class="headerlink" title="配置frpc.ini"></a>配置frpc.ini</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"></span><br><span class="line"># x.x.x.x为公网服务器IP地址，只需设置一次</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line"></span><br><span class="line"># server_port填写上面配置的bind_port值，只需设置一次</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[range:test_tcp]</span><br><span class="line">type = tcp</span><br><span class="line"># local_ip填写我们电脑的局域网ip，每次开启游戏需要修改。</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line"></span><br><span class="line"># local_port填写刚才记下的minecraft生成的端口号，每次开启游戏需要修改。</span><br><span class="line">local_port = 10240</span><br><span class="line"></span><br><span class="line">#这里自定义，建议填写五位数的端口号，不超过65535，小伙伴开启游戏时候填这个。只需设置一次</span><br><span class="line">remote_port = 25600</span><br></pre></td></tr></table></figure>
<p>双击frpc.exe,弹出一个黑框，把这个黑框最小化后台。</p>


<p>在远方的小伙伴，开启游戏，选择多人游戏，直接连接，输入router.baidu.com:25600，加入服务器玩耍吧。</p>

<p>【注】：router为设置的主机记录，baidu.com为自己的域名，25600为上面设置的remote_port端口号。</p>
<hr>
<p>以后每次开游戏，先打开游戏生成端口号，然后修改frpc.ini，打开frpc.exe并后台，小伙伴联机即可。</p>
]]></content>
  </entry>
  <entry>
    <title>数据仓库建模流程</title>
    <url>/blog/a231.html</url>
    <content><![CDATA[<p>模型设计的三个阶段：</p>
<ul>
<li>概念模型</li>
<li>逻辑模型</li>
<li>物理模型</li>
</ul>
<h2 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h2><p>概念模型需要确定系统的核心以及划清系统范围和边界，主要是指通过分析和归纳，将业务划分成几个主题，并确定主题之间的关系</p>
<p>比如：<br>电影行业：影院、影片、影人、用户、订单、渠道、发行等<br>出行行业：司机、乘客、订单、支付、车辆等<br>电商行业：订单、支付、售后、物流、流量等<br>保险行业：客户、渠道、理赔、核保、团体、风控、人管等</p>
<p>概念模型阶段重点:</p>
<ul>
<li>注重全局的理解而非细节</li>
<li>在概念模型阶段，即需要对整体架构做思考概念模型通常是自上而下的模式，通过会议等模式反复沟通，澄清需求</li>
<li>在此阶段，应粗略地估算出整个项目需要的时间以及项目计划草案</li>
<li>根据计划粗略地估算出项目的费用</li>
<li>是数据模型工程师与客户沟通的破冰之旅，使他们在此期间达成共识并奠定未来良好的沟通基础以及私人关系</li>
<li>出品的概念模型可以帮助划定系统边界以及避免方向性的错误</li>
<li>商业主导，相比技术专家而言，更需要商业专家</li>
<li>是未来逻辑模型的沟通基础，以及逐步求精的依据</li>
</ul>
<p>概念模型交付品通常具备如下特点：</p>
<ul>
<li>与客户（业务需求方）一致的商业语言</li>
<li>尽量一页纸描述清楚整个模型</li>
<li>通常用实体关系型图表示，但不需添加实体的属性</li>
<li>允许多对多的关系存在</li>
</ul>
<p>这个阶段一般由架构师，项目负责人，项目经理主导，与业务需求方人员开会讨论，确定需求。</p>
<h2 id="逻辑模型"><a href="#逻辑模型" class="headerlink" title="逻辑模型"></a>逻辑模型</h2><p>逻辑模型需要梳理业务规则以及对概念模型的求精，在概念模型的基础上，定义数据仓库各种实体、属性、关系，指导后续的数据存储、组织和数据应用的开发。目前比较流行的建模理论为Inmon提出的自下而上（EDW-DM）的范式建模理论和Kimball的从上而下的（DM-DW）的维度建模理论。逻辑模型建模的工作量占到数据建模的整体工作量的60%-70%，是最重要的一个环节。</p>
<h3 id="范式建模"><a href="#范式建模" class="headerlink" title="范式建模"></a>范式建模</h3><ul>
<li>第一范式：属性不可分割</li>
<li>第二范式：存在主键，每行数据具备唯一性</li>
<li>第三范式：不存在传递依赖</li>
</ul>
<h3 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h3><ul>
<li>星型模型：由一一个事实表和一组维表组成，每个维表都有一个维度作为主键，事实表居中，多个维表呈辐射状分布于其四周，并与事实表连接，形成一个星型结构。</li>
<li>雪花模型：在星型模型基础上，基于范式理论进一步层次化，将某些维表扩展成事实表，最终形成雪花状结构。</li>
<li>星座模型：由多个事实表组合，维表是公共的，可以被多个事实表共享。</li>
</ul>
<p>数据仓库大多数时候是比较适合使用维度建模的<strong>星型模型</strong>构建底层数据Hive表，通过大量的冗余来提升查询效率（反三范式），星型模型对OLAP的分析引擎支持比较友好，这一点在Kylin中比较能体现。</p>
<p>对比建筑设计图，逻辑模型阶段需要输出数据模型文件。</p>
<img src="/blog/a231/image-20200524193551680.png" class="image-20200524193551680">



<p>逻辑模型需要注意的问题：</p>
<ul>
<li>当实体数量超过100时，需要定义术语表</li>
<li>规范化</li>
<li>先规范化再逆规范化，不可一步到位</li>
<li>不可缺少约束的定义</li>
<li>使用CASE工具做逻辑模型</li>
<li>需要同级评审（Peer Review）</li>
<li>确定可信赖数据源，关键属性需用真实数据验证</li>
<li>应用成熟的建模模式（Pattern）</li>
<li>定程度的抽象化，决定了未来模型的弹性</li>
<li>高质量的模型定义</li>
<li>重要关联关系需要强制建立</li>
<li>与概念模型保持一致</li>
<li>注意模型的版本管理</li>
<li>非常非常注意细节</li>
<li>数据库专家深度介入</li>
<li>占据整个数据建模80%以上时间</li>
<li>不要忽视属性的长度定义和约束定义</li>
<li>不要忽视属性的默认值（Default Value）</li>
<li>使用控制数据范围的域（Domain）</li>
</ul>
<p>逻辑模型交付品特点：</p>
<ul>
<li>要像一本书，而非一页纸</li>
<li>所有实体属性均需添加</li>
<li>实体间关系要清晰描述</li>
<li>使用术语表</li>
<li>遵循命名规范</li>
<li>采用CASE工具创建项目文件</li>
<li>对各个实体必须有清晰描述</li>
<li>对关键属性必须有清晰描述</li>
</ul>
<p>逻辑模型阶段一般由项目负责人或者架构师，与开发人员进行详细沟通，把业务需求明确细化的传达给开发人员，具体建模流程由架构师主导，开发人员具体实施，并输出细节文档。</p>
<h2 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h2><p>物理模型需要从性能、访问、开发等多方面考虑，做系统的实现设计。<br>根据逻辑模型设计的结构为基础，设计数据对象的物理实现，比如表的命名规范、字段的命名规范、字段类型选择、分区设置、存储设置，更行方式等等。</p>
<img src="/blog/a231/image-20200524210531986.png" class="image-20200524210531986">

<p>物理模型需要注意的问题：</p>
<ul>
<li>使用CASE工具由逻辑模型自动生成</li>
<li>应用术语表自动转换生成字段名称</li>
<li>对表空间、索引、视图、物化视图、主键、外键等都有命名规则逆规范化在逻辑层完成，而非本层</li>
<li>数据库DBA深度介入，需要DBA的评审（Peer Review）</li>
<li>和数据库的DDL保持一致</li>
<li>注意版本管理</li>
<li>注意开发、测试、生产三个不同版本的模型管理</li>
<li>注意性能</li>
<li>估算数据规模</li>
<li>考虑数据归档</li>
<li>充分考虑未来使用数据库的优点和缺点</li>
</ul>
<p>物理建模交付品的特点</p>
<ul>
<li>自动生成基础库表结构，之后适度手动调整</li>
<li>与未来要使用的数据库类型息息相关</li>
<li>生成数据字典并发布</li>
<li>可直接用于生成DDL </li>
<li>DDL中注意注释的生成</li>
</ul>
<p>物理模型即开发人员的最终的输出，是整个建模过程中最后的落地实现。</p>
<hr>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>初识Flink</title>
    <url>/blog/d552.html</url>
    <content><![CDATA[<p>Flink起源于Stratosphere项目，Stratosphere是在2010~2014年由3所地处柏林的大学和欧洲的一些其他的大学共同进行的研究项目，2014年4月Stratosphere的代码被复制并捐赠给了Apache软件基金会，参加这个孵化项目的初始成员是Stratosphere系统的核心开发人员，2014年12月，Flink一跃成为Apache软件基金会的顶级项目。</p>
<p>在德语中，Flink一词表示快速和灵巧，项目采用一只松鼠的彩色图案作为logo，这不仅是因为松鼠具有快速和灵巧的特点，还因为柏林的松鼠有一种迷人的红棕色，而Flink的松鼠logo拥有可爱的尾巴，尾巴的颜色与Apache软件基金会的logo颜色相呼应，也就是说，这是一只Apache风格的松鼠。</p>
<img src="/blog/d552/clip_image001.jpg" class="img">

<img src="/blog/d552/clip_image002.jpg" class="img">

<p>Flink Logo</p>
<p>Flink项目的理念是：“Apache Flink是为分布式、高性能、随时可用以及准确的流处理应用程序打造的开源流处理框架”。</p>
<p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。Flink被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。</p>
<img src="/blog/d552/clip_image003.jpg" class="img">

<p>1.2  Flink的重要特点 </p>
<p><strong>1.2.1</strong>  <strong>事件驱动型</strong><strong>(Event-driven)</strong></p>
<p>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。比较典型的就是以kafka为代表的消息队列几乎都是事件驱动型应用。</p>
<p>与之不同的就是SparkStreaming微批次，如图：</p>
<img src="/blog/d552/clip_image004.jpg" class="img">

<p>事件驱动型：</p>
<img src="/blog/d552/clip_image005.png" class="img">

<p><strong>1.2.2</strong> <strong>流与批的世界观</strong></p>
<p><strong>批处理</strong>的特点是有界、持久、大量，非常适合需要访问全套记录才能完成的计算工作，一般用于离线统计。</p>
<p><strong>流处理</strong>的特点是无界、实时,  无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。</p>
<p>在spark的世界观中，一切都是由批次组成的，离线数据是一个大批次，而实时数据是由一个一个无限的小批次组成的。</p>
<p>而在flink的世界观中，一切都是由流组成的，离线数据是有界限的流，实时数据是一个没有界限的流，这就是所谓的有界流和无界流。</p>
<p><strong>无界数据流</strong>：无界数据流有一个开始但是没有结束，它们不会在生成时终止并提供数据，必须连续处理无界流，也就是说必须在获取后立即处理event。对于无界数据流我们无法等待所有数据都到达，因为输入是无界的，并且在任何时间点都不会完成。处理无界数据通常要求以特定顺序（例如事件发生的顺序）获取event，以便能够推断结果完整性。</p>
<p><strong>有界数据流</strong>：有界数据流有明确定义的开始和结束，可以在执行任何计算之前通过获取所有数据来处理有界流，处理有界流不需要有序获取，因为可以始终对有界数据集进行排序，有界流的处理也称为批处理。</p>
<img src="/blog/d552/clip_image006.jpg" class="img">

<p>这种以流为世界观的架构，获得的最大好处就是具有极低的延迟。</p>
<p><strong>1.2.3</strong> <strong>分层****api</strong></p>
<img src="/blog/d552/clip_image007.jpg" class="img">

<p>最底层级的抽象仅仅提供了有状态流，它将通过过程函数（Process Function）被嵌入到DataStream API中。底层过程函数（Process Function） 与 DataStream API 相集成，使其可以对某些特定的操作进行底层的抽象，它允许用户可以自由地处理来自一个或多个数据流的事件，并使用一致的容错的状态。除此之外，用户可以注册事件时间并处理时间回调，从而使程序可以处理复杂的计算。</p>
<p>实际上，大多数应用并不需要上述的底层抽象，而是针对核心API（Core APIs） 进行编程，比如DataStream API（有界或无界流数据）以及DataSet API（有界数据集）。这些API为数据处理提供了通用的构建模块，比如由用户定义的多种形式的转换（transformations），连接（joins），聚合（aggregations），窗口操作（windows）等等。DataSet API 为有界数据集提供了额外的支持，例如循环与迭代。这些API处理的数据类型以类（classes）的形式由各自的编程语言所表示。</p>
<p>Table API 是以表为中心的声明式编程，其中表可能会动态变化（在表达流数据时）。Table API遵循（扩展的）关系模型：表有二维数据结构（schema）（类似于关系数据库中的表），同时API提供可比较的操作，例如select、project、join、group-by、aggregate等。Table API程序声明式地定义了什么逻辑操作应该执行，而不是准确地确定这些操作代码的看上去如何。</p>
<p>尽管Table API可以通过多种类型的用户自定义函数（UDF）进行扩展，其仍不如核心API更具表达能力，但是使用起来却更加简洁（代码量更少）。除此之外，Table API程序在执行之前会经过内置优化器进行优化。</p>
<p>你可以在表与 DataStream/DataSet 之间无缝切换，以允许程序将 Table API 与 DataStream 以及 DataSet 混合使用。</p>
<p>Flink提供的最高层级的抽象是 SQL 。这一层抽象在语法与表达能力上与 Table API 类似，但是是以SQL查询表达式的形式表现程序。SQL抽象与Table API交互密切，同时SQL查询可以直接在Table API定义的表上执行。</p>
<p>目前Flink作为批处理还不是主流，不如Spark成熟，所以DataSet使用的并不是很多。Flink Table API和Flink SQL也并不完善，大多都由各大厂商自己定制。所以我们主要学习DataStream API的使用。实际上Flink作为最接近Google DataFlow模型的实现，是流批统一的观点，所以基本上使用DataStream就可以了。</p>
<p>Flink几大模块</p>
<ul>
<li>Flink Table &amp; SQL(还没开发完)</li>
<li>Flink Gelly(图计算)</li>
<li>Flink CEP(复杂事件处理)</li>
</ul>
]]></content>
      <categories>
        <category>Flink</category>
      </categories>
  </entry>
  <entry>
    <title>数据仓库相关概念</title>
    <url>/blog/788d.html</url>
    <content><![CDATA[<h1 id="什么是OLAP-OLTP"><a href="#什么是OLAP-OLTP" class="headerlink" title="什么是OLAP/OLTP?"></a>什么是OLAP/OLTP?</h1><p>联机事务处理：OLTP，全称On-line Transaction Processing</p>
<p>联机分析处理：OLAP，全称On-line Analytical Processing</p>
<img src="/blog/788d/image-20200524105954281.png" class="image-20200524105954281">



<p>孤立性我们常常称为隔离性。</p>
<p>上钻：从粗粒度往细粒度进行细化</p>
<p>上卷：从细粒度往粗粒度进行汇总</p>
<p>多个维度的数据形成了数据立方体，我们在对部分维度进行限制的时候，就相当于对数据立方体进行了切块，当限制部分维度的值为固定值的时候，数据立方体就被切成了片，非常形象化。</p>
<p>旋转：把行和列进行对调，例如按照地区统计各产品销量信息，和按照产品统计各地区销量。</p>
<img src="/blog/788d/image-20200524113843986.png" class="image-20200524113843986">



<p>OLAP是业务分析导向，一般不符合范式规则，常常有很多数据冗余，传递依赖等，优点是查询效率很高，很少的join操作，一般一张业务报表仅来源于一张底层表，常见于各种即席分析系统如Kylin，Druid等。早期也会使用关系型数据库，现在常见使用分布式集群进行处理，如Hive等。</p>
<p>OLTP是业务效率导向，几乎没有数据冗余，表非常多，各种维表码表，符合三范式，增删改查频繁，常见如ERP，SAP，企业OA等系统。一般使用关系型数据库，MySQL，Oracle等。</p>
<p>数仓整体开发流程</p>
<img src="/blog/788d/image-20200524121215144.png" class="image-20200524121215144">]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>企业级数据仓库介绍</title>
    <url>/blog/1390.html</url>
    <content><![CDATA[<h1 id="数仓痛点"><a href="#数仓痛点" class="headerlink" title="数仓痛点"></a>数仓痛点</h1><p>目前数据仓库的痛点：</p>
<ul>
<li>痛点一：临时取数需求占用数仓人员大部分时间</li>
<li>痛点二：数仓规范和流程不一致，跨部门合作困难</li>
<li>痛点三：指标口径不一致导致数据可信度下降</li>
<li>痛点四：烟囱式开发形成的数据孤岛与重复计算</li>
<li>痛点五：数据膨胀导致计算资源紧张，出数时间得不到保障</li>
<li>痛点六：异常排查时间和修复时间长</li>
<li>痛点七：数据安全和数据共享矛盾不可调和</li>
<li>痛点八：产出形式单一</li>
<li>痛点九：业务需求响应不及时</li>
</ul>
<img src="/blog/1390/image-20200523215301190.png" class="image-20200523215301190">



<h1 id="数仓模型"><a href="#数仓模型" class="headerlink" title="数仓模型"></a>数仓模型</h1><img src="/blog/1390/image-20200523215758029.png" class="image-20200523215758029">

<p>接入层：ODS层</p>
<p>中间层：DW层和DM层</p>
<p>应用层：APP层</p>
<img src="/blog/1390/image-20200523220335657.png" class="image-20200523220335657">

<p>调用原则：</p>
<img src="/blog/1390/image-20200523220901043.png" class="image-20200523220901043">

<p>总原则：</p>
<ul>
<li>禁止逆向调用</li>
<li>避免同层调用</li>
<li>优先使用公共层</li>
<li>避免跨层调用</li>
</ul>
<h1 id="数仓规范"><a href="#数仓规范" class="headerlink" title="数仓规范"></a>数仓规范</h1><p>表命名规范：</p>
<img src="/blog/1390/image-20200523221301354.png" class="image-20200523221301354">

<p>做到见名知意，根据约定同事之间可以对表做到见名知意，这样的表命名是比较规范。</p>
<p>字段命名规范：</p>
<img src="/blog/1390/image-20200523221952779.png" class="image-20200523221952779">

<p>分区字段数一般不超过三层</p>
<p>数据开发有测试环节，但一般没有专职测试人员，测试基本都是开发人员自己做。没有办法直观判断数据计算对不对，最好的办法就是把开发的代码从头撸一遍，有能力把代码从头撸一遍的人可能比开发更懂业务和技术，不可能去做测试，所以开发没有专职测试人员，所以测试这个工作都是要开发自己做。</p>
<p>数据开发规范：</p>
<img src="/blog/1390/image-20200523223157993.png" class="image-20200523223157993">



<p>临时表命名规范：包含<code>temp</code>字段，包含时间戳，包含编号，包含输出的表的表名。</p>
<p>脚本命名和任务命名保持一致。</p>
<p>Lambda架构</p>
<img src="/blog/1390/image-20200523223924651.png" class="image-20200523223924651">

<h1 id="外围系统建设"><a href="#外围系统建设" class="headerlink" title="外围系统建设"></a>外围系统建设</h1><img src="/blog/1390/image-20200523224439858.png" class="image-20200523224439858">

<h2 id="任务调度："><a href="#任务调度：" class="headerlink" title="任务调度："></a>任务调度：</h2><ul>
<li>Airflow</li>
<li>Azkaban</li>
<li>Oozie</li>
<li>企业自研调度平台</li>
</ul>
<h2 id="元数据管理系统"><a href="#元数据管理系统" class="headerlink" title="元数据管理系统"></a>元数据管理系统</h2><p>元数据管理系统(MDV)是外部了解数仓的门户入口，一个好的元数据系统至少应包含如下信息：</p>
<ul>
<li>1、表信息：包括表英文名、中文注释、表状态（在线&amp;下线）</li>
<li>2、字段信息：包括字段类型、英文名、中文名、字段注释、保密级别（机密/保密/一般）、统计逻辑说明</li>
<li>3、负责人信息：业务/开发负责人名超链接、所在部门</li>
<li>4、分区信息：分区名、分区大小、分区记录条数、生成分区的时间5、血缘信息：表上游、下游节点信息</li>
<li>6、代码信息：生成该表对应的代码地址超链接</li>
<li>7、存储信息：总表大小、波动情况</li>
<li>8、热度信息：标识被下游依赖的多寡</li>
<li>9、权限信息：申请访问超链接、权限审批到单人单表单字段粒度，不同保密级别字段对应不同审批流程</li>
<li>10、使用注意事项QA等</li>
</ul>
<h2 id="数据质量监控"><a href="#数据质量监控" class="headerlink" title="数据质量监控"></a>数据质量监控</h2><p>数据质量监控系统主要基于规则判断达到数据监控的目的，系统建设一般分为三个阶段</p>
<ul>
<li>1、表级别的监控：主要为表的总条数、总大小、分区数据、各分区条数，各分区大小，条数/大小同环比，日增长情况等</li>
<li>2、字段级别监控：枚举值异常判断、特殊值判断、范围判断等</li>
<li>3、全链路数据监控：主要依赖于上下游血缘分析，自动判断跟踪故障点，并及时告知相关负责人</li>
</ul>
<p>其中，表级别和字段级别的监控是比较常规且易实现的监控方式，全链路数据监控比这两者要复杂很多，涉及到从源数据-&gt;数据通道-&gt;数据ETL-&gt;数据展示的全过程</p>
<p>数据监控并不一定能杜绝错误，而是要提前早于业务方知道错误，以致于当业务方或者老板质问数据部门的时候，能及时解释原因，而不是一问三不知。</p>
<h1 id="发展方向展望"><a href="#发展方向展望" class="headerlink" title="发展方向展望"></a>发展方向展望</h1><p>数据产品化：</p>
<ul>
<li>面向管理层的宏观经营分析系统</li>
<li>面向运营人员的业务监控报表系统</li>
<li>面向广告以及营销的一体化数据营销平台<br>其中营销平台涉及用户圈选+用户触达+日志回流+效果分析（实验组+对照组）</li>
</ul>
<p>数据服务化：</p>
<ul>
<li>数据以接口方式直接服务于线上业务</li>
<li>数据以共享平台方式提供基础标签服务</li>
</ul>
<p>参考：<a href="https://www.bilibili.com/video/BV1Z4411m7NV?p=1">https://www.bilibili.com/video/BV1Z4411m7NV?p=1</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>2020年4月总结</title>
    <url>/blog/f274.html</url>
    <content><![CDATA[<p>本站友链第一条：稚晖的博客，这位博主现在已经是30万粉丝的UP主了。为了不拉低up主的友链质量，决定以后保证文章质量的前提下，尽量提高更新频率。</p>
<p>四月份当当网书香节，买了三本书，分别是</p>
<ul>
<li>用户画像：方法论与工程化解决方案</li>
<li>Hive性能调优实战</li>
<li>数据仓库工具箱(第3版)——维度建模权威指南</li>
</ul>
<p>其中《Hive性能调优实战》已经看完，上一篇文章中提到了一些总结，收获颇丰。<br>《用户画像》这本还没有看，《数据仓库工具箱》这本书讲了太多维度建模的名词，没有业务场景支撑很难理解，书评描述为经典，等以后达到一定高度再看。</p>
<hr>
<p>另外看了一本电子书《一年顶十年》作者 彪悍一只猫<br>这本书更像是一本问答书，为什么要做xx? 如何做？书中的信息密度真的比较大，目前我仅仅提炼了一些对当下的我有帮助的一些观点，并尝试应用其中的一小部分。<br>作者传播的一句话，简单明了</p>
<blockquote>
<p>让自己变得更好，是解决一切问题的关键</p>
</blockquote>
<h3 id="及时掏空自己："><a href="#及时掏空自己：" class="headerlink" title="及时掏空自己："></a>及时掏空自己：</h3><p>通过学习和实践，脑子里会不断增加新的储备，千万不要把这些储备束之高阁，否则就会很快忘掉，一定要及时“派发”出去。</p>
<h3 id="买经验："><a href="#买经验：" class="headerlink" title="买经验："></a>买经验：</h3><p>进入一个新的领域，最好的方法是向这个领域的专家请教。</p>
<h3 id="如成为某个领域的高手？"><a href="#如成为某个领域的高手？" class="headerlink" title="如成为某个领域的高手？"></a>如成为某个领域的高手？</h3><p>集中突破训练<br>读透几本书，反复钻研<br>活在高手堆里，很难成为低手。</p>
<p>用，才是最好的读。</p>
<h3 id="如何读书？"><a href="#如何读书？" class="headerlink" title="如何读书？"></a>如何读书？</h3><p>写<strong>践行清单</strong></p>
<ul>
<li>哪些是我要用的上的？</li>
<li>针对上面的每一条内容，我该怎么做？</li>
</ul>
<h3 id="读书三板斧："><a href="#读书三板斧：" class="headerlink" title="读书三板斧："></a>读书三板斧：</h3><ul>
<li>重复读</li>
<li>盯作者</li>
<li>勤分享</li>
</ul>
<h3 id="写作："><a href="#写作：" class="headerlink" title="写作："></a>写作：</h3><ul>
<li>写作是改运级别的武器</li>
<li>写作是打造个人品牌的神器</li>
</ul>
<h3 id="常被碾压"><a href="#常被碾压" class="headerlink" title="常被碾压"></a>常被碾压</h3><ul>
<li>向上学，向下帮</li>
<li>日拱一卒</li>
</ul>
<p>现在我正在践行两条：<br><strong>及时掏空自己</strong>和<strong>写作</strong></p>
<p>书中的信息密度真的比较大，目前我仅仅提炼了一些对当下的我有帮助的一些观点，并尝试应用其中的一小部分。</p>
<p>[1]剽悍一只猫.一年顶十年[E].北京联合出版公司，2020.</p>
]]></content>
      <categories>
        <category>月度总结</category>
      </categories>
  </entry>
  <entry>
    <title>范式建模和维度建模对比</title>
    <url>/blog/3264.html</url>
    <content><![CDATA[<h1 id="范式建模"><a href="#范式建模" class="headerlink" title="范式建模"></a>范式建模</h1><p>该方法的主要由Inmon所提倡，主要利用关系型数据库进行数据仓库的建设，且模型的建设方法和业务系统的数据模型比较类似<br>经典范式理论中，一个符合第三范式的关系必须具有以下三个条件：</p>
<ul>
<li>1NF：每个属性值唯一，不具有多义性；</li>
<li>2NF：每个非主属性必须完全依赖于整个主键，而非主键的一部分；</li>
<li>3NF：每个非主属性不能依赖于其他关系中的属性。</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>节约存储</li>
<li>结构清晰</li>
<li>易于理解</li>
<li>适合关系型数据库</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>构建比较繁琐</li>
<li>查询复杂</li>
<li>不适合构建在大数据分布式环境下</li>
</ul>
<p>虽然有这些缺点，但是范式建模的理论，仍然是需要我们去熟练掌握。原因有如几点：</p>
<ul>
<li>数据仓库的上游有相当一部分数据源是业务数据库，而这些业务数据库，其理论一般基于范式理论；</li>
<li>数据源的规范定义需要我们了解范式理论；</li>
<li>数据仓库下游系统比如报表系统设计时，可能会用到范式理论。</li>
</ul>
<h1 id="维度建模"><a href="#维度建模" class="headerlink" title="维度建模"></a>维度建模</h1><p>范式由于存在上述的问题，Kimball根据自己的经验，提出的维度建模的理论，即数据都可以抽象成事实和维度，维度为观察事物的角度，事实为对应某粒度下的度量值，一般，维度建模的步骤如下：</p>
<ul>
<li>1.选择业务过程<br>业务过程是-系列操作活动，转换为事实表中的事实，例如每个月每个账单快照</li>
<li>2.声明粒度<br>粒度是指事实表中的一行代表什么。同一事实表不要混用粒度，最好从最小粒度开始设计维度，因其能承受用户无法预知的查询需求。</li>
<li>3.确认维度<br>维度是根据粒度将表分开成多个维度表，即从不同维度（角度）去看。<br>维度是数据仓库的灵魂，是BI的入口和驱动</li>
<li>4.确认事实<br>事实是指一种在某个粒度下的度量，例如在销售维度中，销量和总额是良好的事实，而商店经理的工资则不允许出现在该维度中。</li>
</ul>
<h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>方便使用</li>
<li>适合大数据下的数据处理</li>
<li>适合进行OL AP操作</li>
</ul>
<h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>维度补全造成的数据存储的浪费</li>
<li>维度变化造成的数据更新量大</li>
<li>与范式理论差异很大，是典型的反三范式</li>
</ul>
<h1 id="维度建模举例"><a href="#维度建模举例" class="headerlink" title="维度建模举例"></a>维度建模举例</h1><p>假设我们要构建的是一张订单表，那业务过程即为这个具体是哪种业务场景下的订单数据;</p>
<p>粒度即为该表中的每一 条数据具体是细化到如何的程度，是一条数据代表一个订单还是多个订单;</p>
<p>维度即为该订单有哪些的附属信息，比方说订单类型、支付方式、城市信心、日期信息等等;</p>
<p>事实是指具体的订单量的数值。</p>
<p>那么，我们可以假设，这个订单表的基础信息包括：</p>
<table>
<thead>
<tr>
<th align="left">编号</th>
<th align="left">字段</th>
</tr>
</thead>
<tbody><tr>
<td align="left">01</td>
<td align="left">订单ID</td>
</tr>
<tr>
<td align="left">02</td>
<td align="left">发货人ID</td>
</tr>
<tr>
<td align="left">03</td>
<td align="left">收件人ID</td>
</tr>
<tr>
<td align="left">04</td>
<td align="left">发货时间</td>
</tr>
<tr>
<td align="left">05</td>
<td align="left">发货地点</td>
</tr>
<tr>
<td align="left">06</td>
<td align="left">快递单号</td>
</tr>
<tr>
<td align="left">07</td>
<td align="left">物品件数</td>
</tr>
<tr>
<td align="left">08</td>
<td align="left">订单总金额</td>
</tr>
<tr>
<td align="left">09</td>
<td align="left">订单状态</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">下单时间</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">支付订单号</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">支付时间</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">支付状态</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">收货时间</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">收货状态</td>
</tr>
</tbody></table>
<p><strong>业务过程</strong>：用户购买商品的订单记录表<br><strong>申明粒度</strong>：每一条记录代表一个有效订单<br><strong>确认维度</strong>：商户维度、用户维度、支付维度、收货维度<br><strong>确认事实</strong>：订单总金额</p>
<p>通过对不同的维度进行统计组合，我们就会得到一个多维数据集，来从多角度观察我们的业务过程的好坏情况。</p>
<hr>
<p>参考：<a href="https://www.bilibili.com/video/BV1Z4411m7NV?p=6">https://www.bilibili.com/video/BV1Z4411m7NV?p=6</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>10道经典Hive题目</title>
    <url>/blog/f9fb.html</url>
    <content><![CDATA[<p>我有早起的习惯，每天早晨上班前的这段时间脑子非常清醒，这段时间我会用来充实自己。看到某个公众号发了一篇Hive的面试题的推文，顺手拿过来做了下。共计10道题，花了下班后的晚上和一个早晨的时间写完。</p>
<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们有如下的用户访问数据</span><br><span class="line">    userId  visitDate   visitCount</span><br><span class="line">    u01 2017/1/21   5</span><br><span class="line">    u02 2017/1/23   6</span><br><span class="line">    u03 2017/1/22   8</span><br><span class="line">    u04 2017/1/20   3</span><br><span class="line">    u01 2017/1/23   6</span><br><span class="line">    u01 2017/2/21   8</span><br><span class="line">    U02 2017/1/23   6</span><br><span class="line">    U01 2017/2/22   4</span><br><span class="line">要求使用SQL统计出每个用户的累积访问次数，如下表所示：</span><br><span class="line">    用户id    月份  小计  累积</span><br><span class="line">    u01 2017-01 11  11</span><br><span class="line">    u01 2017-02 12  23</span><br><span class="line">    u02 2017-01 12  12</span><br><span class="line">    u03 2017-01 8   8</span><br><span class="line">    u04 2017-01 3   3</span><br></pre></td></tr></table></figure>
<p>实现：<br>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test1 ( </span><br><span class="line">        userId string, </span><br><span class="line">        visitDate string,</span><br><span class="line">        visitCount <span class="type">INT</span> )</span><br><span class="line">    <span class="type">ROW</span> format delimited FIELDS TERMINATED <span class="keyword">BY</span> &quot;\t&quot;;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test1</span><br><span class="line">    <span class="keyword">VALUES</span></span><br><span class="line">        ( <span class="string">&#x27;u01&#x27;</span>, <span class="string">&#x27;2017/1/21&#x27;</span>, <span class="number">5</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u02&#x27;</span>, <span class="string">&#x27;2017/1/23&#x27;</span>, <span class="number">6</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u03&#x27;</span>, <span class="string">&#x27;2017/1/22&#x27;</span>, <span class="number">8</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u04&#x27;</span>, <span class="string">&#x27;2017/1/20&#x27;</span>, <span class="number">3</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u01&#x27;</span>, <span class="string">&#x27;2017/1/23&#x27;</span>, <span class="number">6</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u01&#x27;</span>, <span class="string">&#x27;2017/2/21&#x27;</span>, <span class="number">8</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u02&#x27;</span>, <span class="string">&#x27;2017/1/23&#x27;</span>, <span class="number">6</span> ),</span><br><span class="line">        ( <span class="string">&#x27;u01&#x27;</span>, <span class="string">&#x27;2017/2/22&#x27;</span>, <span class="number">4</span> );</span><br></pre></td></tr></table></figure>
<p>查询SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with t1 as(</span><br><span class="line">    select</span><br><span class="line">        userid,</span><br><span class="line">        date_format(regexp_replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;YYYY-MM&#x27;) as vdate,</span><br><span class="line">        sum(visitcount) as vcount</span><br><span class="line">    from prac.test1</span><br><span class="line">    group by userid,date_format(regexp_replace(visitdate,&#x27;/&#x27;,&#x27;-&#x27;),&#x27;YYYY-MM&#x27;)</span><br><span class="line">)</span><br><span class="line">select</span><br><span class="line">    userid,</span><br><span class="line">    vdate,</span><br><span class="line">    vcount,</span><br><span class="line">    sum(vcount) over (partition by userid order by vdate)</span><br><span class="line">from t1;</span><br></pre></td></tr></table></figure>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有50W个京东店铺，每个顾客访客访问任何一个店铺的任何一个商品时都会产生一条访问日志，</span><br><span class="line">访问日志存储的表名为Visit，访客的用户id为user_id，被访问的店铺名称为shop，数据如下：</span><br><span class="line"></span><br><span class="line">                u1  a</span><br><span class="line">                u2  b</span><br><span class="line">                u1  b</span><br><span class="line">                u1  a</span><br><span class="line">                u3  c</span><br><span class="line">                u4  b</span><br><span class="line">                u1  a</span><br><span class="line">                u2  c</span><br><span class="line">                u5  b</span><br><span class="line">                u4  b</span><br><span class="line">                u6  c</span><br><span class="line">                u2  c</span><br><span class="line">                u1  b</span><br><span class="line">                u2  a</span><br><span class="line">                u2  a</span><br><span class="line">                u3  a</span><br><span class="line">                u5  a</span><br><span class="line">                u5  a</span><br><span class="line">                u5  a</span><br><span class="line">请统计：</span><br><span class="line">(1)每个店铺的UV（访客数）</span><br><span class="line">(2)每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数</span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test2 ( </span><br><span class="line">    user_id string, </span><br><span class="line">    shop string </span><br><span class="line">)</span><br><span class="line"><span class="type">ROW</span> format delimited FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test2 <span class="keyword">VALUES</span></span><br><span class="line">( <span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u3&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u4&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u5&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u4&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u6&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;c&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u1&#x27;</span>, <span class="string">&#x27;b&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u2&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u3&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u5&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u5&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ),</span><br><span class="line">( <span class="string">&#x27;u5&#x27;</span>, <span class="string">&#x27;a&#x27;</span> ); </span><br></pre></td></tr></table></figure>

<p>查询SQL：<br>(1)每个店铺的UV（访客数）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    shop,</span><br><span class="line">    <span class="built_in">count</span>(<span class="keyword">distinct</span> user_id) <span class="keyword">as</span> user_cnt</span><br><span class="line"><span class="keyword">from</span> prac.test2</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> shop;</span><br></pre></td></tr></table></figure>
<p>(2)每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id,</span><br><span class="line">        <span class="built_in">count</span>(user_id) <span class="keyword">as</span> cnt</span><br><span class="line">    <span class="keyword">from</span> prac.test2</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> shop,user_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id,</span><br><span class="line">        cnt,</span><br><span class="line">        <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> shop <span class="keyword">order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span>) <span class="keyword">as</span> rk</span><br><span class="line">    <span class="keyword">from</span> t1</span><br><span class="line">) <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>需求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">已知一个表STG.ORDER，有如下字段:Date，Order_id，User_id，amount。</span><br><span class="line">数据样例:2017-01-01,10029028,1000003251,33.57。</span><br><span class="line">请给出sql进行统计:</span><br><span class="line">(1)给出 2017年每个月的订单数、用户数、总成交金额。</span><br><span class="line">(2)给出2017年11月的新客数(指在11月才有第一笔订单)</span><br></pre></td></tr></table></figure>
<p>数据准备:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test3 ( </span><br><span class="line">            dt string,</span><br><span class="line">            order_id string, </span><br><span class="line">            user_id string, </span><br><span class="line">            amount <span class="type">DECIMAL</span> ( <span class="number">10</span>, <span class="number">2</span> ) )</span><br><span class="line"><span class="type">ROW</span> format delimited FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-01-01&#x27;</span>,<span class="string">&#x27;10029028&#x27;</span>,<span class="string">&#x27;1000003251&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-01-01&#x27;</span>,<span class="string">&#x27;10029029&#x27;</span>,<span class="string">&#x27;1000003251&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-01-01&#x27;</span>,<span class="string">&#x27;100290288&#x27;</span>,<span class="string">&#x27;1000003252&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-02-02&#x27;</span>,<span class="string">&#x27;10029088&#x27;</span>,<span class="string">&#x27;1000003251&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-02-02&#x27;</span>,<span class="string">&#x27;100290281&#x27;</span>,<span class="string">&#x27;1000003251&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-02-02&#x27;</span>,<span class="string">&#x27;100290282&#x27;</span>,<span class="string">&#x27;1000003253&#x27;</span>,<span class="number">33.57</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2017-11-02&#x27;</span>,<span class="string">&#x27;10290282&#x27;</span>,<span class="string">&#x27;100003253&#x27;</span>,<span class="number">234</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test3 <span class="keyword">VALUES</span> (<span class="string">&#x27;2018-11-02&#x27;</span>,<span class="string">&#x27;10290284&#x27;</span>,<span class="string">&#x27;100003243&#x27;</span>,<span class="number">234</span>);</span><br></pre></td></tr></table></figure>

<p>查询SQL：<br>(1)给出 2017年每个月的订单数、用户数、总成交金额。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    date_format(dt,<span class="string">&#x27;YYYY-MM&#x27;</span>) <span class="keyword">as</span> mon,</span><br><span class="line">    <span class="built_in">count</span>(order_id) <span class="keyword">as</span> order_cnt,</span><br><span class="line">    <span class="built_in">count</span>(user_id) <span class="keyword">as</span> user_cnt,</span><br><span class="line">    <span class="built_in">sum</span>(amount) <span class="keyword">as</span> AMT</span><br><span class="line"><span class="keyword">from</span> prac.test3</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> date_format(dt,<span class="string">&#x27;YYYY-MM&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>(2)给出2017年11月的新客数(指在11月才有第一笔订单)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with t1 as(</span><br><span class="line">    select</span><br><span class="line">        user_id</span><br><span class="line">    from prac.test3</span><br><span class="line">    where dt&lt;to_date(&#x27;2017-11-01&#x27;)</span><br><span class="line">)</span><br><span class="line">select</span><br><span class="line">    date_format(dt,&#x27;YYYY-MM&#x27;),</span><br><span class="line">    count(1)</span><br><span class="line">from prac.test3</span><br><span class="line">where dt between &#x27;2017-11-01&#x27; and &#x27;2017-11-30&#x27;</span><br><span class="line"> and user_id not in (select t1.user_id from t1)</span><br><span class="line">group by date_format(dt,&#x27;YYYY-MM&#x27;)</span><br></pre></td></tr></table></figure>
<p>不得不说答案上的这个写法真的很巧妙:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(user_id)</span><br><span class="line"><span class="keyword">FROM</span> prac.test3</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> date_format(<span class="built_in">min</span>(dt),<span class="string">&#x27;yyyy-MM&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2017-11&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个5000万的用户文件(user_id，name，age)，一个2亿记录的用户看电影的记录文件(user_id，url)，根据年龄段观看电影的次数进行排序？        </span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test4user</span><br><span class="line">           (user_id string,</span><br><span class="line">            name string,</span><br><span class="line">            age <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test4log</span><br><span class="line">                        (user_id string,</span><br><span class="line">                        url string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test4user <span class="keyword">VALUES</span></span><br><span class="line"> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;u1&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">,(<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;u2&#x27;</span>,<span class="number">15</span>)</span><br><span class="line">,(<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;u3&#x27;</span>,<span class="number">15</span>)  </span><br><span class="line">,(<span class="string">&#x27;004&#x27;</span>,<span class="string">&#x27;u4&#x27;</span>,<span class="number">20</span>) </span><br><span class="line">,(<span class="string">&#x27;005&#x27;</span>,<span class="string">&#x27;u5&#x27;</span>,<span class="number">25</span>)</span><br><span class="line">,(<span class="string">&#x27;006&#x27;</span>,<span class="string">&#x27;u6&#x27;</span>,<span class="number">35</span>) </span><br><span class="line">,(<span class="string">&#x27;007&#x27;</span>,<span class="string">&#x27;u7&#x27;</span>,<span class="number">40</span>)</span><br><span class="line">,(<span class="string">&#x27;008&#x27;</span>,<span class="string">&#x27;u8&#x27;</span>,<span class="number">45</span>)</span><br><span class="line">,(<span class="string">&#x27;009&#x27;</span>,<span class="string">&#x27;u9&#x27;</span>,<span class="number">50</span>)</span><br><span class="line">,(<span class="string">&#x27;0010&#x27;</span>,<span class="string">&#x27;u10&#x27;</span>,<span class="number">65</span>);  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test4log <span class="keyword">VALUES</span></span><br><span class="line"> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;url1&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;url1&#x27;</span>)  </span><br><span class="line">,(<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;url2&#x27;</span>)  </span><br><span class="line">,(<span class="string">&#x27;004&#x27;</span>,<span class="string">&#x27;url3&#x27;</span>)  </span><br><span class="line">,(<span class="string">&#x27;005&#x27;</span>,<span class="string">&#x27;url3&#x27;</span>)  </span><br><span class="line">,(<span class="string">&#x27;006&#x27;</span>,<span class="string">&#x27;url1&#x27;</span>)  </span><br><span class="line">,(<span class="string">&#x27;007&#x27;</span>,<span class="string">&#x27;url5&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;008&#x27;</span>,<span class="string">&#x27;url7&#x27;</span>) </span><br><span class="line">,(<span class="string">&#x27;009&#x27;</span>,<span class="string">&#x27;url5&#x27;</span>) </span><br><span class="line">,(<span class="string">&#x27;0010&#x27;</span>,<span class="string">&#x27;url1&#x27;</span>); </span><br></pre></td></tr></table></figure>
<p>查询SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        user_id,</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> move_cnt</span><br><span class="line">    <span class="keyword">from</span> prac.test4log</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> user_id</span><br><span class="line">),t2 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        user_id,</span><br><span class="line">        name,</span><br><span class="line">        (<span class="keyword">case</span> <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">0</span>  <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">then</span> <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">20</span> <span class="keyword">then</span> <span class="string">&#x27;10-19&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;20-29&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">40</span> <span class="keyword">then</span> <span class="string">&#x27;30-39&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">40</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">50</span> <span class="keyword">then</span> <span class="string">&#x27;40-49&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">50</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;50-59&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">70</span> <span class="keyword">then</span> <span class="string">&#x27;60-69&#x27;</span></span><br><span class="line">              <span class="keyword">when</span> age<span class="operator">&gt;=</span><span class="number">70</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">80</span> <span class="keyword">then</span> <span class="string">&#x27;70-79&#x27;</span></span><br><span class="line">       <span class="keyword">else</span> <span class="string">&#x27;80及以上&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> age_peroid</span><br><span class="line">    <span class="keyword">from</span> prac.test4user</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    t2.age_peroid,</span><br><span class="line">    <span class="built_in">sum</span>(t1.move_cnt)</span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">join</span> t2</span><br><span class="line">  <span class="keyword">on</span> t1.user_id<span class="operator">=</span>t2.user_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> age_peroid;</span><br></pre></td></tr></table></figure>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有日志如下，请写出代码求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）</span><br><span class="line">日期 用户 年龄</span><br><span class="line">2019-02-11,test_1,23</span><br><span class="line">2019-02-11,test_2,19</span><br><span class="line">2019-02-11,test_3,39</span><br><span class="line">2019-02-11,test_1,23</span><br><span class="line">2019-02-11,test_3,39</span><br><span class="line">2019-02-11,test_1,23</span><br><span class="line">2019-02-12,test_2,19</span><br><span class="line">2019-02-13,test_1,23</span><br><span class="line">2019-02-15,test_2,19</span><br><span class="line">2019-02-16,test_2,19</span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test5(</span><br><span class="line">dt string,</span><br><span class="line">user_id string,</span><br><span class="line">age <span class="type">int</span>)</span><br><span class="line"><span class="type">ROW</span> format delimited fields terminated <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test5 <span class="keyword">VALUES</span> </span><br><span class="line"> (<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_1&#x27;</span>,<span class="number">23</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_2&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_3&#x27;</span>,<span class="number">39</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_1&#x27;</span>,<span class="number">23</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_3&#x27;</span>,<span class="number">39</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-11&#x27;</span>,<span class="string">&#x27;test_1&#x27;</span>,<span class="number">23</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-12&#x27;</span>,<span class="string">&#x27;test_2&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-13&#x27;</span>,<span class="string">&#x27;test_1&#x27;</span>,<span class="number">23</span>)</span><br><span class="line">,(<span class="string">&#x27;2019-02-15&#x27;</span>,<span class="string">&#x27;test_2&#x27;</span>,<span class="number">19</span>)                                  </span><br><span class="line">,(<span class="string">&#x27;2019-02-16&#x27;</span>,<span class="string">&#x27;test_2&#x27;</span>,<span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p>查询SQL：<br>求得所有用户和活跃用户的总数及平均年龄。（活跃用户指连续两天都有访问记录的用户）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt_all,</span><br><span class="line">        <span class="built_in">avg</span>(age) <span class="keyword">as</span> avg_all</span><br><span class="line">    <span class="keyword">from</span>( </span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            user_id,</span><br><span class="line">            age</span><br><span class="line">        <span class="keyword">from</span> prac.test5</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> user_id,age</span><br><span class="line">    )</span><br><span class="line">),t2 <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    t4.user_id,</span><br><span class="line">    t4.age</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        t3.user_id,</span><br><span class="line">        t3.age</span><br><span class="line">    <span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            dt,</span><br><span class="line">            user_id,</span><br><span class="line">            age,</span><br><span class="line">            rk,</span><br><span class="line">            date_sub(dt,rk) <span class="keyword">as</span> flag</span><br><span class="line">        <span class="keyword">from</span> (</span><br><span class="line">            <span class="keyword">select</span></span><br><span class="line">                t0.dt,</span><br><span class="line">                t0.user_id,</span><br><span class="line">                t0.age,</span><br><span class="line">                <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> t1.user_id <span class="keyword">order</span> <span class="keyword">by</span> t1.dt) <span class="keyword">as</span> rk</span><br><span class="line">            <span class="keyword">from</span>(</span><br><span class="line">                <span class="keyword">select</span></span><br><span class="line">                    dt,</span><br><span class="line">                    user_id,</span><br><span class="line">                    age</span><br><span class="line">                <span class="keyword">from</span> prac.test5</span><br><span class="line">                <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">                    dt,</span><br><span class="line">                    user_id,</span><br><span class="line">                    age</span><br><span class="line">            ) <span class="keyword">as</span> t0 <span class="comment">-- 对用户访问表去重</span></span><br><span class="line">        )</span><br><span class="line">    ) <span class="keyword">as</span> t3</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">        t3.user_id,</span><br><span class="line">        t3.age,</span><br><span class="line">        t3.flag</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="number">1</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br><span class="line">) <span class="keyword">as</span> t4</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">    t4.user_id,</span><br><span class="line">    t4.age</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	<span class="built_in">count</span>(t2.user_id),</span><br><span class="line">	<span class="built_in">avg</span>(t2.age)</span><br><span class="line"><span class="keyword">from</span> t2</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	cnt_all,</span><br><span class="line">	avg_all</span><br><span class="line"><span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure>
<p>这道题比较复杂，难度在于如何求活跃用户，首先对用户活跃日志进行去重，每个用户每天只保留一条，然后对其按照用户分组，按照日期升序，使用row_number对其打上序号rk。<br>不难看出，如果是连续登录，那么日期dt和序号会是一个等差数列，故用登陆日期dt和序号做差，得到新的日期起别名flag。然后按照user_id和flag进行分组，如果一个分组内的数据量大于等于2，就说明这位用户是活跃用户。得到活跃用户，再一次进行去重操作，因为同一用户可能多次活跃，被判定为多次活跃用户。得到活跃用户再求他们的数量和平均年龄就比较简单了。</p>
<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请用sql写出所有用户中在今年10月份第一次购买商品的金额，</span><br><span class="line">表ordertable字段:</span><br><span class="line">(购买用户：userid，金额：money，购买时间：paymenttime(格式：2017-10-01)，订单id：orderid           </span><br></pre></td></tr></table></figure>
<p>数据准备:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test6 (</span><br><span class="line">        userid string,</span><br><span class="line">        money <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">        paymenttime string,</span><br><span class="line">        orderid string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test6 <span class="keyword">VALUES</span></span><br><span class="line"> (<span class="string">&#x27;001&#x27;</span>,<span class="number">100</span>,<span class="string">&#x27;2017-10-01&#x27;</span>,<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;001&#x27;</span>,<span class="number">200</span>,<span class="string">&#x27;2017-10-02&#x27;</span>,<span class="string">&#x27;124&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;002&#x27;</span>,<span class="number">500</span>,<span class="string">&#x27;2017-10-01&#x27;</span>,<span class="string">&#x27;125&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;001&#x27;</span>,<span class="number">100</span>,<span class="string">&#x27;2017-11-01&#x27;</span>,<span class="string">&#x27;126&#x27;</span>);    </span><br></pre></td></tr></table></figure>
<p>查询SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    userid,</span><br><span class="line">    money,</span><br><span class="line">    <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> paymenttime) rk</span><br><span class="line"><span class="keyword">from</span> prac.test6</span><br><span class="line"><span class="keyword">where</span> paymenttime<span class="operator">&gt;=</span><span class="string">&#x27;2017-10-01&#x27;</span> <span class="keyword">and</span> paymenttime<span class="operator">&lt;=</span><span class="string">&#x27;2017-10-31&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    userid,</span><br><span class="line">    money</span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现有图书管理数据库的三个数据模型如下：</span><br><span class="line">图书（数据表名：BOOK）</span><br><span class="line">    序号      字段名称    字段描述    字段类型</span><br><span class="line">    1       BOOK_ID     总编号         文本</span><br><span class="line">    2       SORT        分类号         文本</span><br><span class="line">    3       BOOK_NAME   书名          文本</span><br><span class="line">    4       WRITER      作者          文本</span><br><span class="line">    5       OUTPUT      出版单位    文本</span><br><span class="line">    6       PRICE       单价          数值（保留小数点后2位）</span><br><span class="line">读者（数据表名：READER）</span><br><span class="line">    序号      字段名称    字段描述    字段类型</span><br><span class="line">    1       READER_ID   借书证号    文本</span><br><span class="line">    2       COMPANY     单位          文本</span><br><span class="line">    3       NAME        姓名          文本</span><br><span class="line">    4       SEX         性别          文本</span><br><span class="line">    5       GRADE       职称          文本</span><br><span class="line">    6       ADDR        地址          文本</span><br><span class="line">借阅记录（数据表名：BORROW LOG）</span><br><span class="line">    序号      字段名称        字段描述    字段类型</span><br><span class="line">    1       READER_ID       借书证号    文本</span><br><span class="line">    2       BOOK_ID         总编号         文本</span><br><span class="line">    3       BORROW_DATE     借书日期    日期</span><br><span class="line">（1）创建图书管理库的图书、读者和借阅三个基本表的表结构。请写出建表语句。</span><br><span class="line">（2）找出姓李的读者姓名（NAME）和所在单位（COMPANY）。</span><br><span class="line">（3）查找“高等教育出版社”的所有图书名称（BOOK_NAME）及单价（PRICE），结果按单价降序排序。</span><br><span class="line">（4）查找价格介于10元和20元之间的图书种类(SORT）出版单位（OUTPUT）和单价（PRICE），结果按出版单位（OUTPUT）和单价（PRICE）升序排序。</span><br><span class="line">（5）查找所有借了书的读者的姓名（NAME）及所在单位（COMPANY）。</span><br><span class="line">（6）求”科学出版社”图书的最高单价、最低单价、平均单价。</span><br><span class="line">（7）找出当前至少借阅了2本图书（大于等于2本）的读者姓名及其所在单位。</span><br><span class="line">（8）考虑到数据安全的需要，需定时将“借阅记录”中数据进行备份，请使用一条SQL语句，在备份用户bak下创建与“借阅记录”表结构完全一致的数据表BORROW_LOG_BAK.井且将“借阅记录”中现有数据全部复制到BORROW_L0G_ BAK中。</span><br><span class="line">（9）现在需要将原Oracle数据库中数据迁移至Hive仓库，请写出“图书”在Hive中的建表语句（Hive实现，提示：列分隔符|；数据表数据需要外部导入：分区分别以month＿part、day＿part 命名）</span><br><span class="line">（10）Hive中有表A，现在需要将表A的月分区　201505　中　user＿id为20000的user＿dinner字段更新为bonc8920，其他用户user＿dinner字段数据不变，请列出更新的方法步骤。（Hive实现，提示：Hlive中无update语法，请通过其他办法进行数据更新）</span><br></pre></td></tr></table></figure>
<p>(1)数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.book(book_id string,</span><br><span class="line">                           `SORT` string,</span><br><span class="line">                           book_name string,</span><br><span class="line">                           writer string,</span><br><span class="line">                           OUTPUT string,</span><br><span class="line">                           price <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;TP391&#x27;</span>,<span class="string">&#x27;信息处理&#x27;</span>,<span class="string">&#x27;author1&#x27;</span>,<span class="string">&#x27;机械工业出版社&#x27;</span>,<span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;TP392&#x27;</span>,<span class="string">&#x27;数据库&#x27;</span>,<span class="string">&#x27;author12&#x27;</span>,<span class="string">&#x27;科学出版社&#x27;</span>,<span class="string">&#x27;15&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;TP393&#x27;</span>,<span class="string">&#x27;计算机网络&#x27;</span>,<span class="string">&#x27;author3&#x27;</span>,<span class="string">&#x27;机械工业出版社&#x27;</span>,<span class="string">&#x27;29&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;004&#x27;</span>,<span class="string">&#x27;TP399&#x27;</span>,<span class="string">&#x27;微机原理&#x27;</span>,<span class="string">&#x27;author4&#x27;</span>,<span class="string">&#x27;科学出版社&#x27;</span>,<span class="string">&#x27;39&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;005&#x27;</span>,<span class="string">&#x27;C931&#x27;</span>,<span class="string">&#x27;管理信息系统&#x27;</span>,<span class="string">&#x27;author5&#x27;</span>,<span class="string">&#x27;机械工业出版社&#x27;</span>,<span class="string">&#x27;40&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.book <span class="keyword">VALUES</span> (<span class="string">&#x27;006&#x27;</span>,<span class="string">&#x27;C932&#x27;</span>,<span class="string">&#x27;运筹学&#x27;</span>,<span class="string">&#x27;author6&#x27;</span>,<span class="string">&#x27;科学出版社&#x27;</span>,<span class="string">&#x27;55&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建读者表reader</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.reader (reader_id string,</span><br><span class="line">                              company string,</span><br><span class="line">                              name string,</span><br><span class="line">                              sex string,</span><br><span class="line">                              grade string,</span><br><span class="line">                              addr string);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;vp&#x27;</span>,<span class="string">&#x27;addr1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0002&#x27;</span>,<span class="string">&#x27;百度&#x27;</span>,<span class="string">&#x27;robin&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;vp&#x27;</span>,<span class="string">&#x27;addr2&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0003&#x27;</span>,<span class="string">&#x27;腾讯&#x27;</span>,<span class="string">&#x27;tony&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;vp&#x27;</span>,<span class="string">&#x27;addr3&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0004&#x27;</span>,<span class="string">&#x27;京东&#x27;</span>,<span class="string">&#x27;jasper&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;cfo&#x27;</span>,<span class="string">&#x27;addr4&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0005&#x27;</span>,<span class="string">&#x27;网易&#x27;</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;ceo&#x27;</span>,<span class="string">&#x27;addr5&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.reader <span class="keyword">VALUES</span> (<span class="string">&#x27;0006&#x27;</span>,<span class="string">&#x27;搜狐&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;ceo&#x27;</span>,<span class="string">&#x27;addr6&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建借阅记录表borrow_log</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.borrow_log(reader_id string,</span><br><span class="line">                                 book_id string,</span><br><span class="line">                                 borrow_date string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0001&#x27;</span>,<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;2019-10-14&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0002&#x27;</span>,<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;2019-10-13&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0003&#x27;</span>,<span class="string">&#x27;005&#x27;</span>,<span class="string">&#x27;2019-09-14&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0004&#x27;</span>,<span class="string">&#x27;006&#x27;</span>,<span class="string">&#x27;2019-08-15&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0005&#x27;</span>,<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;2019-10-10&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.borrow_log <span class="keyword">VALUES</span> (<span class="string">&#x27;0006&#x27;</span>,<span class="string">&#x27;004&#x27;</span>,<span class="string">&#x27;2019-17-13&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>(2)找出姓李的读者姓名（NAME）和所在单位（COMPANY）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    name,</span><br><span class="line">    company</span><br><span class="line"><span class="keyword">from</span> prac.reader</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;li%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>(3)查找“高等教育出版社”的所有图书名称（BOOK_NAME）及单价（PRICE），结果按单价降序排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    book_name,</span><br><span class="line">    price</span><br><span class="line"><span class="keyword">from</span> prac.book</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>(4)查找价格介于10元和20元之间的图书种类(SORT）出版单位（OUTPUT）和单价（PRICE），结果按出版单位（OUTPUT）和单价（PRICE）升序排序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    sort,</span><br><span class="line">    output,</span><br><span class="line">    price</span><br><span class="line"><span class="keyword">from</span> prac.book</span><br><span class="line"><span class="keyword">where</span> price<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> price<span class="operator">&lt;=</span><span class="number">20</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> output,price;</span><br></pre></td></tr></table></figure>
<p>(5)查找所有借了书的读者的姓名（NAME）及所在单位（COMPANY）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    b.name,</span><br><span class="line">    b.company</span><br><span class="line"><span class="keyword">from</span> borrow_log <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reader <span class="keyword">as</span> b</span><br><span class="line">       <span class="keyword">on</span> a.reader_id<span class="operator">=</span>b.reader_id</span><br></pre></td></tr></table></figure>
<p>(6)求科学出版社图书的最高单价、最低单价、平均单价。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="built_in">max</span>(price),</span><br><span class="line">    <span class="built_in">min</span>(price),</span><br><span class="line">    <span class="built_in">avg</span>(price)</span><br><span class="line"><span class="keyword">from</span> prac.book</span><br><span class="line"><span class="keyword">where</span> output<span class="operator">=</span><span class="string">&#x27;科学出版社&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>(7)找出当前至少借阅了2本图书（大于等于2本）的读者姓名及其所在单位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        reader_id,</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line">    <span class="keyword">from</span> borrow_log</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> reader_id</span><br><span class="line">    <span class="keyword">having</span> cnt<span class="operator">&gt;=</span><span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    t2.name,</span><br><span class="line">    t2.company</span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reader <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.reader_id<span class="operator">=</span>t2.reader_id;</span><br></pre></td></tr></table></figure>
<p>(8)考虑到数据安全的需要，需定时将“借阅记录”中数据进行备份，请使用一条SQL语句，<br>在备份用户bak下创建与“借阅记录”表结构完全一致的数据表BORROW_LOG_BAK.井且将“借阅记录”中现有数据全部复制到BORROW_L0G_ BAK中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.borrow_log_bak <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> prac.borrow_log;</span><br></pre></td></tr></table></figure>
<p>(9)现在需要将原Oracle数据库中数据迁移至Hive仓库，请写出“图书”在Hive中的建表语句（Hive实现，提示：列分隔符|；数据表数据需要外部导入：分区分别以month＿part、day＿part 命名）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> book2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> book2(</span><br><span class="line"> BOOK_ID     STRING    COMMENT    <span class="string">&#x27;总编号&#x27;</span></span><br><span class="line">,SORT        STRING    COMMENT    <span class="string">&#x27;分类号&#x27;</span></span><br><span class="line">,BOOK_NAME   STRING    COMMENT    <span class="string">&#x27;书名&#x27;</span></span><br><span class="line">,WRITER      STRING    COMMENT    <span class="string">&#x27;作者&#x27;</span></span><br><span class="line">,OUTPUT      STRING    COMMENT    <span class="string">&#x27;出版单位&#x27;</span></span><br><span class="line">,PRICE       STRING    COMMENT    <span class="string">&#x27;单价&#x27;</span></span><br><span class="line">)COMMENT <span class="string">&#x27;图书表&#x27;</span></span><br><span class="line">partitioned <span class="keyword">by</span>(month_part string COMMENT <span class="string">&#x27;月分区&#x27;</span>,day_part string COMMENT <span class="string">&#x27;日分区&#x27;</span>)</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;|&#x27;</span> stored <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure>
<p>(10)Hive中有表A，现在需要将表A的月分区 201505 中 user_id为20000的user_dinner字段更新为bonc8920，其他用户user_dinner字段数据不变，请列出更新的方法步骤。</p>
<ul>
<li>1.新建临时表写入更改过的数据</li>
<li>2.把临时表数据写回原分区</li>
</ul>
<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个线上服务器访问日志格式如下（用sql答题）</span><br><span class="line">时间                    接口                         ip地址</span><br><span class="line">2016-11-09 14:22:05        /api/user/login             110.23.5.33</span><br><span class="line">2016-11-09 14:23:10        /api/user/detail            57.3.2.16</span><br><span class="line">2016-11-09 15:59:40        /api/user/login             200.6.5.166</span><br><span class="line">… …</span><br><span class="line">求11月9号下午14点（14-15点），访问/api/user/login接口的top10的ip地址       </span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test8(`<span class="type">date</span>` string,</span><br><span class="line">                interface string,</span><br><span class="line">                ip string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test8 <span class="keyword">VALUES</span> </span><br><span class="line"> (<span class="string">&#x27;2016-11-09 11:22:05&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;110.23.5.23&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 11:23:10&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;57.3.2.16&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 23:59:40&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;200.6.5.166&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 11:14:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;136.79.47.70&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 11:15:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;94.144.143.141&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 11:16:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;197.161.8.206&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 12:14:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;240.227.107.145&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 13:14:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;79.130.122.205&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:14:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;65.228.251.189&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:15:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;245.23.122.44&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:17:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;22.74.142.137&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:19:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;54.93.212.87&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:20:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;218.15.167.248&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:24:23&#x27;</span>,<span class="string">&#x27;/api/user/detail&#x27;</span>,<span class="string">&#x27;20.117.19.75&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 15:14:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;183.162.66.97&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 16:14:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;108.181.245.147&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:17:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;22.74.142.137&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2016-11-09 14:19:23&#x27;</span>,<span class="string">&#x27;/api/user/login&#x27;</span>,<span class="string">&#x27;22.74.142.137&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>查询SQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        date_format(`<span class="type">date</span>`,<span class="string">&#x27;YYYY-MM-dd HH&#x27;</span>) <span class="keyword">as</span> dt,</span><br><span class="line">        ip,</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line">    <span class="keyword">from</span> test8</span><br><span class="line">    <span class="keyword">where</span> date_format(`<span class="type">date</span>`,<span class="string">&#x27;YYYY-MM-dd HH&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2016-11-09 14&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> date_format(`<span class="type">date</span>`,<span class="string">&#x27;YYYY-MM-dd HH&#x27;</span>),ip</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    dt,</span><br><span class="line">    ip,</span><br><span class="line">    rk</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        dt,</span><br><span class="line">        ip,</span><br><span class="line">        <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span>) <span class="keyword">as</span> rk</span><br><span class="line">    <span class="keyword">from</span> t1</span><br><span class="line">) <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">&lt;=</span><span class="number">10</span>;    </span><br></pre></td></tr></table></figure>
<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个充值日志表credit_log，字段如下：</span><br><span class="line">`dist_id` int  &#x27;区组id&#x27;,</span><br><span class="line">`account` string  &#x27;账号&#x27;,</span><br><span class="line">`money` int   &#x27;充值金额&#x27;,</span><br><span class="line">`create_time` string  &#x27;订单时间&#x27;</span><br><span class="line"></span><br><span class="line">请写出SQL语句，查询充值日志表2019年01月02号每个区组下充值额最大的账号，要求结果：</span><br><span class="line">区组id，账号，金额，充值时间      </span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test9(</span><br><span class="line">            dist_id string COMMENT <span class="string">&#x27;区组id&#x27;</span>,</span><br><span class="line">            account string COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">           `money` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;充值金额&#x27;</span>,</span><br><span class="line">            create_time string COMMENT <span class="string">&#x27;订单时间&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test9 <span class="keyword">VALUES</span> </span><br><span class="line"> (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;11&#x27;</span>,<span class="number">100006</span>,<span class="string">&#x27;2019-01-02 13:00:01&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;22&#x27;</span>,<span class="number">110000</span>,<span class="string">&#x27;2019-01-02 13:00:02&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;33&#x27;</span>,<span class="number">102000</span>,<span class="string">&#x27;2019-01-02 13:00:03&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;44&#x27;</span>,<span class="number">100300</span>,<span class="string">&#x27;2019-01-02 13:00:04&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;55&#x27;</span>,<span class="number">100040</span>,<span class="string">&#x27;2019-01-02 13:00:05&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;66&#x27;</span>,<span class="number">100005</span>,<span class="string">&#x27;2019-01-02 13:00:06&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;77&#x27;</span>,<span class="number">180000</span>,<span class="string">&#x27;2019-01-03 13:00:07&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;88&#x27;</span>,<span class="number">106000</span>,<span class="string">&#x27;2019-01-02 13:00:08&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;99&#x27;</span>,<span class="number">100400</span>,<span class="string">&#x27;2019-01-02 13:00:09&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="number">100030</span>,<span class="string">&#x27;2019-01-02 13:00:10&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="number">100003</span>,<span class="string">&#x27;2019-01-02 13:00:20&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;14&#x27;</span>,<span class="number">100020</span>,<span class="string">&#x27;2019-01-02 13:00:30&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="number">100500</span>,<span class="string">&#x27;2019-01-02 13:00:40&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;16&#x27;</span>,<span class="number">106000</span>,<span class="string">&#x27;2019-01-02 13:00:50&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="number">100800</span>,<span class="string">&#x27;2019-01-02 13:00:59&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="number">100800</span>,<span class="string">&#x27;2019-01-02 13:00:11&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="number">100030</span>,<span class="string">&#x27;2019-01-02 13:00:12&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="number">100000</span>,<span class="string">&#x27;2019-01-02 13:00:13&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;45&#x27;</span>,<span class="number">100010</span>,<span class="string">&#x27;2019-01-02 13:00:14&#x27;</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;78&#x27;</span>,<span class="number">100070</span>,<span class="string">&#x27;2019-01-02 13:00:15&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>查询SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        dist_id,</span><br><span class="line">        account,</span><br><span class="line">        <span class="built_in">sum</span>(money) <span class="keyword">as</span> sum_m</span><br><span class="line">    <span class="keyword">from</span> prac.test9</span><br><span class="line">    <span class="keyword">where</span> date_format(create_time,<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)<span class="operator">=</span><span class="string">&#x27;2019-01-02&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">        dist_id,</span><br><span class="line">        account</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    t2.dist_id,</span><br><span class="line">    t2.account,</span><br><span class="line">    t2.sum_m,</span><br><span class="line">    <span class="string">&#x27;2019-01-02&#x27;</span></span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            t1.dist_id,</span><br><span class="line">            t1.account,</span><br><span class="line">            t1.sum_m,</span><br><span class="line">            <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> t1.dist_id <span class="keyword">order</span> <span class="keyword">by</span> sum_m <span class="keyword">desc</span>) <span class="keyword">as</span> rk</span><br><span class="line">        <span class="keyword">from</span> t1</span><br><span class="line">    ) <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> prac.test10(</span><br><span class="line">    `dist_id` string COMMENT <span class="string">&#x27;区组id&#x27;</span>,</span><br><span class="line">    `account` string COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">    `gold` <span class="type">int</span> COMMENT <span class="string">&#x27;金币&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="第十题："><a href="#第十题：" class="headerlink" title="第十题："></a>第十题：</h2><p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个账号表如下，请写出SQL语句，查询各自区组的money排名前十的账号（分组取前10）</span><br><span class="line">dist_id string  &#x27;区组id&#x27;,</span><br><span class="line">account string  &#x27;账号&#x27;,</span><br><span class="line">gold     int    &#x27;金币&#x27;  </span><br></pre></td></tr></table></figure>
<p>数据准备：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> prac.test10 <span class="keyword">VALUES</span> </span><br><span class="line"> (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;77&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;88&#x27;</span>,<span class="number">106</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;99&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="number">13</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;13&#x27;</span>,<span class="number">14</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;14&#x27;</span>,<span class="number">25</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;15&#x27;</span>,<span class="number">36</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;16&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">,(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;17&#x27;</span>,<span class="number">158</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;19&#x27;</span>,<span class="number">44</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;10&#x27;</span>,<span class="number">66</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;45&#x27;</span>,<span class="number">80</span>)</span><br><span class="line">,(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;78&#x27;</span>,<span class="number">98</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test10;</span><br></pre></td></tr></table></figure>
<p>查询SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询各自区组的money排名前十的账号（分组取前10）</span></span><br><span class="line"><span class="keyword">with</span> t1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        dist_id,</span><br><span class="line">        account,</span><br><span class="line">        gold,</span><br><span class="line">        <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dist_id <span class="keyword">order</span> <span class="keyword">by</span> gold <span class="keyword">desc</span>) <span class="keyword">as</span> rk</span><br><span class="line">    <span class="keyword">from</span> prac.test10</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.dist_id,</span><br><span class="line">    t1.account,</span><br><span class="line">    t1.gold,</span><br><span class="line">    t1.rk</span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">where</span> rk<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这10道题并不难，和工作中的HiveSQL相比真的不算什么了，日拱一卒。加油！</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>Hive的UDTF函数</title>
    <url>/blog/6be3.html</url>
    <content><![CDATA[<p>在一些应用场景中，需要对一个字段进行分割，形成多个字段，比如日志信息使用#号连接字段，那么在导入数据仓库的时候，使用UDTF函数就显得比较方便和得心应手了。<br>在Hive的官网上，可以看到最UDTF的介绍是这样的：</p>
<blockquote>
<h3 id="GenericUDTF-Interface"><a href="#GenericUDTF-Interface" class="headerlink" title="GenericUDTF Interface"></a>GenericUDTF Interface</h3><p>A custom UDTF can be created by extending the GenericUDTF abstract class and then implementing the initialize, process, and possibly close methods. The initialize method is called by Hive to notify the UDTF the argument types to expect. The UDTF must then return an object inspector corresponding to the row objects that the UDTF will generate. Once initialize() has been called, Hive will give rows to the UDTF using the process() method. While in process(), the UDTF can produce and forward rows to other operators by calling forward(). Lastly, Hive will call the close() method when all the rows have passed to the UDTF.</p>
</blockquote>
<p>那么自定义UDTF函数需要继承<code>GenericUDTF</code> 抽象方法，实现<code>initialize</code>，<code>process</code>，<code>close</code> 这三个方法。</p>
<p>其中<code>initialize</code>方法中声明了Hive中需要的参数类型。</p>
<p><code>process</code>方法中进行我们所期望的操作，并调用<code>forward</code>方法把内容写到hive对应的行中。</p>
<p>当所有的行都写完后，会执行<code>close</code>方法。</p>
<p>下面代码实现了输入一个String类型的字符串，输入分隔符。会按照分隔符分割，之后把内容进行输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive.udtf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplodUDTF</span> <span class="keyword">extends</span> <span class="title class_">GenericUDTF</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; outList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StructObjectInspector <span class="title function_">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.定义输出数据的列名和类型</span></span><br><span class="line">        List&lt;String&gt; fieldNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加输出数据的列名和类型</span></span><br><span class="line">        fieldNames.add(<span class="string">&quot;lineToWord&quot;</span>);</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取原始数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">arg</span> <span class="operator">=</span> args[<span class="number">0</span>].toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取数据传入的第二个参数，此处为分隔符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">splitKey</span> <span class="operator">=</span> args[<span class="number">1</span>].toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.将原始数据按照传入的分隔符进行切分</span></span><br><span class="line">        String[] fields = arg.split(splitKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.遍历切分后的结果，并写出</span></span><br><span class="line">        <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//集合为复用的，首先清空集合</span></span><br><span class="line">            outList.clear();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每一个单词添加至集合</span></span><br><span class="line">            outList.add(field);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将集合内容写出</span></span><br><span class="line">            forward(outList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打好jar包并放到对应目录后，创建函数，尝试执行一句简单的，可以看到<code>1001#Jack#18#1999-01-02#Male</code>已经被按照期望的形式分割出来。其中<code>linetoword</code>是在UDTF函数中定义的列名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; create <span class="keyword">function</span> mp_explod as <span class="string">&quot;tech.mapan.hive.udtf.ExplodUDTF&quot;</span>;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.03 seconds</span><br><span class="line"></span><br><span class="line">hive (default)&gt; select mp_explod(<span class="string">&#x27;1001#Jack#18#1999-01-02#Male&#x27;</span>,<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">OK</span><br><span class="line">linetoword</span><br><span class="line">1001</span><br><span class="line">Jack</span><br><span class="line">18</span><br><span class="line">1999-01-02</span><br><span class="line">Male</span><br><span class="line">Time taken: 12.29 seconds, Fetched: 5 row(s)</span><br></pre></td></tr></table></figure>

<p>实际上，UDF还有一种更直接的使用方法，可以直接把一个字段变成两个字段（或多个字段）输出，但这样的写法比较相对比较固定。其实在<code>initialize</code>方法里只需要多定义一个（或多个）字段即可，输出时，会自动按顺序填充到对应的字段位置上。写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive.udtf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDFArgumentException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.metadata.HiveException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.udf.generic.GenericUDTF;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.StructObjectInspector;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: udtf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDTF函数,分割成两个字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 22:40</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExplodUDTF2</span> <span class="keyword">extends</span> <span class="title class_">GenericUDTF</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; outList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StructObjectInspector <span class="title function_">initialize</span><span class="params">(StructObjectInspector argOIs)</span> <span class="keyword">throws</span> UDFArgumentException &#123;</span><br><span class="line">        <span class="comment">// 1.定义输出数据的列名和类型</span></span><br><span class="line">        List&lt;String&gt; fieldNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.添加输出数据的列名</span></span><br><span class="line">        fieldNames.add(<span class="string">&quot;word1&quot;</span>);</span><br><span class="line">        fieldNames.add(<span class="string">&quot;word2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.定义输出数据的类型</span></span><br><span class="line">        List&lt;ObjectInspector&gt; fieldOIs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line">        fieldOIs.add(PrimitiveObjectInspectorFactory.javaStringObjectInspector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOIs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Object[] args)</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line">        <span class="comment">//1.获取原始数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">arg</span> <span class="operator">=</span> args[<span class="number">0</span>].toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取数据传入的第二个参数，此处为分隔符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">splitKey</span> <span class="operator">=</span> args[<span class="number">1</span>].toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.将原始数据按照传入的分隔符进行切分</span></span><br><span class="line">        String[] fields = arg.split(splitKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.遍历切分后的结果，并写出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//集合为复用的，首先清空集合</span></span><br><span class="line">        outList.clear();</span><br><span class="line">        outList.add(fields[<span class="number">0</span>]);</span><br><span class="line">        outList.add(fields[<span class="number">1</span>]);</span><br><span class="line">        forward(outList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> HiveException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行效果如下，这样就把一个字段直接拆成了两个字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create <span class="keyword">function</span> mp_explod as <span class="string">&quot;tech.mapan.hive.udtf.ExplodUDTF2&quot;</span>;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.029 seconds</span><br><span class="line"></span><br><span class="line">hive (prac)&gt; select * from test03;</span><br><span class="line">OK</span><br><span class="line">test03.id	test03.name</span><br><span class="line">1001	jack<span class="comment">#ma</span></span><br><span class="line">1002	dong<span class="comment">#liu</span></span><br><span class="line">1003	poney<span class="comment">#ma</span></span><br><span class="line">Time taken: 0.522 seconds, Fetched: 3 row(s)</span><br><span class="line"></span><br><span class="line">hive (prac)&gt; select <span class="built_in">id</span>,first_name,last_name from test03 lateral view mp_explod2(name,<span class="string">&quot;#&quot;</span>) temp as first_name,last_name;</span><br><span class="line">OK</span><br><span class="line"><span class="built_in">id</span>	first_name	last_name</span><br><span class="line">1001	jack	ma</span><br><span class="line">1002	dong	liu</span><br><span class="line">1003	poney	ma</span><br><span class="line">Time taken: 13.393 seconds, Fetched: 3 row(s)</span><br></pre></td></tr></table></figure>

<p>补充一点：</p>
<p>关于Lateral View在官网这样介绍：</p>
<blockquote>
<h2 id="Lateral-View-Syntax"><a href="#Lateral-View-Syntax" class="headerlink" title="Lateral View Syntax"></a>Lateral View Syntax</h2><p><code>lateralView: LATERAL VIEW udtf(expression) tableAlias AS columnAlias (&#39;,&#39;columnAlias)*</code><br><code>fromClause: FROM baseTable (lateralView)*</code></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Lateral view is used in conjunction with user-defined table generating functions such as <code>explode()</code>. As mentioned in <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-Built-inTable-GeneratingFunctions(UDTF)">Built-in Table-Generating Functions</a>, a UDTF generates zero or more output rows for each input row. A lateral view first applies the UDTF to each row of base table and then joins resulting output rows to the input rows to form a virtual table having the supplied table alias.</p>
</blockquote>
<p>Lateral View一般与用户自定义表生成函数（如explode()）结合使用。 如<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-Built-inTable-GeneratingFunctions(UDTF">内置表生成函数</a> 中所述，UDTF为每个输入行生成零个或多个输出行。 Lateral View 首先将UDTF应用于基表的每一行，然后将结果输出行连接到输入行，以形成具有提供的表别名的虚拟表。</p>
<p>附：<a href="6be3/udtf-1.0-SNAPSHOT.jar" target="_blank">jar包</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Hive优化</title>
    <url>/blog/626f.html</url>
    <content><![CDATA[<p>平常工作中写HiveSQL比较多，对于一些常见的Hive问题和优化做一下总结：</p>
<h3 id="1-MapJoin"><a href="#1-MapJoin" class="headerlink" title="1. MapJoin"></a>1. MapJoin</h3><p>如果不指定<code>Mapjoin</code>或者不符合<code>MapJoin</code>的条件，那么Hive解析器会将<code>Join</code>操作转换成<code>Common Join</code>, 即在<code>Reduce</code>阶段完成<code>Join</code>，容易发生数据倾斜。这时可以使用MapJoin把小表全部加载到内存中在<code>Map</code>端进行<code>Join</code>，避免<code>Reduce</code>处理。</p>
<h3 id="2-行列过滤"><a href="#2-行列过滤" class="headerlink" title="2. 行列过滤"></a>2. 行列过滤</h3><p>列处理：在SELECT中，只拿需要处理的列。如非必要，尽量避免SELECT *；</p>
<p>行处理：尽早的过滤数据，减少每个阶段的数据量，对于分区表尽量使用分区过滤。</p>
<h3 id="3-尽量原子化操作"><a href="#3-尽量原子化操作" class="headerlink" title="3. 尽量原子化操作"></a>3. 尽量原子化操作</h3><p>尽量避免一个SQL包含复杂的逻辑，可以创建临时表来完成复杂的逻辑。</p>
<h3 id="4-采用分区技术"><a href="#4-采用分区技术" class="headerlink" title="4. 采用分区技术"></a>4. 采用分区技术</h3><p>可以把数据根据数据量按照天或者按照周、月来分区。</p>
<h3 id="5-合理设置Map数量和Reduce数"><a href="#5-合理设置Map数量和Reduce数" class="headerlink" title="5. 合理设置Map数量和Reduce数"></a>5. 合理设置Map数量和Reduce数</h3><p>Hive中的SQL查询会生成执行计划，执行计划以MapReduce的方式执行，那么结合数据和集群的大小，Map和Reduce的数量就会影响到SQL的执行效率，除了要控制Hive生成的Job的数量，也要控制map和reduce的数量。</p>
<h4 id="Map的数量"><a href="#Map的数量" class="headerlink" title="Map的数量"></a>Map的数量</h4><p>通常情况下，作业会通过input的目录产生一个或者多个map任务。<br>主要决定因素有：input的文件总个数，input的文件大小，集群设置的文件块大小。<br>Hive中默认的<code>hive.input.format</code>是<code>org.apache.hadoop.hive.ql.io.CombineHivelnputFormat</code>，对于<code>combineHiveInputFormat</code>，它的输入的map数量由三个配置决定：<br><code>mapred.min.split.size.per.node</code> 一个节点上split的至少的大小<br><code>mapred.min.split.size.per.rack</code> 一个交换机下split 至少的大小<br><code>mapred.max.split.size</code> 一个split 最大的大小<br>主要思路是把输入目录下的大文件分成多个map的输入，并合并小文件，做为一个map的输入<br>具体的原理是下述三步：</p>
<p>a) 根据输入目录下的每个文件，如果其长度超过<code>mapred.max.split.size</code>，以Block 为单位分成多个Split（一个Split是一个map的输入），每个split的长度都大于<code>mapred.max.split.size</code>，因为以Block为单位，因此也会大于·<code>BlockSize</code>，此文件剩下的长度如果大于<code>mapred.min.split.size.per.node</code>，则生成一个Split，否则先暂时保留；</p>
<p>b) 现在剩下的都是一些长度较短的碎片，把每个rack 下碎片合并，只要长度超过<br><code>mapred.max.split.size</code>就合并成一-个 split，最后如果剩下的碎片比<code>mapred.min.split.size.per.rack</code> 大，就合并成一个split，否则暂时保留；</p>
<p>c) 把不同rack下的碎片合并，只要长度超过<code>mapred.max.split.size</code>就合并成一个 split，剩下的碎片无论长度，合并成一个split。</p>
<h4 id="Reduce的数量"><a href="#Reduce的数量" class="headerlink" title="Reduce的数量"></a>Reduce的数量</h4><p>reduce数量由以下三个参数决定：</p>
<ul>
<li><code>mapred.reduce.tasks</code>（强制指定reduce的任务数量）</li>
<li><code>hive.exec.reducers.bytes.per.reducer</code>（每个reduce任务处理的数据量，默认为1000^3=1G）</li>
<li><code>hive.exec.reducers.max</code>（每个任务最大的reduce数，默认为999）<br>计算reducer 数的公式:<br><code>N=min(hive.exec.reducers.max，总输入数据量/hive.exec.reducers.bytes.per.reducer)</code></li>
</ul>
<h3 id="6-注意Join的使用"><a href="#6-注意Join的使用" class="headerlink" title="6. 注意Join的使用"></a>6. 注意Join的使用</h3><p>把重复关联键少的表放在join前面，可以提高join效率。网上所谓的<code>hive会将join前面的表放在内存中，把小表放在前面能减少内存资源消耗</code>这种说法在现在看来其实是有异议的。用1条记录的表和3亿条记录的表做join，无论小表是放在join的前面还是join的后面，执行的时间几乎都是相同的，原因是因为Hive在早期某个版本中，底层对此进行了优化。</p>
<h3 id="7-小文件处理"><a href="#7-小文件处理" class="headerlink" title="7. 小文件处理"></a>7. 小文件处理</h3><p><code>HiveInputFormat</code>没有对小文件的合并功能<br>可以使用<code>Combinefileinputformat</code>，将多个小文件打包作为一个整体的inputsplit，减少map任务数<br><code>set mapred.max.split.size=256000000</code>;<br><code>set mapred.min.split.size.per.node= 256000000</code>；<br><code>set mapred.min.split.size.per.rack=256000000</code>;<br><code>set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHivelnputFormat</code>;</p>
<p>设置hive参数，额外启动-一个MR Job打包小文件:<br><code>hive.merge.mapredfiles=false</code> 是否合并Reduce 输出文件，默认为False<br><code>hive.merge.size.per.task = 256*1000*1000</code> 合并文件的大小</p>
<h3 id="8-注意数据倾斜"><a href="#8-注意数据倾斜" class="headerlink" title="8. 注意数据倾斜"></a>8. 注意数据倾斜</h3><p>a) 通过 <code>hive.groupby.skewindata=true</code>控制生成两个MR Job，第一个 MR Job Map的输出结果随机分配到reduce做次预汇总，减少某些key值条数过多某些key条数过小造成的数据倾斜问题；</p>
<p>b) 通过<code>hive.map.aggr = true</code>（默认为true）在Map端做combiner，假如map各条数据基本上不一样，聚合没什么意义，做combiner反而画蛇添足，hive里也考虑的比较周到通过参数<br><code>hive.groupby.mapaggr.checkinterval = 100000</code>（默认）</p>
<p><code>hive.map.aggr.hash.min.reduction=0.5</code>（默认），预先取100000条数据聚合，如果聚合后的条数/100000&gt;0.5，则不再聚合。</p>
<h3 id="9-合理使用multi-insert，union-all"><a href="#9-合理使用multi-insert，union-all" class="headerlink" title="9. 合理使用multi insert，union all"></a>9. 合理使用multi insert，union all</h3><p><code>multi insert</code>适合基于同一个源表按照不同逻辑不同粒度处理插入不同表的场景，做到只需要扫描源表一次，job个数不变，减少源表扫描次数；</p>
<p>union all用好，可减少表的扫描次数，减少job 的个数，通常预先按不同逻辑不同条件生成的查询<code>union all</code>后，再统一<code>Group by</code>计算，不同表的<code>union all</code>相当于<code>multiple inputs</code>，同一个表的<code>union all</code>，相当map一次输出多条。</p>
<h3 id="10-Group优化"><a href="#10-Group优化" class="headerlink" title="10.Group优化"></a>10.Group优化</h3><p>对于Group操作，首先在map端聚合，最后在reduce端做聚合，以下是相关的参数:<br><code>hive.map.aggr=true </code>是否在Map端进行聚合，默认为True,<br><code>hive.groupby.mapaggr.checkinterval= 100000 </code>在Map端进行聚合操作的条目数目。</p>
<h3 id="11-使用压缩"><a href="#11-使用压缩" class="headerlink" title="11. 使用压缩"></a>11. 使用压缩</h3><p>设置map端输出，中间结果压缩。不完全解决数据倾斜问题，但是减少了IO读写和网络传输，能提高很多效率。</p>
<p><code>set hive.exec.compress.intermediate = true;</code></p>
<p>对于中间数据压缩，选择一个低CPU开销的Codec要比选择一个压缩率高的Codec要重要的多。</p>
<p><code>SnappyCodec</code>是一个比较好的中间文件Codec，因为其很好的结合了低CPU开销和好的压缩执行效率。</p>
<h3 id="12-开启JVM重用"><a href="#12-开启JVM重用" class="headerlink" title="12. 开启JVM重用"></a>12. 开启JVM重用</h3><p>JVM重用是Hadoop调优参数的内容，对hive的性能具有非常大的影响，特别是对于很难避免小文件的场景或者Task特别多的场景，这类场景大多数执行时间都很短。Hadoop默认配置是使用JVM来执行map和reduce任务的，这时Jvm的启动过程可能会造成相当大的开销，尤其是执行的job包含有成千上万个task任务的情况。</p>
<p>JVM重用可以使得JVM实例在同一个JOB中重新使用N次，N的值可以在<code>Hadoop的mapre-site.xml</code>文件中进行设置<br><code>mapred.job.reuse.jvm.num.tasks</code><br>也可在hive的执行设置：<br><code>set  mapred.job.reuse.jvm.num.tasks=10</code>;</p>
<p> JVM重用的一个缺点是，开启JVM重用将会一直占用使用到的task插槽，以便进行重用，直到任务完成后才能释放。如果某个不平衡的job中有几个<code>reduce task</code> 执行的时间要比其他<code>reduce task</code>消耗的时间多得多的话，那么保留的插槽就会一直空闲着却无法被其他的job使用，直到所有的task都结束了才会释放。</p>
<h3 id="13-使用动态分区"><a href="#13-使用动态分区" class="headerlink" title="13.使用动态分区"></a>13.使用动态分区</h3><p>在Hive中，有时候会希望根据输入的Key，把结果自动输出到不同的目录中，这可以通过动态分区来实现，就是把每一个 key当作一个 分区。<br>如果要启动动态分区，则需要进行下面的设置首先需要在hive语句中设置允许动态分区<br><code>set hive.exec.dynamic.partition=true</code>；<br><code>set hive.exec.dynamic.partition.mode=nonstrict</code>；<br>在动态分区有可能很大的情况下，还需要其他的调整<br><code>hive.exec.dynamic.partitions.pernode</code> 参数指的是每个节点上能够生成的最大分区，这个在最坏情况下应该是跟最大分区一样的值<br><code>hive.exec.dynamic.partitions.partitions</code> 参数指的是总共的最大的动态分区数<code>hive.exec.max.createdfiles</code>参数指的是能够创建的最多文件数（分区一多，文件必然就多了）<br>最后要注意的是select语句中要把distribute的key也select出来。</p>
<h3 id="14-使用列式存储"><a href="#14-使用列式存储" class="headerlink" title="14.使用列式存储"></a>14.使用列式存储</h3><p>根据数据的特点来进行技术选型：如果数据结构是比较扁平的，那么用<code> ORC</code> 比较合适，如果嵌套较多，就用 <code>Parquet</code>。<br>列存储主要有两个好处：数据压缩和查询性能提升，在节省了存储的同时还提升了查询性能，这个的收益是非常可观的。</p>
<h3 id="15-使用索引"><a href="#15-使用索引" class="headerlink" title="15.使用索引"></a>15.使用索引</h3><p>索引可以避免全表扫描和资源浪费<br>索引可以加快含有Group By语句的查询的计算速度<br><code>hive.optimize.index.filter=true</code>; 使用自动索引<br><code>hive.optimie.index.groupby=true</code>;使用聚合索引优化GROUP BY操作</p>
<h3 id="16-利用好EXPLAIN"><a href="#16-利用好EXPLAIN" class="headerlink" title="16.利用好EXPLAIN"></a>16.利用好EXPLAIN</h3><p>Explain命令对于优化查询语句很重要，针对某些查询语句，我们可以通过它查看各个执行计划，针对耗时的地方，采取优化。</p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>HQL必会50题</title>
    <url>/blog/b8f1.html</url>
    <content><![CDATA[<p>平常加班不多，为了提高自己的SQL能力，找了网上流传的比较广泛的SQL50题，先把题目拿过来，计划抽空作为练习用HiveSQL完成。</p>
<p>开始日期：2020-03-18</p>
<p>完成日期：2020-03-21</p>
<p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(s_id string,s_name string,s_birth string,s_sex string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> course(c_id string,c_name string,t_id string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> teacher(t_id string,t_name string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> score(s_id string,c_id string,s_score <span class="type">int</span>) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>数据：</p>
<p><a href="https://mapan.tech/cn/b8f1/student.txt" target="_blank">student.txt </a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01	赵雷	1990-01-01	男</span><br><span class="line">02	钱电	1990-12-21	男</span><br><span class="line">03	孙风	1990-05-20	男</span><br><span class="line">04	李云	1990-08-06	男</span><br><span class="line">05	周梅	1991-12-01	女</span><br><span class="line">06	吴兰	1992-03-01	女</span><br><span class="line">07	郑竹	1989-07-01	女</span><br><span class="line">08	王菊	1990-01-20	女</span><br></pre></td></tr></table></figure>

<p> <a href="https://mapan.tech/cn/b8f1/teacher.txt" target="_blank">teacher.txt</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01	张三</span><br><span class="line">02	李四</span><br><span class="line">03	王五</span><br></pre></td></tr></table></figure>

<p>  <a href="https://mapan.tech/cn/b8f1/course.txt" target="_blank">course.txt</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01	语文	02</span><br><span class="line">02	数学	01</span><br><span class="line">03	英语	03</span><br></pre></td></tr></table></figure>

<p>  <a href="https://mapan.tech/cn/b8f1/score.txt" target="_blank">score.txt</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01	01	80</span><br><span class="line">01	02	90</span><br><span class="line">01	03	99</span><br><span class="line">02	01	70</span><br><span class="line">02	02	60</span><br><span class="line">02	03	80</span><br><span class="line">03	01	80</span><br><span class="line">03	02	80</span><br><span class="line">03	03	80</span><br><span class="line">04	01	50</span><br><span class="line">04	02	30</span><br><span class="line">04	03	20</span><br><span class="line">05	01	76</span><br><span class="line">05	02	87</span><br><span class="line">06	01	31</span><br><span class="line">06	03	34</span><br><span class="line">07	02	89</span><br><span class="line">07	03	98</span><br></pre></td></tr></table></figure>

<p>加载数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;~/student.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> student;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;~/course.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> course;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;~/teacher.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> teacher;</span><br><span class="line"></span><br><span class="line">load data <span class="keyword">local</span> inpath <span class="string">&#x27;~/score.txt&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> score;</span><br></pre></td></tr></table></figure>



<p>表之间的关系如图：</p>
<img src="/blog/b8f1/Kinship.png" class="表关系">

<ul>
<li>1、查询”01”课程比”02”课程成绩高的学生的信息及课程分数:</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    T0.<span class="operator">*</span>,</span><br><span class="line">    T1.s_score <span class="keyword">AS</span> c01,</span><br><span class="line">    T2.s_score <span class="keyword">as</span> c02</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student <span class="keyword">AS</span> T0,</span><br><span class="line">    (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> T1,</span><br><span class="line">    (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span>) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">WHERE</span> T0.s_id<span class="operator">=</span>T1.s_id</span><br><span class="line"><span class="keyword">AND</span> T0.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">AND</span> T1.s_score<span class="operator">&gt;</span>T2.s_score;</span><br></pre></td></tr></table></figure>

<p>  运行结果：</p>
<img src="/blog/b8f1/image-20200318221755774.png" class="image-20200318221755774">



<ul>
<li>2、查询同时存在” 01 “课程和” 02 “课程的情况:</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t3.<span class="operator">*</span>,</span><br><span class="line">    t1.s_score <span class="keyword">as</span> c01,</span><br><span class="line">    t2.s_score <span class="keyword">as</span> c02</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">as</span> t1, <span class="comment">-- 选修01课程的同学</span></span><br><span class="line">    (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span>) <span class="keyword">as</span> t2, <span class="comment">-- 选修01课程的同学</span></span><br><span class="line">    student <span class="keyword">as</span> t3</span><br><span class="line"><span class="keyword">WHERE</span> t1.s_id<span class="operator">=</span>t2.s_id</span><br><span class="line"><span class="keyword">AND</span> t2.s_id<span class="operator">=</span>t3.s_id;</span><br></pre></td></tr></table></figure>

<p>  运行结果：</p>
<img src="/blog/b8f1/image-20200318224041101.png" class="image-20200318224041101">

<ul>
<li>3、查询存在” 01 “课程但<strong>可能</strong>不存在” 02 “课程的情况(不存在时显示为 null )</li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t2.<span class="operator">*</span>,</span><br><span class="line">    t1.s_score <span class="keyword">AS</span> c01,</span><br><span class="line">    t3.s_score <span class="keyword">AS</span> c02 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> t1, <span class="comment">-- 选修01课程的同学</span></span><br><span class="line">    student <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id,s_score <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span>) <span class="keyword">AS</span> t3 <span class="comment">-- 选修01课程的同学</span></span><br><span class="line"><span class="keyword">ON</span> t2.s_id <span class="operator">=</span> t3.s_id</span><br><span class="line"><span class="keyword">WHERE</span> t1.s_id<span class="operator">=</span>t2.s_id;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200318225024279.png" class="image-20200318225024279">


<ul>
<li>4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩:<br>(包括有成绩的和无成绩的)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T1.s_name,</span><br><span class="line">    T2.avg_sc</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span>(<span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        <span class="built_in">avg</span>(s_score) <span class="keyword">AS</span> avg_sc </span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line">    <span class="keyword">having</span> avg_sc<span class="operator">&lt;</span><span class="number">60</span>) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id; </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200318225822830.png" class="image-20200318225822830">


<ul>
<li><p>5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T1.s_name,</span><br><span class="line">    T2.co_cnt,</span><br><span class="line">    T3.sum_score</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> co_cnt <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id,<span class="built_in">sum</span>(s_score) <span class="keyword">AS</span> sum_score <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200318231242423.png" class="image-20200318231242423"></li>
</ul>
<ul>
<li><p>6、查询”李”姓老师的数量:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> teacher <span class="keyword">WHERE</span> t_name <span class="keyword">LIKE</span> &quot;李%&quot;;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200319073738350.png" class="image-20200319073738350"></li>
</ul>
<ul>
<li><p>7、查询学过”张三”老师授课的同学的信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    T1.<span class="operator">*</span>,</span><br><span class="line">    T3.c_name,</span><br><span class="line">    T4.t_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    student <span class="keyword">AS</span> T1,</span><br><span class="line">    score <span class="keyword">AS</span> T2,</span><br><span class="line">    course <span class="keyword">AS</span> T3,</span><br><span class="line">    teacher <span class="keyword">AS</span> T4</span><br><span class="line"><span class="keyword">WHERE</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">AND</span> T2.c_id<span class="operator">=</span>T3.c_id</span><br><span class="line"><span class="keyword">AND</span> T3.t_id<span class="operator">=</span>T4.t_id</span><br><span class="line"><span class="keyword">AND</span> T4.t_name<span class="operator">=</span>&quot;张三&quot;;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200319074432715.png" class="image-20200319074432715"></li>
</ul>
<ul>
<li><p>8、查询没学过”张三”老师授课的同学的信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A1.<span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">AS</span> A1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> </span><br><span class="line">                T1.s_id</span><br><span class="line">            <span class="keyword">FROM</span></span><br><span class="line">                student <span class="keyword">AS</span> T1,</span><br><span class="line">                score <span class="keyword">AS</span> T2,</span><br><span class="line">                course <span class="keyword">AS</span> T3,</span><br><span class="line">                teacher <span class="keyword">AS</span> T4</span><br><span class="line">            <span class="keyword">WHERE</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line">            <span class="keyword">AND</span> T2.c_id<span class="operator">=</span>T3.c_id</span><br><span class="line">            <span class="keyword">AND</span> T3.t_id<span class="operator">=</span>T4.t_id</span><br><span class="line">            <span class="keyword">AND</span> T4.t_name<span class="operator">=</span>&quot;张三&quot;) <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">ON</span> A1.s_id<span class="operator">=</span>A2.s_id</span><br><span class="line"><span class="keyword">WHERE</span> A2.s_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200319075846289.png" class="image-20200319075846289"></li>
</ul>
<ul>
<li><p>9、查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">            T1.s_id</span><br><span class="line">        <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> s_id <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> T1</span><br><span class="line">        <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span>) <span class="keyword">AS</span> T2</span><br><span class="line">        <span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id) <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.s_id<span class="operator">=</span>B.s_id;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200319080655329.png" class="image-20200319080655329"></li>
</ul>
<ul>
<li><p>10、查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">            T1.s_id</span><br><span class="line">        <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> s_id <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> T1</span><br><span class="line">        <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span>) <span class="keyword">AS</span> T2</span><br><span class="line">        <span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line">        <span class="keyword">WHERE</span> T2.s_id <span class="keyword">IS</span> <span class="keyword">NULL</span>) <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.s_id<span class="operator">=</span>B.s_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行结果：</p>
<img src="/blog/b8f1/image-20200319080957865.png" class="image-20200319080957865">




<ul>
<li>11、查询没有学全所有课程的同学的信息:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.<span class="operator">*</span>,</span><br><span class="line">    T2.CNT_C</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> s_id,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_C <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">WHERE</span> T2.CNT_C<span class="operator">&lt;</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200319221856619.png" class="image-20200319221856619">


<ul>
<li>12、查询至少有一门课与学号为”01”的同学所学相同的同学的信息:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    t3.<span class="operator">*</span>,</span><br><span class="line">    t4.cnt </span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> t3 </span><br><span class="line"><span class="keyword">JOIN</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> s_id,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> cnt </span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> t1 </span><br><span class="line">    <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> c_id </span><br><span class="line">          <span class="keyword">FROM</span> score</span><br><span class="line">          <span class="keyword">WHERE</span> s_id <span class="operator">=</span>&quot;01&quot;) <span class="keyword">AS</span> t2 </span><br><span class="line">    <span class="keyword">ON</span> t1.c_id <span class="operator">=</span> t2.c_id </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id </span><br><span class="line">    <span class="keyword">HAVING</span> cnt<span class="operator">&gt;</span><span class="number">0</span>) <span class="keyword">AS</span> t4 </span><br><span class="line"><span class="keyword">ON</span> t3.s_id<span class="operator">=</span>t4.s_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200319223531461.png" class="image-20200319223531461">


<ul>
<li>13、查询和”01”号的同学学习的课程完全相同的其他同学的信息:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    A1.<span class="operator">*</span>,</span><br><span class="line">    A2.CNT_C</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> A1</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> T1.s_id,<span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_C</span><br><span class="line">        <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">        <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> score <span class="keyword">WHERE</span> s_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> T2</span><br><span class="line">        <span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.s_id) <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">ON</span> A1.s_id<span class="operator">=</span>A2.s_id</span><br><span class="line"><span class="keyword">AND</span> A1.S_id<span class="operator">&lt;&gt;</span><span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_C <span class="keyword">FROM</span> score <span class="keyword">where</span> s_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span>) <span class="keyword">AS</span> A3</span><br><span class="line"><span class="keyword">ON</span> A2.CNT_C<span class="operator">=</span>A3.CNT_C;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200319230518263.png" class="image-20200319230518263">



<ul>
<li>14、查询没学过”张三”老师讲授的任一门课程的学生姓名:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S1.s_name </span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> S1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">                A1.s_id</span><br><span class="line">            <span class="keyword">FROM</span> score <span class="keyword">AS</span> A1</span><br><span class="line">            <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> T2.c_id </span><br><span class="line">                    <span class="keyword">FROM</span> teacher <span class="keyword">AS</span> T1 </span><br><span class="line">                    <span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line">                    <span class="keyword">ON</span> T1.t_id<span class="operator">=</span>T2.t_id</span><br><span class="line">                    <span class="keyword">WHERE</span> T1.t_name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>) <span class="keyword">AS</span> A2</span><br><span class="line">            <span class="keyword">ON</span> A1.c_id<span class="operator">=</span>A2.c_id</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> A1.s_id) <span class="keyword">AS</span> S2</span><br><span class="line"><span class="keyword">ON</span> S1.s_id<span class="operator">=</span>S2.s_id</span><br><span class="line"><span class="keyword">WHERE</span> S2.s_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200319232211741.png" class="image-20200319232211741">



<ul>
<li>15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T1.s_name,</span><br><span class="line">    T3.AVG_C</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_C</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> s_score<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line">    <span class="keyword">having</span> CNT_C<span class="operator">&gt;=</span><span class="number">2</span>) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">            s_id,</span><br><span class="line">            <span class="built_in">AVG</span>(s_score) <span class="keyword">AS</span> AVG_C</span><br><span class="line">        <span class="keyword">FROM</span> score</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id) <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200320080055175.png" class="image-20200320080055175">


<ul>
<li>16、检索”01”课程分数小于60，按分数降序排列的学生信息:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.<span class="operator">*</span>,</span><br><span class="line">    T2.s_score</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span></span><br><span class="line">            s_id,</span><br><span class="line">            s_score</span><br><span class="line">        <span class="keyword">FROM</span> score</span><br><span class="line">        <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> s_score<span class="operator">&lt;</span><span class="number">60</span>) <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.S_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> T2.s_score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/blog/b8f1/image-20200320080551819.png" class="image-20200320080551819">


<ul>
<li>17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩:</li>
</ul>
<p>尝试用WITH的写法，相对常规写法逻辑还是比较清晰的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line"><span class="comment">-- 平均分</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        <span class="built_in">AVG</span>(s_score) <span class="keyword">AS</span> AVG_S</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line">), T2 <span class="keyword">AS</span>(</span><br><span class="line"><span class="comment">-- 语文分数</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span></span><br><span class="line">)</span><br><span class="line">, T3 <span class="keyword">AS</span>(</span><br><span class="line"><span class="comment">-- 数学分数</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span></span><br><span class="line">), T4 <span class="keyword">AS</span>(</span><br><span class="line"><span class="comment">-- 英语分数</span></span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;03&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T0.s_id,</span><br><span class="line">    T0.s_name,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T1.AVG_S <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">ELSE</span> round(T1.AVG_S,<span class="number">2</span>) <span class="keyword">END</span>) <span class="keyword">AS</span> AVG_S,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">ELSE</span> T2.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> CHINESE,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T3.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">ELSE</span> T3.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> MATH,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T4.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">ELSE</span> T4.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> ENGLISH</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T0</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T0.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2</span><br><span class="line"><span class="keyword">ON</span> T2.s_id<span class="operator">=</span>T0.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3</span><br><span class="line"><span class="keyword">ON</span> T3.s_id<span class="operator">=</span>T0.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T4</span><br><span class="line"><span class="keyword">ON</span> T4.s_id<span class="operator">=</span>T0.s_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> AVG_S <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321105038801.png" class="image-20200321105038801">




<ul>
<li>18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分， ，平均分，及格率，中等率，优良率，优秀率: （及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        c_id,</span><br><span class="line">        <span class="built_in">MAX</span>(s_score) <span class="keyword">AS</span> max_c,</span><br><span class="line">        <span class="built_in">MIN</span>(s_score) <span class="keyword">AS</span> min_c,</span><br><span class="line">        ROUND(<span class="built_in">AVG</span>(s_score),<span class="number">2</span>)  <span class="keyword">AS</span> avg_c,</span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">count</span>(s_score),<span class="number">2</span>) <span class="keyword">AS</span> L1,</span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">79</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">count</span>(s_score),<span class="number">2</span>)  <span class="keyword">AS</span> L2,</span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">89</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">count</span>(s_score),<span class="number">2</span>)  <span class="keyword">AS</span> L3,</span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score<span class="operator">&gt;=</span><span class="number">90</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">count</span>(s_score),<span class="number">2</span>)  <span class="keyword">AS</span> L4</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A0.c_id,</span><br><span class="line">    A0.c_name,</span><br><span class="line">    A1.max_c,</span><br><span class="line">    A1.min_c,</span><br><span class="line">    A1.avg_c,</span><br><span class="line">    A1.L1,</span><br><span class="line">    A1.L2,</span><br><span class="line">    A1.L3,</span><br><span class="line">    A1.L4</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> A0</span><br><span class="line"><span class="keyword">JOIN</span> A1</span><br><span class="line"><span class="keyword">ON</span> A0.c_id<span class="operator">=</span>A1.c_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321153421319.png" class="image-20200321153421319">


<ul>
<li>19、按各科成绩进行排序，并显示排名:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    T1.s_id,</span><br><span class="line">    T3.s_name,</span><br><span class="line">    T1.c_id,</span><br><span class="line">    T2.c_name,</span><br><span class="line">    T1.s_score,</span><br><span class="line">    RANK() OVER (PARTITION BY T1.c_id ORDER BY T1.s_score DESC)</span><br><span class="line">FROM score AS T1</span><br><span class="line">JOIN course AS T2</span><br><span class="line">ON T1.c_id=T2.c_id</span><br><span class="line">JOIN student AS T3</span><br><span class="line">ON T1.s_id=T3.s_id;</span><br></pre></td></tr></table></figure>




<ul>
<li>20、查询学生的总成绩并进行排名:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T3.s_name,</span><br><span class="line">    <span class="built_in">sum</span>(T1.s_score) <span class="keyword">AS</span> SUM_C,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">sum</span>(T1.s_score) <span class="keyword">DESC</span>)</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> student <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.s_id,T3.s_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321181506578.png" class="image-20200321181506578">

<ul>
<li>21、查询不同老师所教不同课程平均分从高到低显示:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.c_id,</span><br><span class="line">    T3.t_name,</span><br><span class="line">    ROUND(<span class="built_in">AVG</span>(T1.s_score),<span class="number">2</span>),</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(T1.s_score) <span class="keyword">DESC</span>)</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line"><span class="keyword">JOIN</span> teacher <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">ON</span> T2.t_id<span class="operator">=</span>T3.t_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.c_id,T3.t_name;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321181609080.png" class="image-20200321181609080">


<ul>
<li>22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        T1.s_id,</span><br><span class="line">        T3.s_name,</span><br><span class="line">        T1.c_id,</span><br><span class="line">        T2.c_name,</span><br><span class="line">        T1.s_score,</span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> T1.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> T1.s_score <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">    <span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line">    <span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line">    <span class="keyword">JOIN</span> student <span class="keyword">AS</span> T3</span><br><span class="line">    <span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> A1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> A1</span><br><span class="line"><span class="keyword">WHERE</span> A1.rk<span class="operator">=</span><span class="number">2</span> <span class="keyword">OR</span> A1.rk<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321181701546.png" class="image-20200321181701546">



<ul>
<li>23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        c_id,</span><br><span class="line">        <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">59</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> L0, <span class="comment">-- [0-59分的人数]</span></span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">59</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="number">1</span>),<span class="number">2</span>) <span class="keyword">AS</span> H0, <span class="comment">-- [0-59分的人数占比]</span></span><br><span class="line">        <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">70</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> L1, <span class="comment">-- [60-69分的人数]</span></span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">69</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="number">1</span>),<span class="number">2</span>) <span class="keyword">AS</span> H1, <span class="comment">-- [60-69分的人数占比]</span></span><br><span class="line">        <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)  <span class="keyword">AS</span> L2, <span class="comment">-- [70-85分的人数]</span></span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">85</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="number">1</span>),<span class="number">2</span>) <span class="keyword">AS</span> H2, <span class="comment">-- [70-85分的人数占比]</span></span><br><span class="line">        <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">86</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)  <span class="keyword">AS</span> L3, <span class="comment">-- [86-100分的人数]</span></span><br><span class="line">        ROUND(<span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> s_score <span class="keyword">BETWEEN</span> <span class="number">86</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="number">1</span>),<span class="number">2</span>) <span class="keyword">AS</span> H3 <span class="comment">-- [86-100分的人数占比]</span></span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A0.c_id,</span><br><span class="line">    A0.c_name,</span><br><span class="line">    A1.L3,</span><br><span class="line">    A1.H3,</span><br><span class="line">    A1.L2,</span><br><span class="line">    A1.H2,</span><br><span class="line">    A1.L1,</span><br><span class="line">    A1.H1,</span><br><span class="line">    A1.L0,</span><br><span class="line">    A1.H0</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> A0</span><br><span class="line"><span class="keyword">JOIN</span> A1</span><br><span class="line"><span class="keyword">ON</span> A0.c_id<span class="operator">=</span>A1.c_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321181822411.png" class="image-20200321181822411">



<ul>
<li>24、查询学生平均成绩及其名次:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T3.s_name,</span><br><span class="line">    ROUND(<span class="built_in">AVG</span>(T1.s_score),<span class="number">2</span>) <span class="keyword">AS</span> AVG_C,</span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">sum</span>(T1.s_score) <span class="keyword">DESC</span>)</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> student <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.s_id,T3.s_name;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321181938010.png" class="image-20200321181938010">


<ul>
<li>25、查询各科成绩前三名的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        T1.s_id,</span><br><span class="line">        T3.s_name,</span><br><span class="line">        T1.c_id,</span><br><span class="line">        T2.c_name,</span><br><span class="line">        T1.s_score,</span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> T1.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> T1.s_score <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">    <span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line">    <span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line">    <span class="keyword">JOIN</span> student <span class="keyword">AS</span> T3</span><br><span class="line">    <span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T3.s_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> A1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> A1</span><br><span class="line"><span class="keyword">WHERE</span> A1.rk<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321182026689.png" class="image-20200321182026689">

<ul>
<li>26、查询每门课程被选修的学生数:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.c_id,</span><br><span class="line">    T2.c_name,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.c_id,T2.c_name</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321182103466.png" class="image-20200321182103466">

<ul>
<li>27、查询出只有两门课程的全部学生的学号和姓名:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        T1.s_id,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.s_id</span><br><span class="line">    <span class="keyword">HAVING</span> CNT<span class="operator">=</span><span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A2.s_id,</span><br><span class="line">    A2.s_name,</span><br><span class="line">    A1.CNT</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">JOIN</span> A1 </span><br><span class="line"><span class="keyword">ON</span> A1.s_id<span class="operator">=</span>A2.s_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321182151875.png" class="image-20200321182151875">

<ul>
<li>28、查询男生、女生人数:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_sex,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_sex;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321182221250.png" class="image-20200321182221250">

<ul>
<li>29、查询名字中含有”风”字的学生信息:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">WHERE</span> T1.s_name <span class="keyword">LIKE</span> &quot;%风%&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/blog/b8f1/image-20200321182246186.png" class="image-20200321182246186">

<ul>
<li>30、查询同名同性学生名单，并统计同名人数:</li>
</ul>
<p>数据中发现没有同名同性的学生，先插入几条</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;09&#x27;</span> , <span class="string">&#x27;张三&#x27;</span> , <span class="string">&#x27;2017-12-20&#x27;</span> , <span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;10&#x27;</span> , <span class="string">&#x27;李四&#x27;</span> , <span class="string">&#x27;2017-12-25&#x27;</span> , <span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;11&#x27;</span> , <span class="string">&#x27;李四&#x27;</span> , <span class="string">&#x27;2012-06-06&#x27;</span> , <span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;12&#x27;</span> , <span class="string">&#x27;赵六&#x27;</span> , <span class="string">&#x27;2013-06-13&#x27;</span> , <span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;13&#x27;</span> , <span class="string">&#x27;孙七&#x27;</span> , <span class="string">&#x27;2014-06-01&#x27;</span> , <span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>然后找同名同性的学生</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s_name,</span><br><span class="line">    s_sex,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_N</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name,s_sex</span><br><span class="line"><span class="keyword">HAVING</span> CNT_N<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321182748601.png" class="image-20200321182748601">


<ul>
<li>31、查询1990年出生的学生名单:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> s_birth <span class="keyword">BETWEEN</span> <span class="string">&#x27;1990-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1990-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321182943315.png" class="image-20200321182943315">


<ul>
<li>32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        c_id,</span><br><span class="line">        ROUND(<span class="built_in">AVG</span>(s_score),<span class="number">2</span>) <span class="keyword">AS</span> AVG_C</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.c_id,</span><br><span class="line">    T0.c_name,</span><br><span class="line">    T1.AVG_C</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> T0</span><br><span class="line"><span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.c_id<span class="operator">=</span>T1.c_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> T1.AVG_C <span class="keyword">DESC</span>,T1.c_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321183807915.png" class="image-20200321183807915">


<ul>
<li>33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        <span class="built_in">AVG</span>(s_score) <span class="keyword">AS</span> AVG_S</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line">    <span class="keyword">HAVING</span> AVG_S<span class="operator">&gt;=</span><span class="number">85</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T0.s_id,</span><br><span class="line">    T0.s_name,</span><br><span class="line">    T1.AVG_S</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> T0</span><br><span class="line"><span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T1.s_id;</span><br></pre></td></tr></table></figure>




<ul>
<li>34、查询课程名称为”数学”，且分数低于60的学生姓名和分数:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        s_id,</span><br><span class="line">        <span class="built_in">AVG</span>(s_score) <span class="keyword">AS</span> AVG_S</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line">    <span class="keyword">HAVING</span> AVG_S<span class="operator">&gt;=</span><span class="number">85</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T0.s_id,</span><br><span class="line">    T0.s_name,</span><br><span class="line">    ROUND(T1.AVG_S,<span class="number">2</span>) <span class="keyword">AS</span> AVG_S</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">as</span> T0</span><br><span class="line"><span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T1.s_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321194621260.png" class="image-20200321194621260">


<ul>
<li>35、查询所有学生的课程及分数情况:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span></span><br><span class="line">), T2 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;02&#x27;</span></span><br><span class="line">), T3 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        s_id,</span><br><span class="line">        s_score</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">WHERE</span> c_id<span class="operator">=</span><span class="string">&#x27;03&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T0.s_id,</span><br><span class="line">    T0.s_name,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T1.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> &quot;未选修&quot; <span class="keyword">ELSE</span> T1.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> CHINESE,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> &quot;未选修&quot; <span class="keyword">ELSE</span> T2.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> MATH,</span><br><span class="line">    (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T3.s_score <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> &quot;未选修&quot; <span class="keyword">ELSE</span> T3.s_score <span class="keyword">END</span>) <span class="keyword">AS</span> ENGLISH</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> T0</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T1.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T3.s_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321195553301.png" class="image-20200321195553301">


<ul>
<li>36、查询任何一门课程成绩在70分以上的学生姓名、课程名称和分数:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="comment">-- T0.s_id,</span></span><br><span class="line">    T1.s_name,</span><br><span class="line">    <span class="comment">-- T0.c_id,</span></span><br><span class="line">    T2.c_name,</span><br><span class="line">    T0.s_score</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T0</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T1.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T0.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line"><span class="keyword">WHERE</span> T0.s_score<span class="operator">&gt;</span><span class="number">70</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321200351423.png" class="image-20200321200351423">


<ul>
<li>37、查询课程不及格的学生:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="comment">-- T0.s_id,</span></span><br><span class="line">    T1.s_name,</span><br><span class="line">    <span class="comment">-- T0.c_id,</span></span><br><span class="line">    T2.c_name,</span><br><span class="line">    T0.s_score</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T0</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">ON</span> T0.s_id<span class="operator">=</span>T1.s_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> course <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T0.c_id<span class="operator">=</span>T2.c_id</span><br><span class="line"><span class="keyword">WHERE</span> T0.s_score<span class="operator">&lt;</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321200449627.png" class="image-20200321200449627">


<ul>
<li>38、查询课程编号为01且课程成绩在80分及以上的学生的学号和姓名:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.s_id,</span><br><span class="line">    T2.s_name</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line"><span class="keyword">JOIN</span> student <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">ON</span> T1.s_id<span class="operator">=</span>T2.s_id</span><br><span class="line"><span class="keyword">WHERE</span> T1.c_id<span class="operator">=</span><span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> T1.s_score<span class="operator">&gt;=</span><span class="number">80</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321201135781.png" class="image-20200321201135781">


<ul>
<li>39、求每门课程的学生人数:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        c_id,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_S</span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T2.c_id,</span><br><span class="line">    T2.c_name,</span><br><span class="line">    T1.CNT_S</span><br><span class="line"><span class="keyword">FROM</span> course <span class="keyword">AS</span> T2</span><br><span class="line"><span class="keyword">JOIN</span> T1</span><br><span class="line"><span class="keyword">ON</span> T1.c_id<span class="operator">=</span>T2.c_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321201506854.png" class="image-20200321201506854">


<ul>
<li>40、查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> T1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        A4.<span class="operator">*</span>,</span><br><span class="line">        A3.s_score,</span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> A3.s_score <span class="keyword">DESC</span>) <span class="keyword">AS</span> RK</span><br><span class="line">    <span class="keyword">FROM</span> teacher <span class="keyword">AS</span> A1</span><br><span class="line">    <span class="keyword">JOIN</span> course <span class="keyword">AS</span> A2</span><br><span class="line">    <span class="keyword">ON</span> A1.t_id<span class="operator">=</span>A2.t_id</span><br><span class="line">    <span class="keyword">JOIN</span> score <span class="keyword">AS</span> A3</span><br><span class="line">    <span class="keyword">ON</span> A3.c_id<span class="operator">=</span>A2.c_id</span><br><span class="line">    <span class="keyword">JOIN</span> student <span class="keyword">AS</span> A4</span><br><span class="line">    <span class="keyword">ON</span> A3.s_id<span class="operator">=</span>A4.s_id</span><br><span class="line">    <span class="keyword">WHERE</span> A1.t_name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    T1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> T1</span><br><span class="line"><span class="keyword">WHERE</span> RK<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<img src="/blog/b8f1/image-20200321203900937.png" class="image-20200321203900937">


<ul>
<li>41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="keyword">DISTINCT</span> T1.s_id,</span><br><span class="line">    T1.c_id,</span><br><span class="line">    T3.c_name,</span><br><span class="line">    T1.s_score</span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> T1,score <span class="keyword">AS</span> T2,course <span class="keyword">AS</span> T3</span><br><span class="line"><span class="keyword">WHERE</span> T1.c_id <span class="operator">&lt;&gt;</span> T2.c_id </span><br><span class="line"><span class="keyword">AND</span> T1.s_score<span class="operator">=</span>T2.s_score</span><br><span class="line"><span class="keyword">AND</span> T1.c_id<span class="operator">=</span>T3.c_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321220508059.png" class="image-20200321220508059">


<ul>
<li>42、查询每门课程成绩最好的前三名:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        T1.s_id,</span><br><span class="line">        T1.c_id,</span><br><span class="line">        T1.s_score,</span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> T1.c_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> T1.s_score <span class="keyword">DESC</span>) <span class="keyword">AS</span> RK</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A1.s_id,</span><br><span class="line">    A3.s_name,</span><br><span class="line">    A2.c_name,</span><br><span class="line">    A1.s_score,</span><br><span class="line">    A1.RK</span><br><span class="line"><span class="keyword">FROM</span> A1</span><br><span class="line"><span class="keyword">JOIN</span> course <span class="keyword">AS</span> A2</span><br><span class="line"><span class="keyword">ON</span> A1.c_id<span class="operator">=</span>A2.c_id</span><br><span class="line"><span class="keyword">JOIN</span> student <span class="keyword">AS</span> A3</span><br><span class="line"><span class="keyword">ON</span> A1.s_id<span class="operator">=</span>A3.s_id</span><br><span class="line"><span class="keyword">WHERE</span> RK<span class="operator">&lt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321205236979.png" class="image-20200321205236979">


<ul>
<li>43、统计每门课程的学生选修人数（超过5人的课程才统计）:要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    c_id,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_C</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c_id</span><br><span class="line"><span class="keyword">HAVING</span> CNT_C<span class="operator">&gt;=</span><span class="number">5</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> CNT_C <span class="keyword">DESC</span>,c_id;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321205619210.png" class="image-20200321205619210">


<ul>
<li>44、检索至少选修两门课程的学生学号:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s_id,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_S</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_id</span><br><span class="line"><span class="keyword">HAVING</span> CNT_S<span class="operator">&gt;=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321205759015.png" class="image-20200321205759015">


<ul>
<li>45、查询选修了全部课程的学生信息:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> A1 <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        T1.s_id,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> CNT_S</span><br><span class="line">    <span class="keyword">FROM</span> score <span class="keyword">AS</span> T1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.s_id</span><br><span class="line">    <span class="keyword">HAVING</span> CNT_S<span class="operator">=</span><span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    A0.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student A0</span><br><span class="line"><span class="keyword">JOIN</span> A1</span><br><span class="line"><span class="keyword">ON</span> A0.s_id<span class="operator">=</span>A1.s_id</span><br><span class="line"><span class="keyword">WHERE</span> A1.CNT_S<span class="operator">=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321210907315.png" class="image-20200321210907315">


<ul>
<li>46、查询各学生的年龄(周岁):</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    s_name,</span><br><span class="line">    s_birth,</span><br><span class="line">    (YEAR(current_date())-YEAR(s_birth)-</span><br><span class="line">        (CASE WHEN MONTH(current_date())&gt;MONTH(s_birth) THEN 0 </span><br><span class="line">              WHEN MONTH(current_date())=MONTH(s_birth) THEN </span><br><span class="line">                    (CASE WHEN DAY(current_date())&gt;=DAY(s_birth) THEN 0 ELSE 1 END)</span><br><span class="line">          ELSE 1 END)</span><br><span class="line">    ) AS AGE</span><br><span class="line">FROM student;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321213703448.png" class="image-20200321213703448">


<ul>
<li>47、查询本周过生日的学生:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    s_name,</span><br><span class="line">    s_birth</span><br><span class="line">FROM student</span><br><span class="line">WHERE s_birth BETWEEN DATE_ADD(NEXT_DAY(current_date(), &#x27;MON&#x27;),-1) AND DATE_ADD(NEXT_DAY(current_date(), &#x27;MON&#x27;),-7);</span><br></pre></td></tr></table></figure>

<p>今天是3月21号，暂时没有本周过生日的同学，不过本题的思想是找到本周第一天和本周最后一天，HQL实现如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">        DATE_ADD(NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>),<span class="number">-1</span>) <span class="keyword">AS</span> SUNDAY,</span><br><span class="line">        DATE_ADD(NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>),<span class="number">-7</span>) <span class="keyword">AS</span> MONDAY</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321215322208.png" class="image-20200321215322208">


<ul>
<li>48、查询下周过生日的学生:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s_name,</span><br><span class="line">    s_birth</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> s_birth <span class="keyword">BETWEEN</span> NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>) <span class="keyword">AND</span> DATE_ADD(NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>),<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>同样没有下周过生日的同学，下周一到下周日的HQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>) , DATE_ADD(NEXT_DAY(<span class="built_in">current_date</span>(), <span class="string">&#x27;MON&#x27;</span>),<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321215737713.png" class="image-20200321215737713">


<ul>
<li>49、查询本月过生日的学生:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s_name,</span><br><span class="line">    s_birth</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(s_birth)<span class="operator">=</span><span class="keyword">MONTH</span>(<span class="built_in">current_date</span>());</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321215852433.png" class="image-20200321215852433">


<ul>
<li>50、查询12月份过生日的学生:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s_name,</span><br><span class="line">    s_birth</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">MONTH</span>(s_birth)<span class="operator">=</span><span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/b8f1/image-20200321215929799.png" class="image-20200321215929799">]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hive进阶</title>
    <url>/blog/31e5.html</url>
    <content><![CDATA[<p>最近当当网书香节，满100减50，购物车里的书迫不及待的下单买了，5折价格真香。</p>
<p>拿到手后花了约一周时间把<a href="https://u.dangdang.com/xjGKA">《Hive性能调优实战》</a>    这本看完了。</p>
<img src="/blog/31e5/image-20200505154309203.png" class="image-20200505154309203">

<p>由于最近工作中遇到Hive的优化问题，对我来说收获颇丰，让我对Hive有了更深层次的理解。书的主要内容如下：</p>
<img src="/blog/31e5/image-20200505144431706.png" class="image-20200505144431706">

<p>总结了一些对我来说比较有帮助的点：</p>
<h2 id="MUTI-INSERT写法"><a href="#MUTI-INSERT写法" class="headerlink" title="MUTI-INSERT写法"></a>MUTI-INSERT写法</h2><p>找到student_stat表中每个年龄段最早出生和最晚出生的人的出生日期，插入tp分区里：<br>正常来说会这样写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> <span class="keyword">table</span> student_stat <span class="keyword">partition</span>(tp)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	s_age,</span><br><span class="line">	<span class="built_in">min</span>(s_birth) stat,</span><br><span class="line">	<span class="string">&#x27;min&#x27;</span> tp</span><br><span class="line"><span class="keyword">from</span> student_tb_txt</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	s_age,</span><br><span class="line">	<span class="built_in">max</span>(s_birth) stat,</span><br><span class="line">	<span class="string">&#x27;max&#x27;</span> tp</span><br><span class="line"><span class="keyword">from</span> student_tb_txt</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age;</span><br></pre></td></tr></table></figure>
<p>上面的HQL会形成5个MR的job，执行过程类似这样</p>
<img src="/blog/31e5/image-20200505145600207.png" class="image-20200505145600207">


<p>正常来说，优化会把这个union all改写成两个insert,类似这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--计算max值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> student_stat <span class="keyword">partition</span>(tp)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    s_age,</span><br><span class="line">    <span class="built_in">max</span>(s_birth) stat, </span><br><span class="line">    <span class="string">&#x27;max&#x27;</span> tp</span><br><span class="line"><span class="keyword">from</span> student_tb_txt</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age;</span><br><span class="line"><span class="comment">--计算min值</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> student_stat <span class="keyword">partition</span>(tp)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">	s_age,</span><br><span class="line">	<span class="built_in">min</span>(s_birth) stat,</span><br><span class="line">	<span class="string">&#x27;min&#x27;</span> tp</span><br><span class="line"><span class="keyword">from</span> student_tb_txt</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age;</span><br></pre></td></tr></table></figure>
<p>执行过程会是下面这样，同样是两次表扫描，两次求聚合操作（存在Shuffle）并写入结果表。</p>
<img src="/blog/31e5/image-20200505145640213.png" class="image-20200505145640213">

<p>看起来优化掉了union all操作，计算max和min值的两个job可直接将数据放到student_stat下，减少了一次MapReduce作业，看似方案比较合理，但是实际执行起来反而比优化之前时间更久。其实Hive的早期版本确实可以优化，但是随着Hive版本的迭代，对union操作进行了优化，导致拆分后的代码执行效率更低了。</p>
<p>那么是否可以只经过一次Table Scan并写入呢？答案是肯定的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> student_tb_txt</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> <span class="keyword">table</span> student_stat <span class="keyword">partition</span>(tp)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    s_age,</span><br><span class="line">    <span class="built_in">min</span>(s_birth) stat,</span><br><span class="line">    <span class="string">&#x27;min&#x27;</span> tp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> student_stat <span class="keyword">partition</span>(tp)</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    s_age,</span><br><span class="line">    <span class="built_in">max</span>(s_birth) stat,</span><br><span class="line">    <span class="string">&#x27;max&#x27;</span> tp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age;</span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<img src="/blog/31e5/image-20200505150343464.png" class="image-20200505150343464">

<p>这样写就只会产生一个MR的Job，也就是说只执行了一次MapReduce作业。相比优化之前的5个Job，极大的减少了磁盘IO和网络通信，提高执行效率。</p>
<h2 id="Count-distinct-优化"><a href="#Count-distinct-优化" class="headerlink" title="Count(distinct)优化"></a>Count(distinct)优化</h2><p>统计年龄枚举值个数：<br>下意识的觉得group by去重会比distinct效率高所以会写成这样，能有效避免Reduce阶段数据倾斜</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span>(</span><br><span class="line">  <span class="keyword">select</span> s_age</span><br><span class="line">  <span class="keyword">from</span> student_tb_orc</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> s_age</span><br><span class="line">) b</span><br></pre></td></tr></table></figure>
<ul>
<li>因为去重的是s_age列，实际上业务含义表示年龄，枚举值个数非常有限，在Map阶段会对s_age去重，因此每个Map得到的s_age有限，最后到达Reduce阶段的非常有限，根本不会达到数据倾斜的量。</li>
<li>另外group by在不同版本间变动比较大，有的版本会用构建hashtable的形式去重，有的版本会通过排序的方式，排序最优时间复杂度无法到O(1) 。另外上面写法转化为两个任务，会消耗更多的磁盘网络I/O资源。</li>
</ul>
<p>所以，这样的写法有点过度优化，执行过程如下：</p>
<img src="/blog/31e5/image-20200505152946846.png" class="image-20200505152946846">


<p>如下写法是正常写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> s_age)</span><br><span class="line"><span class="keyword">from</span> student_tb_orc</span><br></pre></td></tr></table></figure>
<p>distinct的命令会在内存中构建一个hashtable，查找去重的时间复杂度是O(1)；</p>
<p>Hive 3.0中新增了count(distinct)优化，通过配置<code>set hive.optimize.countdistinct = true</code>设置，即使真的出现数据倾斜也可以自动优化，自动改变SQL执行的逻辑。</p>
<p>执行过程如下：</p>
<img src="/blog/31e5/image-20200505153005333.png" class="image-20200505153005333">

<blockquote>
<p>理透需求原则，这是优化的根本；</p>
</blockquote>
<blockquote>
<p>把握数据全链路原则，这是优化的脉络；</p>
</blockquote>
<blockquote>
<p>坚持代码的简洁原则，这让优化更加简单；</p>
</blockquote>
<blockquote>
<p>没有瓶颈时谈论优化，是自寻烦恼。</p>
</blockquote>
<h2 id="学会查看执行计划"><a href="#学会查看执行计划" class="headerlink" title="学会查看执行计划"></a>学会查看执行计划</h2><p>查看执行计划的命令：<code>explain sql</code><br>查看执行计划的扩展信息：<code>explain extended sql</code><br>执行计划包含两部分:</p>
<ol>
<li>作业的依赖关系图，即STAGE DEPENDENCIES;</li>
<li>每个作业的详细信息，即STAGE PLANS;</li>
</ol>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    s_age,</span><br><span class="line">    <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> prac.student_tb_txt</span><br><span class="line"><span class="keyword">where</span> s_age<span class="operator">&lt;</span><span class="number">30</span></span><br><span class="line"><span class="keyword">and</span> s_name <span class="keyword">like</span> <span class="string">&#x27;%红&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> s_age;</span><br></pre></td></tr></table></figure>

<p>执行计划如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STAGE DEPENDENCIES:</span><br><span class="line">  Stage-1 is a root stage</span><br><span class="line">  Stage-0 depends on stages: Stage-1</span><br><span class="line"></span><br><span class="line">STAGE PLANS:</span><br><span class="line">  Stage: Stage-1</span><br><span class="line">    Map Reduce</span><br><span class="line">      Map Operator Tree:</span><br><span class="line">          TableScan // 表扫描</span><br><span class="line">            alias: student_tb_txt</span><br><span class="line">            Statistics: Num rows: 25083517 Data size: 2709019904 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            Filter Operator</span><br><span class="line">              predicate: ((s_age &lt; 30) and (s_name like &#x27;%红&#x27;)) (type: boolean)</span><br><span class="line">              Statistics: Num rows: 4180586 Data size: 451503299 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">              Select Operator</span><br><span class="line">                expressions: s_age (type: bigint)</span><br><span class="line">                outputColumnNames: s_age</span><br><span class="line">                Statistics: Num rows: 4180586 Data size: 451503299 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                Group By Operator</span><br><span class="line">                  aggregations: count(1)</span><br><span class="line">                  keys: s_age (type: bigint)</span><br><span class="line">                  mode: hash</span><br><span class="line">                  outputColumnNames: _col0, _col1</span><br><span class="line">                  Statistics: Num rows: 4180586 Data size: 451503299 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                  Reduce Output Operator// 输出结果给Reduce</span><br><span class="line">                    key expressions: _col0 (type: bigint)</span><br><span class="line">                    sort order: +</span><br><span class="line">                    Map-reduce partition columns: _col0 (type: bigint)</span><br><span class="line">                    Statistics: Num rows: 4180586 Data size: 451503299 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                    value expressions: _col1 (type: bigint)</span><br><span class="line">      Reduce Operator Tree:// Reduce阶段</span><br><span class="line">        Group By Operator</span><br><span class="line">          aggregations: count(VALUE._col0)</span><br><span class="line">          keys: KEY._col0 (type: bigint)</span><br><span class="line">          mode: mergepartial</span><br><span class="line">          outputColumnNames: _col0, _col1</span><br><span class="line">          Statistics: Num rows: 2090293 Data size: 225751649 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">          File Output Operator</span><br><span class="line">            compressed: false</span><br><span class="line">            Statistics: Num rows: 2090293 Data size: 225751649 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            table:</span><br><span class="line">                input format: org.apache.hadoop.mapred.SequenceFileInputFormat</span><br><span class="line">                output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat</span><br><span class="line">                serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</span><br><span class="line"></span><br><span class="line">  Stage: Stage-0</span><br><span class="line">    Fetch Operator</span><br><span class="line">      limit: -1</span><br><span class="line">      Processor Tree:</span><br><span class="line">        ListSink</span><br></pre></td></tr></table></figure>

<p>STAGE DEPENDENCIES描述了作业之间的依赖关系，即Stage-0依赖Stage-1的执行结果 。Stage-1表示如下的SQL，即<code>SQL select * from prac.student_tb_txt where s_age&lt;30 and s_name like &#39;%红&#39;</code>的执行结果。</p>
<p> Stage–1分为Map和 Reduce两个阶段，对应的执行计划关键词解读如下:</p>
<ul>
<li>MapReduce:表示当前任务执行所用的计算引擎是 MapReduce</li>
<li>Map Operator Tree当前描述的Map阶段执行的操作信息。<br>Reduce Operator Tree:表示当前描述的是 Reduce阶段的操作信息。</li>
</ul>
<p>Map操作树（Map Operator Tree）信息解读如下:</p>
<ul>
<li>TableScan:表示对关键字 alias声明的结果集，这里指代 student tb orc，进行表扫描操作。</li>
<li>Statistics:表示对当前阶段的统计信息。例如，当前处理的数据行和数据量，这两个都是预估值。</li>
<li>Filter Operator:表示在之前操作(TableScan)的结果集上进行数据的过滤</li>
<li>predicate:表示 filter Operator进行过滤时，所用的谓词，即s＿age&lt;30 and s_e like ‘’％红％’’。</li>
<li>Select Operator:表示在之前的结果集上对列进行投影，即筛选列。</li>
<li>expressions:表示需要投影的列，即筛选的列。</li>
<li>outputColumnNames:表示输出的列名。</li>
</ul>
<ul>
<li>Group By Operator:表示在之前的结果集上分组聚合。</li>
<li>aggregations:表示分组聚合使用的算法，这里是 count(1)。</li>
<li>keys:表示分组的列，在该例子表示的是s＿age</li>
<li>Reduce output Operator:表示当前描述的是对之前结果聚会后的输出信息，这里表示Map端聚合后的输出信息。</li>
<li>key expressions/value expressions: MapReduce计算引擎，在Map阶段和 Reduce阶段输出的都是键-值对的形式，这里 key expression value expressions分别描述的就是Map阶段输出的键(key)和值(value)所用的数据列这里的例子 key expressions指代的就是s＿age列， value expressions指代的就是 count(1)列。</li>
<li>sort order:表示输出是否进行排序，+表示正序，-表示倒序。</li>
<li>Map- -reduce partition columns:表示Map阶段输出到 Reduce阶段的分区列，在Hive-SQL中，可以用 distribute by指代分区的列。</li>
<li>Reduce阶段所涉及的关键词与Map阶段的关键词是一样的，字段表示含义也相同，<br>因此这里不再罗列。下面是 Reduce中出现但是在Map阶段没有出现的关键词。</li>
<li>compressed:在 File Output Operator中这个关键词表示文件输出的结果是否进行压缩， false表示不进行输出压缩。</li>
<li>table:表示当前操作表的信息。</li>
<li>input format/output format:分别表示文件输入和输出的文件类型。</li>
<li>serde:表示读取表数据的序列化和反序列化的方式。</li>
</ul>
<h2 id="开启map端聚合"><a href="#开启map端聚合" class="headerlink" title="开启map端聚合"></a>开启map端聚合</h2><p>关闭map端聚合的情况下，普通Group by 的执行计划</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.map.aggr<span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">explain</span><br><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> id,name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STAGE DEPENDENCIES:</span><br><span class="line">  Stage-1 is a root stage</span><br><span class="line">  Stage-0 depends on stages: Stage-1</span><br><span class="line"></span><br><span class="line">STAGE PLANS:</span><br><span class="line">  Stage: Stage-1</span><br><span class="line">    Map Reduce</span><br><span class="line">      Map Operator Tree:</span><br><span class="line">          TableScan</span><br><span class="line">            alias: students</span><br><span class="line">            Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            Select Operator</span><br><span class="line">              expressions: id (type: string), name (type: string)</span><br><span class="line">              outputColumnNames: id, name</span><br><span class="line">              Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">              Reduce Output Operator</span><br><span class="line">                key expressions: id (type: string), name (type: string)</span><br><span class="line">                sort order: ++</span><br><span class="line">                Map-reduce partition columns: id (type: string), name (type: string)</span><br><span class="line">                Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">      Reduce Operator Tree:</span><br><span class="line">        Group By Operator</span><br><span class="line">          keys: KEY._col0 (type: string), KEY._col1 (type: string)</span><br><span class="line">          mode: complete</span><br><span class="line">          outputColumnNames: _col0, _col1</span><br><span class="line">          Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">          File Output Operator</span><br><span class="line">            compressed: false</span><br><span class="line">            Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            table:</span><br><span class="line">                input format: org.apache.hadoop.mapred.SequenceFileInputFormat</span><br><span class="line">                output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat</span><br><span class="line">                serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</span><br><span class="line"></span><br><span class="line">  Stage: Stage-0</span><br><span class="line">    Fetch Operator</span><br><span class="line">      limit: -1</span><br><span class="line">      Processor Tree:</span><br><span class="line">        ListSink</span><br></pre></td></tr></table></figure>
<p>可以看到Group by操作在Reduce阶段，模式为complete。</p>
<p>下面开启map端聚合测试普通的Group by</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">hive<span class="operator">&gt;</span> <span class="keyword">set</span> hive.map.aggr<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line">hive<span class="operator">&gt;</span> explain</span><br><span class="line">    <span class="operator">&gt;</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> id,name;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STAGE DEPENDENCIES:</span><br><span class="line">  Stage-1 is a root stage</span><br><span class="line">  Stage-0 depends on stages: Stage-1</span><br><span class="line"></span><br><span class="line">STAGE PLANS:</span><br><span class="line">  Stage: Stage-1</span><br><span class="line">    Map Reduce</span><br><span class="line">      Map Operator Tree:</span><br><span class="line">          TableScan</span><br><span class="line">            alias: students</span><br><span class="line">            Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            Select Operator</span><br><span class="line">              expressions: id (type: string), name (type: string)</span><br><span class="line">              outputColumnNames: id, name</span><br><span class="line">              Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">              Group By Operator</span><br><span class="line">                keys: id (type: string), name (type: string)</span><br><span class="line">                mode: hash</span><br><span class="line">                outputColumnNames: _col0, _col1</span><br><span class="line">                Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">                Reduce Output Operator</span><br><span class="line">                  key expressions: _col0 (type: string), _col1 (type: string)</span><br><span class="line">                  sort order: ++</span><br><span class="line">                  Map-reduce partition columns: _col0 (type: string), _col1 (type: string)</span><br><span class="line">                  Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">      Reduce Operator Tree:</span><br><span class="line">        Group By Operator</span><br><span class="line">          keys: KEY._col0 (type: string), KEY._col1 (type: string)</span><br><span class="line">          mode: mergepartial</span><br><span class="line">          outputColumnNames: _col0, _col1</span><br><span class="line">          Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">          File Output Operator</span><br><span class="line">            compressed: false</span><br><span class="line">            Statistics: Num rows: 1 Data size: 22 Basic stats: COMPLETE Column stats: NONE</span><br><span class="line">            table:</span><br><span class="line">                input format: org.apache.hadoop.mapred.SequenceFileInputFormat</span><br><span class="line">                output format: org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat</span><br><span class="line">                serde: org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe</span><br><span class="line"></span><br><span class="line">  Stage: Stage-0</span><br><span class="line">    Fetch Operator</span><br><span class="line">      limit: -1</span><br><span class="line">      Processor Tree:</span><br><span class="line">        ListSink</span><br></pre></td></tr></table></figure>
<p>可以看到Group by操作被提到了Map阶段，模式为 <strong>hash</strong>，而在Reduce阶段，同样进行了一次Group by操作，但这次的模式为<strong>mergepartial</strong>，也就是把Map阶段和结果合并起来。</p>
<p>[1]林志煌.Hive性能调优实战[E]机械工业出版社,2020.01 </p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Hive的UDF函数</title>
    <url>/blog/d960.html</url>
    <content><![CDATA[<p>Hive中给了很多系统函数，<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF" target="_blank">官网</a> 给了很多函数可以参考。但是复杂的业务中，官方函数并不一定能满足特定化的需求，这时可以自定义函数来满足需求。</p>
<p>参考：官网中的关于UDF部分的<a href="https://cwiki.apache.org/confluence/display/Hive/HivePlugins" target="_blank">链接</a></p>
<h3 id="1-在IDEA中创建一个项目，配置pom-xml-添加依赖如下："><a href="#1-在IDEA中创建一个项目，配置pom-xml-添加依赖如下：" class="headerlink" title="1.  在IDEA中创建一个项目，配置pom.xml 添加依赖如下："></a>1.  在IDEA中创建一个项目，配置pom.xml 添加依赖如下：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建一个类，例如创建一个把字符串全部转换为小写的UDF"><a href="#2-创建一个类，例如创建一个把字符串全部转换为小写的UDF" class="headerlink" title="2. 创建一个类，例如创建一个把字符串全部转换为小写的UDF"></a>2. 创建一个类，例如创建一个把字符串全部转换为小写的UDF</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: UDF函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 09:13</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lower</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span> <span class="params">(String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-打jar包，把jar包放在-opt-local-hive-lib"><a href="#3-打jar包，把jar包放在-opt-local-hive-lib" class="headerlink" title="3. 打jar包，把jar包放在 /opt/local/hive/lib"></a>3. 打jar包，把jar包放在 /opt/local/hive/lib</h3><p>这一步就不在赘述，默认大家都会</p>
<h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><p>CDH<a href="https://docs.cloudera.com/documentation/enterprise/latest/topics/cm_mc_hive_udf.html#hive-aux-jars-dir" target="_blank">官网</a>写的在hive-site.xml中配置<code>hive.aux.jars.path</code>，但是我配置完后并没有生效，不过官网写</p>
<blockquote>
<p> The directory location is set in the environment as <code>HIVE_AUX_JARS_PATH</code> and will generally override the <code>hive.aux.jars.path</code> property set in XML files, even if <code>hive.aux.jars.path</code> is set in an advanced configuration snippet.</p>
</blockquote>
<p>意思就是环境变量的优先级要高于XML，所以建议直接配置环境变量。</p>
<p>在root用户下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile.d/hive.sh </span><br><span class="line"><span class="comment"># 添加如下内容并保存</span></span><br><span class="line"><span class="built_in">export</span> HIVE_AUX_JARS_PATH=/opt/local/hive/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_AUX_JARS_PATH</span></span><br></pre></td></tr></table></figure>

<p>执行<code>source /etc/profile</code>刷新环境变量。</p>
<h3 id="5-进入hive-cli中，创建函数"><a href="#5-进入hive-cli中，创建函数" class="headerlink" title="5. 进入hive-cli中，创建函数"></a>5. 进入hive-cli中，创建函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hive (default)&gt; create <span class="keyword">function</span> mylower as <span class="string">&quot;tech.mapan.hive.Lower&quot;</span>;</span><br><span class="line">OK</span><br><span class="line">Time taken: 0.285 seconds</span><br><span class="line"></span><br><span class="line">hive (default)&gt;  select mylower(<span class="string">&quot;HELLO WORLD&quot;</span>);</span><br><span class="line">OK</span><br><span class="line">_c0</span><br><span class="line">hello world</span><br><span class="line">Time taken: 0.18 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>

<p>这样就向系统添加了一个函数 mylower(), 退出hive-cli再次进入依然生效。</p>
<hr>
<p>随手写了几个常用的UDF函数:</p>
<ul>
<li>输入两个数，输出按位与的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 按位与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 12:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitAnd</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        String result;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="literal">null</span> ||b==<span class="literal">null</span>)&#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(a);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(b);</span><br><span class="line">            result = Integer.toString(i &amp; j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>输入几个数，找出这些数中最大的数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 求一组数中的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 12:49</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Greatest</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String... strings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[strings.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : strings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i++] = Integer.parseInt(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; max) &#123;</span><br><span class="line">                max = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>地址脱敏</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 地址脱敏, 对长度超过15个字符串, 只保留前15个字符, 不超过15个则不截取, 全部返回。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 11:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaskAddress</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.length() &gt; <span class="number">15</span>) &#123;</span><br><span class="line">            result = s.substring(<span class="number">0</span>, <span class="number">14</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>邮箱脱敏</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 邮箱脱敏，@后面全部换成*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 13:19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaskMail</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String[] split = s.split(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">            res = split[<span class="number">0</span>] + <span class="string">&quot;@*****&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>单号脱敏</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 单号脱敏，保留头部尾部各两位，其他全部换成*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 13:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaskNo</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = s.substring(<span class="number">0</span>, <span class="number">2</span>) + <span class="string">&quot;****&quot;</span> + s.substring(s.length() - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>手机号脱敏</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package tech.mapan.hive;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @program: UDF</span><br><span class="line"> * @description: 手机号码脱敏，手机号码后6位换成*</span><br><span class="line"> * @author: MaPan</span><br><span class="line"> * @create: 2020-03-22 13:08</span><br><span class="line"> **/</span><br><span class="line">public class MaskPhone extends UDF &#123;</span><br><span class="line">    public String evaluate(String s) &#123;</span><br><span class="line">        String res = &quot;&quot;;</span><br><span class="line">        if (s == null) &#123;</span><br><span class="line">            res = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res = s.substring(0, 5) + &quot;******&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>性别归一化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan.hive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.exec.UDF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: UDF</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 性别归一化，不同的系统中的性别不同有的是男和女，有的是F和M有的是1和0，针对不同的性别表示方式进行归一化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MaPan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-03-22 13:47</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenderETL</span> <span class="keyword">extends</span> <span class="title class_">UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">evaluate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            res = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(<span class="string">&quot;男&quot;</span>) || s.equals(<span class="string">&quot;M&quot;</span>) || s.equals(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                res = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">&quot;女&quot;</span>) || s.equals(<span class="string">&quot;F&quot;</span>) || s.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                res = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>附：jar包<a href="d960/UDF-1.0-SNAPSHOT.jar" target="_blank">下载</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Hive的一次踩坑[2]</title>
    <url>/blog/9af.html</url>
    <content><![CDATA[<p>记录一次可以稳定复现的Hive的Bug。如果是在生产环境，一定要注意规避。<br>首先准备数据，建表、插入数据一气呵成。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> temp_101 (id string, name string,come_date string,go_date string) <span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\001&#x27;</span> stored <span class="keyword">as</span> orc;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_101 <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;1001&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;2020-01-01 09:15:26&#x27;</span>,<span class="string">&#x27;2020-02-12 12:25:29&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1002&#x27;</span>,<span class="string">&#x27;Mike&#x27;</span>,<span class="string">&#x27;2020-02-07 18:15:26&#x27;</span>,<span class="string">&#x27;2020-03-18 11:02:15&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1003&#x27;</span>,<span class="string">&#x27;Jhon&#x27;</span>,<span class="string">&#x27;2020-03-15 15:15:26&#x27;</span>,<span class="string">&#x27;2020-05-20 15:21:42&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这里插入了三条数据，可以有<strong>id</strong>，<strong>姓名</strong>，<strong>到来时间</strong>和<strong>离开时间</strong>，共4个字段。</p>
<p>查一下数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_101;</span><br></pre></td></tr></table></figure>

<img src="/blog/9af/image-20200527201128911.png" class="image-20200527201128911">

<p>假设有一个需求是，找到 2020年5月20号 离开的人的相关信息，那么SQL可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from temp_101 where date(go_date)=&#x27;2020-05-20&#x27;;</span><br></pre></td></tr></table></figure>

<p>在HUE中显示如下，可以发现go_date这个字段的时分秒不显示了。难道是HUE的问题？</p>
<img src="/blog/9af/image-20200527201333957.png" class="image-20200527201333957">

<p>去Hive-Cli中执行，发现同样如此。</p>
<img src="/blog/9af/image-20200527201626965.png" class="image-20200527201626965">

<p>那么基本可以确定这是Hive中的一个Bug（也许是Feature），暂时看怎么解决吧。</p>
<ul>
<li>尝试使用to_date替换date</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_101 <span class="keyword">where</span> to_date(go_date)<span class="operator">=</span><span class="string">&#x27;2020-05-20&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img src="/blog/9af/image-20200527201837107.png" class="image-20200527201837107">



<ul>
<li>尝试使用substring代替date</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp_101 <span class="keyword">where</span> <span class="built_in">substring</span>(go_date,<span class="number">1</span>,<span class="number">10</span>)<span class="operator">=</span><span class="string">&#x27;2020-05-20&#x27;</span>;</span><br></pre></td></tr></table></figure>



<img src="/blog/9af/image-20200527202021174.png" class="image-20200527202021174">

<p>上面两种改写都是OK的</p>
<p>上谷歌翻了一圈，确认是Hive的一个至今为解决的Bug，地址在这</p>
<p><a href="https://issues.apache.org/jira/browse/HIVE-22513">https://issues.apache.org/jira/browse/HIVE-22513</a></p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/blog/a77d.html</url>
    <content><![CDATA[<p>在学习Java的最初阶段，我们应该都写过一个猜数字的小程序，随机生成一个数字，让我们输入来猜，其实里面就用到了二分查找的思想。</p>
<img src="/blog/a77d/binarysearch.png" class="binarysearch">

<p>二分查找的思想：</p>
<ol>
<li>首先确定该数组的中间下表 mid = (left+right)/2；</li>
<li>然后让需要查找的数findVal和arr[mid]比较；</li>
<li>若findVal&gt;arr[mid],说明要查找的数在mid的右边，因此需要递归的向右查找；</li>
<li>若findVal&lt;arr[mid],说明要查找的数在mid的左边，因此需要递归的向左查找；</li>
<li>若findVal==arr[mid],说明要查找的数找到，就返回。</li>
</ol>
<p>结束递归条件:</p>
<ol>
<li>找到要查找的数，结束递归</li>
<li>递归完整个数组，仍然没有找到findVal,也需要结束递归，此时left&gt;right</li>
</ol>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     要查找的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下边，如果没有找到就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>PostgreSql学习</title>
    <url>/blog/2c3f.html</url>
    <content><![CDATA[<h2 id="数据库安装"><a href="#数据库安装" class="headerlink" title="数据库安装"></a>数据库安装</h2><p>生产环境几乎都是在Linux下，所以PostgreSQL就安装到Linux环境下，我的虚拟机是CentOS 7</p>
<p>直接参考官网的安装教程，打开官网<a href="https://www.postgresql.org/download/linux/redhat/">https://www.postgresql.org/download/linux/redhat/</a></p>
<p>安装比较稳定的9.5版本</p>
<ul>
<li><strong>Install the repository RPM:</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Install the client packages:</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install postgresql95</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Optionally install the server packages:</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install postgresql95-server</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Optionally initialize the database and enable automatic start:</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/pgsql-9.5/bin/postgresql95-setup initdb</span><br><span class="line">systemctl <span class="built_in">enable</span> postgresql-9.5</span><br><span class="line">systemctl start postgresql-9.5</span><br></pre></td></tr></table></figure>

<h2 id="客户端安装："><a href="#客户端安装：" class="headerlink" title="客户端安装："></a>客户端安装：</h2><p>我选择的是Dbeaver,免费强大，界面友好。官网<a href="https://dbeaver.io/">https://dbeaver.io/</a></p>
<p>下载社区免安装版，即开即用。</p>
<p>为了在windows下连接上数据库，踩了两个坑，花了点时间琢磨了一下。</p>
<p>Win下一直报连接被拒绝，应该是类是mysql中的白名单制，找到配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /var/lib/pgsql/9.5/data/postgresql.conf</span><br></pre></td></tr></table></figure>

<p>找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#listen_addresses = &#x27;localhost&#x27;    #what IP address(es) to listen on;</span><br></pre></td></tr></table></figure>

<p>在下面添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>保存并退出。</p>
<p>然后修改pg_hba.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /var/lib/pgsql/9.5/data/pg_hba.conf</span><br></pre></td></tr></table></figure>

<p>找到如下两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1/32            ident</span><br></pre></td></tr></table></figure>

<p>在下面添加一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">host    all             all             192.168.100.1/24        md5</span><br></pre></td></tr></table></figure>

<p>保存然后重启postgreSQL服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart postgresql-9.5</span><br></pre></td></tr></table></figure>

<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>postgres用户是postgreSQL的最高权限用户，安装时自动创建的。使用Shell命令行,切换到postgres用户下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su - postgres</span><br></pre></td></tr></table></figure>

<p>进入控制台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">psql</span><br></pre></td></tr></table></figure>

<p>为postgres用户设置一个密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\password postgres</span><br></pre></td></tr></table></figure>

<p>输入两次密码即可。</p>
<p>创建数据库，例如创建mydb,这里就是标准数据库语法了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASES mytbl;</span><br></pre></td></tr></table></figure>

<p>更新中…</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>从源码看HBase的写入流程</title>
    <url>/blog/d6ca.html</url>
    <content><![CDATA[<p>最近在看HBase，琢磨了一下HBase的写入流程，我的测试环境安装的HBase版本是2.1.0-cdh6.3.2，那么直接在IDEA配置好POM文件，下载对应版本的Jar包和文档，找到<code>org.apache.hadoop.hbase.regionserver.HRegion.java</code>，开撕源码。<br>可以找到源码中关于这部分的注释比较清晰明了：</p>
<blockquote>
<p>STEP 1. Try to acquire as many locks as we can and build mini-batch of operations with<br>  locked rows</p>
</blockquote>
<blockquote>
<p>STEP 2. Update mini batch of all operations in progress with  LATEST_TIMESTAMP timestamp<br>We should record the timestamp only after we have acquired the rowLock,<br>otherwise, newer puts/deletes are not guaranteed to have a newer timestamp</p>
</blockquote>
<blockquote>
<p>STEP 3. Build WAL edit</p>
</blockquote>
<blockquote>
<p>STEP 4. Append the WALEdits to WAL and <strong>SYNC</strong>.</p>
</blockquote>
<blockquote>
<p>STEP 5. Write back to memStore</p>
</blockquote>
<blockquote>
<p>STEP 6. Complete MiniBatchOperations: If required calls postBatchMutate() CP hook and<br>complete mvcc for last writeEntry</p>
</blockquote>
<blockquote>
<p>STEP 7. Apply to memstore</p>
</blockquote>
<p>首先HBase首先获取一些锁，在导入的包中，可以发现<code>import java.util.concurrent.locks.Lock;</code><br>不难看出这里的获取的锁是JUC的锁。</p>
<p>然后构建<code>mini-batch</code>，并使用最后的时间戳来更新mini-batch；</p>
<p>把操作追加到WAL并且<strong>同步</strong>。</p>
<p>再写入menStore，写入成功以后才在Finally中释放锁。</p>
<p>Hbase2.1.0版本与1.3.1版本相比，有了不少的改进：</p>
<ol>
<li>加入了mini-batch，每次更新是针对小批量的操作，提高了整体的吞吐率；</li>
<li>WAL的同步时机不同，在1.3.1版本中是先写入WALedits，再写入memStore，最后才对WAL进行同步，在2.1.0版本中的顺序变成了先写WAL并同步，然后再写memStore。在2.1.0的顺序更加符合我们的逻辑，理解起来也更简单。</li>
</ol>
<p>总结一下HBase的写入逻辑：</p>
<ol>
<li>Client先访问zookeeper，获取hbase:meta表位于哪个Region Server。</li>
<li>访问对应的Region Server，获取hbase:meta表，根据读请求的namespace:table/rowkey，查询出目标数据位于哪个Region Server中的哪个Region中。并将该table的region信息以及meta表的位置信息缓存在客户端的meta cache，方便下次访问。</li>
<li>与目标Region Server进行通讯；</li>
<li>将数据顺序追加到WAL；</li>
<li>将数据写入对应的MemStore，数据会在MemStore进行排序；</li>
<li>向客户端发送ack；</li>
<li>等达到MemStore的刷写时机后，将数据刷写到HFile。</li>
</ol>
<p>看过源码之后，对于HBase的写入有了更深入的认识。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
  </entry>
  <entry>
    <title>三大经典排序</title>
    <url>/blog/846c.html</url>
    <content><![CDATA[<p>2018年Coding被腾讯收购后变成了腾讯开发者平台，一直不温不火。今年一月份有又要改名为新Coding，真是命途多舛，还好提供的服务一直可以满足我的需求。虽然偶尔服务器宕机，但是速度快呀，Coding pages还是真香。由于今年网站再次改版，之前的pages要停止服务了，貌似也没有通知一声，昨天修复了一下，看了下留言，我的小站还是有人浏览的。所以决定还是要好好经营下去。</p>
<p>最近看了一些书，有了一些新的感悟。学习是要有输出的，只有自己能把一个东西讲清楚才算真正学会了，那么就把最近研究和学习的一些东西给写下来吧。</p>
<h1 id="大学学过的一些很基础的排序算法"><a href="#大学学过的一些很基础的排序算法" class="headerlink" title="大学学过的一些很基础的排序算法"></a>大学学过的一些很基础的排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>掌握一种算法不是把它的实现代码给背下来，而是理解他的思想。这样就可以做到以不变应万变。<br>冒泡排序的思想是：在一个n个数的乱序数组中，遍历整个数组(n-1)轮，每次遍历位数减少1，每次选择出一个最大的数放在数组的末尾，这样在经过(n-1)轮遍历之后，数组中所有的元素都是有序的。<br>原理：</p>
<img src="/blog/846c/e9011afacb434ea09c8a156dc9983bfb.gif" class="冒泡排序">

<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i) + <span class="string">&quot;趟排序:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我使用了一个不引入第三个变量，实现交换两个变量的值的技巧，一个数对另一个数进行两次异或运算得到的结果是这个数本身，交换a和b的值的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>那么不管是最好的情况还是最坏的情况，实际判断的次数是不会减少的，是否可以优化呢？答案是肯定的，如果在最好的情况下，可以发现，在第一趟排序中所有的数都没有发生交换。<br>所以可以进行如下优化，当在一轮遍历中，如果没有两个数进行交换，就可以认为整体数组是有序的，优化之后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>] ^ arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + (i) + <span class="string">&quot;趟排序:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 在一趟排序中，若没有发生过交换，说明已经排好序了。</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序相对冒泡排序而言，交换的次数减少了，所以效率也提高了一些。选择排序的思想是：<br>经过(n-1)轮遍历，依次找到每个位置上该放的值。第1次遍历找到最小的值a，把它当到第一位；第2次遍历找到除最小值a以外的最小值b，把它放到第二位··· 直到(n-1)次遍历，找到最小值把它放到(n-1)位，即第倒数二位。此时数组为全局有序。<br>原理：</p>
<img src="/blog/846c/0d74357a85fb419da3fc60219b2172ac.gif" class="选择排序">

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 选择排序 时间复杂度O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>选择排序的思想是找位置，与选择排序不同，插入排序的思想是找一个有序的区间，保证这个区间内是有序的。通过一次次的遍历，逐渐扩大这个有序区间，直到区间大小等于数组大小，即数组全局有序。所谓逐渐扩大，即把待插入的数，插入到有序区间内属于这个数的恰当位置。</p>
<p>原理：</p>
<img src="/blog/846c/1167a023cbec4da0aa056ca481104d16.gif" class="插入排序">

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义待插入的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">//即arr[i]前面这个数的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给insertVal找到插入的位置</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1.insertIndex &gt;= 0保证在给insertVal找插入位置，不越界</span></span><br><span class="line">        <span class="comment">//2.insertVal &lt; arr[insertIndex]待插入的数，还没有找到插入位置</span></span><br><span class="line">        <span class="comment">//3.就需要将arr[insertIndex]后移</span></span><br><span class="line">        <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">            insertIndex--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当退出while循环时，说明插入的位置找到，insertIndex + 1</span></span><br><span class="line">        arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;轮插入&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/blog/3c6c.html</url>
    <content><![CDATA[<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的思想是按照下标的一定增量分组，对魅族使用直接插入排序算法进行排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减少到1时，整个文件恰好被分成一组，算法终止。<br>简单来说就是按照一定步长分组，例如100个数排序，第一次分50组，每组两个数，第二次分25组，每组4个数，第三次分12组，第四次分6组，第五次分3组，第六次分1组。每一次分组后在组内进行排序。</p>
<p>排序流程：</p>
<img src="/blog/3c6c/srg453d.gif" class="希尔排序">

<p>代码实现：</p>
<p>首先分组，然后使用交换法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个循环，对数组进行分组，直到gap=1为止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//交替遍历所有组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 组内排序，使用交换法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                    arr[j] = arr[j] ^ arr[j + gap];</span><br><span class="line">                    arr[j + gap] = arr[j] ^ arr[j + gap];</span><br><span class="line">                    arr[j] = arr[j] ^ arr[j + gap];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用交换法，每次对比都要进行交换，效率比较低，内部排序的方式可以修改成直接插入排序。</p>
<p>分组，然后插入法（希尔排序）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个循环，对数组进行分组，直到gap=1为止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 交替遍历所有的组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                <span class="comment">// 移动数据，等待插入</span></span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到待插入的位置，插入数据</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序是对直接插入排序的更高效的改进版本，</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>常见错误总结(Hive)</title>
    <url>/blog/f7df.html</url>
    <content><![CDATA[<h2 id="开发中常见错误总结"><a href="#开发中常见错误总结" class="headerlink" title="开发中常见错误总结"></a>开发中常见错误总结</h2><ul>
<li>1、开发时仔细检查脚本，避免低级错误，比如缺少逗号，有重复字段，脚本文件保存的不是UTF8无BOM，或不是UNIX格式，Tab没有转为空格等；</li>
</ul>
<img src="/blog/f7df/image-20200526215250522.png" class="image-20200526215250522">

<ul>
<li><p>2、注意一些Hive性能参数的设置，比如 MapJoin的打开、并行、动态分区的打开，还要防止数据倾斜、迪卡尔积，特别是不要数据倾斜；</p>
</li>
<li><p>3、Job运行失败并且不出现日志，检查是否是脚本文件名有中文或有空格；</p>
</li>
</ul>
<ul>
<li>4、Job运行慢，检查是数据倾斜还是资源不够的原因，如果进度在99％半小时还没动就考虑是数据倾斜了，如果 MapReduce运行进度很均匀但是很慢，要看日志，包括Map的日志和Reduce志和的日志，看每个map或Reduce的start的时间间隔是否很长，如果很长则考虑是资源不够。如果elapsed时间内有很长的 tasks，且时间不均匀，则考虑是数据倾斜了；</li>
</ul>
<ul>
<li>5、在配置任务调度的时候，需要确认被依赖的任务在任务调度平台上是否存在。依赖任务的跑数时间是否满足自己的需求，比如可能会出现上游表本身跑数时间设置比较晚，导致我们的作业等待时间长。</li>
</ul>
<ul>
<li>6、如果正常调度任务显示已完成，但结果表中没有数据，手工下发任务重新跑数后，数据正常。则可以断定任务依赖配置有问题，依赖任务配置少了。</li>
</ul>
<hr>
<p>未完待续</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/blog/f8df.html</url>
    <content><![CDATA[<p>归并排序采用经典的分治策略，利用归并的思想实现的排序方法。把一个待排序的数组无限拆分，直到子数组只有一个元素，然后开始按顺序再进行合并。想象一下若一副扑克牌乱序混在一起，如何从小到大排序？</p>
<ol>
<li>把牌堆分层两份，分给两个小伙伴进行从小到大排序。</li>
<li>两位小伙伴排序完成，给到有序牌堆A和有序牌堆B。</li>
<li>每次抽取两个牌堆最顶端一张进行比较，较小的合入到整体有序的牌堆C中。</li>
</ol>
<p>那么两个小伙伴是如何把分到的扑克牌给排序完成的呢？</p>
<ol>
<li><p>把牌堆分层两份，分给两个小伙伴进行从小到大排序。</p>
</li>
<li><p>两位小伙伴排序完成，给到有序牌堆A和有序牌堆B。</p>
</li>
<li><p>每次抽取两个牌堆最顶端一张进行比较，较小的合入到整体有序的牌堆C中。</p>
</li>
</ol>
<p>那么两个小伙伴是如何把分到的扑克牌给排序完成的呢？</p>
<p>重复步骤1-3 ···</p>
<p>当某次分牌时，某两位小伙伴各自仅分到了一张牌，那就不能再继续分了，他俩把分到的牌按照大小顺序交上去，这样就有了有序的牌堆（2张牌），然后2张合4张，4张合8张···，到最后整副扑克牌都是有序的。</p>
<p>这就是归并的思想</p>
<img src="/blog/f8df/MergeSrot.png" class="MergeSrot">

<p>动图理解：</p>
<img src="/blog/f8df/2346780.gif" class="2346780">

<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr  带排序的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low  数组中较低的一侧的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high 数组中较高的一侧的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (high + low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 处理左边</span></span><br><span class="line">        mergeSort(arr, low, middle);</span><br><span class="line">        <span class="comment">// 处理右边</span></span><br><span class="line">        mergeSort(arr, middle + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 合并左右两边</span></span><br><span class="line">        merge(arr, low, middle, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待归并的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low    左侧数组起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> middle 左侧数组的结束位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high   右侧数组结束位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> middle, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="comment">// 用于存储归并后的临时数组</span></span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录第一个数组中需要遍历的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="comment">// 记录第二个数组中需要遍历的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> middle + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 用于记录在临时数组中存放的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[index++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个数组中的数已经全部放入temp,剩下较长的一个子数组的数全部放进temp中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">        temp[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把临时数组中的数据重新存入原来数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">        arr[k + low] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/blog/2c2a.html</url>
    <content><![CDATA[<p>快速排序是对冒泡排序的一种改进，快速思想是使用分治法，其中有一个基准值，把一个数组中的数分为较基准值大和较基准值小的两部分（子数组），所有比基准值大的放在基准值后面，所有比基准值小的放在基准值前面，然后递归再次切分，直至子数组的大小为1或0，此时全局有序。</p>
<p>图示：</p>
<img src="/blog/2c2a/7789414-007520d3d4a7610c.gif" class="7789414-007520d3d4a7610c">





<p>快速排序是不稳定的排序，在排序后，相同值的先后顺序可能会变化，所以是不稳定的。</p>
<p>所谓是稳定性是指：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>代码实现：</p>
<p>Java版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[low] = arr[high];</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[high] = arr[low];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[low] = pivot;</span><br><span class="line">        quickSort(arr, left, low - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, low + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala版本：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], left: <span class="type">Int</span>, right: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">var</span> low = left</span><br><span class="line">    <span class="keyword">var</span> high = right</span><br><span class="line">    <span class="keyword">val</span> pivot = arr(low)</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">      <span class="keyword">while</span> (low &lt; high &amp;&amp; arr(high) &gt;= pivot) high -= <span class="number">1</span></span><br><span class="line">      arr(low) = arr(high)</span><br><span class="line">      <span class="keyword">while</span> (low &lt; high &amp;&amp; arr(low) &lt;= pivot) low += <span class="number">1</span></span><br><span class="line">      arr(high) = arr(low)</span><br><span class="line">    &#125;</span><br><span class="line">    arr(low) = pivot</span><br><span class="line">    quickSort(arr, low + <span class="number">1</span>, right)</span><br><span class="line">    quickSort(arr, left, low - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在网上看了不少人的快速排序代码，其整体思想都是一样的，分治，递归。但是具体实现细节上则各不相同，八仙过海，大显神通。上面代码是我觉得比较好简洁，且理解相对容易的一种写法。另外Scala版本有一个十分精简的写法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span></span>(list: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = list <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">List</span>()</span><br><span class="line">    <span class="keyword">case</span> head :: tail =&gt;</span><br><span class="line">      <span class="keyword">val</span> (left, right) = tail.partition(_ &lt; head)</span><br><span class="line">      quickSort(left) ::: head :: quickSort(right)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Scala这么优雅的语言，真的让人赏心悦目。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>文言文生成器</title>
    <url>/blog/aa33.html</url>
    <content><![CDATA[<p>在Freenom注册了几个免费域名，域名必须正常使用状态才可以免费使用，否则有可能被官方强制收回。所以就用Scala写了这个小项目，用来生成符合Hexo标准的Markdown文章，使用Hexo渲染层HTML后，把网站文件上传到Github并绑定域名，这样就算域名是正常使用了。</p>
<p>首先从网上找了一个词典的文件，可以看到这个词典文件每一行是一个词，有三列，分别是词语，拼音，编号。我们需要的仅仅是词，拼音和编号可以抛弃不用。</p>
<img src="/blog/aa33/image-20200530120155177.png" class="image-20200530120155177">

<p>实际思路是，把每一行放在作为一个元素放在一个List中，然后单个元素按照’\t’分隔，取第一个元素，其他的丢弃。这样就组成了一个List词典，只需要随机取用即可。实现代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = <span class="type">TitleMock</span>.getClass.getResourceAsStream(<span class="string">&quot;/1.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剥离出词语组成一个List</span></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">Source</span>.fromInputStream(stream)(<span class="string">&quot;UTF8&quot;</span>).getLines.toList.map &#123;</span><br><span class="line">    f =&gt; &#123;</span><br><span class="line">        f.split(<span class="string">&quot;\t&quot;</span>).toList.head</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是文言文那肯定离不开之乎者也这类的虚词，找了一些虚词放到数组中:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="string">&quot;而&quot;</span>, <span class="string">&quot;何&quot;</span>, <span class="string">&quot;乎&quot;</span>, <span class="string">&quot;乃&quot;</span>, <span class="string">&quot;其&quot;</span>, <span class="string">&quot;且&quot;</span>, <span class="string">&quot;然&quot;</span>, <span class="string">&quot;若&quot;</span>, <span class="string">&quot;所&quot;</span>, <span class="string">&quot;为&quot;</span>, <span class="string">&quot;焉&quot;</span>, <span class="string">&quot;也&quot;</span>, <span class="string">&quot;以&quot;</span>, <span class="string">&quot;矣&quot;</span>, <span class="string">&quot;于&quot;</span>, <span class="string">&quot;之&quot;</span>, <span class="string">&quot;则&quot;</span>, <span class="string">&quot;者&quot;</span>, <span class="string">&quot;与&quot;</span>, <span class="string">&quot;欤&quot;</span>, <span class="string">&quot;因&quot;</span>, <span class="string">&quot;兮&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>把实词和虚词拼接，组成句子，句子组成段落，段落组成文章。关键实现如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (j &lt;- <span class="number">1</span> to para) &#123;</span><br><span class="line">    <span class="keyword">var</span> article: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">        article += list(math.abs(<span class="type">Random</span>.nextInt) % shiSize) + array(math.abs(<span class="type">Random</span>.nextInt) % xuSize)</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">100</span> &amp;&amp; math.abs(<span class="type">Random</span>.nextInt) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (math.abs(<span class="type">Random</span>.nextInt) % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            article += <span class="string">&quot;，&quot;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            article += <span class="string">&quot;。&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    article = prefix + article + suffix + <span class="string">&quot;\n\n&quot;</span></span><br><span class="line">    cont += article</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成文章的标题：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文言文虚词</span></span><br><span class="line"><span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(<span class="string">&quot;论&quot;</span>, <span class="string">&quot;行&quot;</span>, <span class="string">&quot;说&quot;</span>, <span class="string">&quot;颂&quot;</span>, <span class="string">&quot;学&quot;</span>, <span class="string">&quot;经&quot;</span>, <span class="string">&quot;序&quot;</span>, <span class="string">&quot;辞&quot;</span>, <span class="string">&quot;铭&quot;</span>, <span class="string">&quot;记&quot;</span>, <span class="string">&quot;赋&quot;</span>)</span><br><span class="line"><span class="comment">//虚词的数量</span></span><br><span class="line"><span class="keyword">val</span> xuSize = array.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> (title.length == <span class="number">0</span> || title.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    title = list(math.abs(<span class="type">Random</span>.nextInt) % shiSize)</span><br><span class="line">&#125;</span><br><span class="line">title + array(math.abs(<span class="type">Random</span>.nextInt) % xuSize)</span><br></pre></td></tr></table></figure>

<p>标题和文章都有了，那么拼接在一起写入一个文本文件中即可，引入Java的IO的三个类，java.io.{File, FileOutputStream, OutputStreamWriter},关键实现如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机出来一个近20年的时间点</span></span><br><span class="line"><span class="keyword">val</span> ran = <span class="type">Random</span>.nextInt()</span><br><span class="line"><span class="keyword">val</span> year = <span class="number">1980</span> + math.abs(ran % <span class="number">39</span>)</span><br><span class="line"><span class="keyword">val</span> month = <span class="number">1</span> + math.abs(ran % <span class="number">12</span>)</span><br><span class="line"><span class="keyword">val</span> day = <span class="number">1</span> + math.abs(ran % <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> now = <span class="type">LocalDate</span>.of(year, month, day) + <span class="string">&quot; &quot;</span> + <span class="type">LocalTime</span>.now().toString.dropRight(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是markdown文章的前缀</span></span><br><span class="line"><span class="keyword">val</span> pre = <span class="string">&quot;---\n&quot;</span> + <span class="string">&quot;title: &quot;</span> + title + <span class="string">&quot;\ndate: &quot;</span> + now + <span class="string">&quot;\ntags: \n&quot;</span> + <span class="string">&quot;---\n\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出文章路径output文件夹，如果没有就创建</span></span><br><span class="line"><span class="keyword">val</span> myPath: <span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;./output&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (!myPath.exists())&#123;<span class="comment">//若此目录不存在，则创建之</span></span><br><span class="line">    myPath.mkdir()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fos : <span class="type">FileOutputStream</span> = <span class="keyword">new</span> <span class="type">FileOutputStream</span>(<span class="string">s&quot;./<span class="subst">$myPath</span>/<span class="subst">$title</span>.md&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> osw : <span class="type">OutputStreamWriter</span>  = <span class="keyword">new</span> <span class="type">OutputStreamWriter</span>(fos, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文章</span></span><br><span class="line">osw.write(pre + totalArticle)</span><br><span class="line">osw.close()</span><br><span class="line">fos.close()</span><br></pre></td></tr></table></figure>



<p>具体生成文章效果：</p>
<img src="/blog/aa33/image-20200530122545640.png" class="image-20200530122545640">

<p>使用Hexo渲染后（具体实现查考Hexo官网），网站代码放到Github并开启gh-pages服务，预览文章 <a href="https://impn.github.io/ClassicalChineseGenerator/">https://impn.github.io/ClassicalChineseGenerator/</a></p>
<p>到此为止，一个完整的文言文网站已经生成。</p>
<img src="/blog/aa33/image-20200530123103874.png" class="image-20200530123103874">

<p>项目已经开源，完整代码放在Github，<a href="https://github.com/impn/ClassicalChineseGenerator">项目地址</a> ，可以直接下载在Release页面下载Jar包使用。</p>
<p>具体使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javr -jar ClassicalChineseGenerator-0.1.1.jar 10</span><br></pre></td></tr></table></figure>

<p>后面的数值参数是生成10篇文章，如果不加参数默认是生成1篇。</p>
]]></content>
      <categories>
        <category>灵感一现</category>
      </categories>
  </entry>
  <entry>
    <title>牛客网SQL题目</title>
    <url>/blog/7b61.html</url>
    <content><![CDATA[<p>牛客网题目 <a href="https://www.nowcoder.com/ta/sql">https://www.nowcoder.com/ta/sql</a><br>共计61道题目，现已全部完成</p>
<h2 id="第01题"><a href="#第01题" class="headerlink" title="第01题"></a>第01题</h2><ul>
<li>题目描述：查找最晚入职员工的所有信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">birth_date</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
<th align="left">gender</th>
<th align="left">hire_date</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10008</td>
<td align="left">1958-02-19</td>
<td align="left">Saniya</td>
<td align="left">Kalloufi</td>
<td align="left">M</td>
<td align="left">1994-09-15</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> hire_date<span class="operator">=</span>(<span class="keyword">select</span> hire_date <span class="keyword">from</span> employees <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span> limit <span class="number">1</span> )</span><br></pre></td></tr></table></figure>

<h2 id="第02题"><a href="#第02题" class="headerlink" title="第02题"></a>第02题</h2><ul>
<li>题目描述：查找入职员工时间排名倒数第三的员工所有信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">birth_date</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
<th align="left">gender</th>
<th align="left">hire_date</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10005</td>
<td align="left">1955-01-21</td>
<td align="left">Kyoichi</td>
<td align="left">Maliniak</td>
<td align="left">M</td>
<td align="left">1989-09-12</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> hire_date<span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">select</span> hire_date </span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> hire_date </span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">2</span>,<span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="第03题"><a href="#第03题" class="headerlink" title="第03题"></a>第03题</h2><ul>
<li>题目描述：查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_manager` (</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">salary</th>
<th align="left">from_date</th>
<th align="left">to_date</th>
<th align="left">dept_no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10002</td>
<td align="left">72527</td>
<td align="left">2001-08-02</td>
<td align="left">9999-01-01</td>
<td align="left">d001</td>
</tr>
<tr>
<td align="left">10004</td>
<td align="left">74057</td>
<td align="left">2001-11-27</td>
<td align="left">9999-01-01</td>
<td align="left">d004</td>
</tr>
<tr>
<td align="left">10005</td>
<td align="left">94692</td>
<td align="left">2001-09-09</td>
<td align="left">9999-01-01</td>
<td align="left">d003</td>
</tr>
<tr>
<td align="left">10006</td>
<td align="left">43311</td>
<td align="left">2001-08-02</td>
<td align="left">9999-01-01</td>
<td align="left">d002</td>
</tr>
<tr>
<td align="left">10010</td>
<td align="left">94409</td>
<td align="left">2001-11-23</td>
<td align="left">9999-01-01</td>
<td align="left">d006</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    t2.<span class="operator">*</span>,</span><br><span class="line">    t1.dept_no</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">join</span> dept_manager <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">where</span> t1.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第04题"><a href="#第04题" class="headerlink" title="第04题"></a>第04题</h2><ul>
<li>题目描述：查找所有已经分配部门的员工的last_name和first_name</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_emp` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">last_name</th>
<th align="left">first_name</th>
<th align="left">dept_no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Facello</td>
<td align="left">Georgi</td>
<td align="left">d001</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">Piveteau</td>
<td align="left">Duangkaew</td>
<td align="left">d006</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.last_name,</span><br><span class="line">    t1.first_name,</span><br><span class="line">    t2.dept_no</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    employees <span class="keyword">as</span> t1,</span><br><span class="line">    dept_emp <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">where</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">and</span> t2.dept_no <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="第05题"><a href="#第05题" class="headerlink" title="第05题"></a>第05题</h2><ul>
<li>题目描述：查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_emp` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">last_name</th>
<th align="left">first_name</th>
<th align="left">dept_no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Facello</td>
<td align="left">Georgi</td>
<td align="left">d001</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">Sluis</td>
<td align="left">Mary</td>
<td align="left">NULL(在sqlite中此处为空,MySQL为NULL)</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t2.last_name,</span><br><span class="line">    t2.first_name,</span><br><span class="line">    t1.dept_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_emp <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no;</span><br></pre></td></tr></table></figure>

<h2 id="第06题"><a href="#第06题" class="headerlink" title="第06题"></a>第06题</h2><ul>
<li>题目描述：查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10011</td>
<td align="left">25828</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">10001</td>
<td align="left">60117</td>
</tr>
</tbody></table>
<ul>
<li>答案：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.emp_no,</span><br><span class="line">    t2.salary</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">join</span> salaries <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">where</span> t1.hire_date<span class="operator">=</span>t2.from_date</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.emp_no <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第07题"><a href="#第07题" class="headerlink" title="第07题"></a>第07题</h2><ul>
<li>题目描述：查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">t</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">17</td>
</tr>
<tr>
<td align="left">10004</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">10009</td>
<td align="left">18</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    emp_no,</span><br><span class="line">    <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> emp_no</span><br><span class="line"><span class="keyword">having</span> t<span class="operator">&gt;</span><span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第08题"><a href="#第08题" class="headerlink" title="第08题"></a>第08题</h2><ul>
<li>题目描述：找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">94692</td>
</tr>
<tr>
<td align="left">94409</td>
</tr>
<tr>
<td align="left">88958</td>
</tr>
<tr>
<td align="left">88070</td>
</tr>
<tr>
<td align="left">74057</td>
</tr>
<tr>
<td align="left">72527</td>
</tr>
<tr>
<td align="left">59755</td>
</tr>
<tr>
<td align="left">43311</td>
</tr>
<tr>
<td align="left">25828</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="keyword">distinct</span> salary</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第09题"><a href="#第09题" class="headerlink" title="第09题"></a>第09题</h2><ul>
<li>题目描述：获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_manager` (</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">dept_no</th>
<th align="left">emp_no</th>
<th align="left">salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">d001</td>
<td align="left">10002</td>
<td align="left">72527</td>
</tr>
<tr>
<td align="left">d004</td>
<td align="left">10004</td>
<td align="left">74057</td>
</tr>
<tr>
<td align="left">d003</td>
<td align="left">10005</td>
<td align="left">94692</td>
</tr>
<tr>
<td align="left">d002</td>
<td align="left">10006</td>
<td align="left">43311</td>
</tr>
<tr>
<td align="left">d006</td>
<td align="left">10010</td>
<td align="left">94409</td>
</tr>
</tbody></table>
<ul>
<li>答案：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t2.dept_no,</span><br><span class="line">    t2.emp_no,</span><br><span class="line">    t1.salary</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">join</span> dept_manager <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">where</span> t1.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h2><ul>
<li>题目描述：获取所有非manager的员工emp_no</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_manager` (</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
</tr>
<tr>
<td align="left">10003</td>
</tr>
<tr>
<td align="left">10007</td>
</tr>
<tr>
<td align="left">10008</td>
</tr>
<tr>
<td align="left">10009</td>
</tr>
<tr>
<td align="left">10011</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.emp_no</span><br><span class="line"><span class="keyword">from</span> employees <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_manager <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">where</span> t2.dept_no <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="第11题"><a href="#第11题" class="headerlink" title="第11题"></a>第11题</h2><ul>
<li>题目描述： 获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。<br>结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_emp` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_manager` (</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">manager_no</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10001</td>
<td align="left">10002</td>
</tr>
<tr>
<td align="left">10003</td>
<td align="left">10004</td>
</tr>
<tr>
<td align="left">10009</td>
<td align="left">10010</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.emp_no,</span><br><span class="line">    t2.emp_no <span class="keyword">as</span> manager_no</span><br><span class="line"><span class="keyword">from</span> dept_emp <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> dept_manager <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.dept_no<span class="operator">=</span>t2.dept_no</span><br><span class="line"><span class="keyword">where</span> t1.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t1.emp_no<span class="operator">&lt;&gt;</span>t2.emp_no;</span><br></pre></td></tr></table></figure>



<h2 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h2><ul>
<li>题目描述：获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_emp` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">dept_no</th>
<th align="left">emp_no</th>
<th align="left">salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">d001</td>
<td align="left">10001</td>
<td align="left">88958</td>
</tr>
<tr>
<td align="left">d002</td>
<td align="left">10006</td>
<td align="left">43311</td>
</tr>
<tr>
<td align="left">d003</td>
<td align="left">10005</td>
<td align="left">94692</td>
</tr>
<tr>
<td align="left">d004</td>
<td align="left">10004</td>
<td align="left">74057</td>
</tr>
<tr>
<td align="left">d005</td>
<td align="left">10007</td>
<td align="left">88070</td>
</tr>
<tr>
<td align="left">d006</td>
<td align="left">10009</td>
<td align="left">95409</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.dept_no, </span><br><span class="line">    t1.emp_no, </span><br><span class="line">    t2.salary</span><br><span class="line"><span class="keyword">from</span> dept_emp <span class="keyword">as</span> t1 </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.emp_no <span class="operator">=</span> t2.emp_no</span><br><span class="line"><span class="keyword">and</span> t1.to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t2.to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">where</span> t2.salary <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">max</span>(t3.salary)</span><br><span class="line">    <span class="keyword">from</span> dept_emp <span class="keyword">as</span> t4</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> t3</span><br><span class="line">    <span class="keyword">on</span> t3.emp_no <span class="operator">=</span> t4.emp_no</span><br><span class="line">    <span class="keyword">and</span> t3.to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> t4.to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">    <span class="keyword">where</span> t4.dept_no <span class="operator">=</span> t1.dept_no</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t4.dept_no)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.dept_no;</span><br></pre></td></tr></table></figure>



<h2 id="第13题"><a href="#第13题" class="headerlink" title="第13题"></a>第13题</h2><ul>
<li>题目描述：从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;titles&quot; (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">title</th>
<th align="left">t</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Assistant Engineer</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Engineer</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">Staff</td>
<td align="left">3</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    title,</span><br><span class="line">    <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> titles</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> title</span><br><span class="line"><span class="keyword">having</span> t<span class="operator">&gt;=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第14题"><a href="#第14题" class="headerlink" title="第14题"></a>第14题</h2><ul>
<li>题目描述：从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。<br>注意对于重复的emp_no进行忽略。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `titles` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">title</th>
<th align="left">t</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Assistant Engineer</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Engineer</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">Staff</td>
<td align="left">3</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    title,</span><br><span class="line">    <span class="built_in">count</span>(<span class="keyword">distinct</span> emp_no) <span class="keyword">as</span> t</span><br><span class="line"><span class="keyword">from</span> titles</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> title;</span><br></pre></td></tr></table></figure>



<h2 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h2><ul>
<li>题目描述：查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">birth_date</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
<th align="left">gender</th>
<th align="left">hire_date</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10011</td>
<td align="left">1953-11-07</td>
<td align="left">Mary</td>
<td align="left">Sluis</td>
<td align="left">F</td>
<td align="left">1990-01-22</td>
</tr>
<tr>
<td align="left">10005</td>
<td align="left">1955-01-21</td>
<td align="left">Kyoichi</td>
<td align="left">Maliniak</td>
<td align="left">M</td>
<td align="left">1989-09-12</td>
</tr>
<tr>
<td align="left">10007</td>
<td align="left">1957-05-23</td>
<td align="left">Tzvetan</td>
<td align="left">Zielinski</td>
<td align="left">F</td>
<td align="left">1989-02-10</td>
</tr>
<tr>
<td align="left">10003</td>
<td align="left">1959-12-03</td>
<td align="left">Parto</td>
<td align="left">Bamford</td>
<td align="left">M</td>
<td align="left">1986-08-28</td>
</tr>
<tr>
<td align="left">10001</td>
<td align="left">1953-09-02</td>
<td align="left">Georgi</td>
<td align="left">Facello</td>
<td align="left">M</td>
<td align="left">1986-06-26</td>
</tr>
<tr>
<td align="left">10009</td>
<td align="left">1952-04-19</td>
<td align="left">Sumant</td>
<td align="left">Peac</td>
<td align="left">F</td>
<td align="left">1985-02-18</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> emp_no<span class="operator">&amp;</span><span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> last_name<span class="operator">&lt;&gt;</span>&quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第16题"><a href="#第16题" class="headerlink" title="第16题"></a>第16题</h2><ul>
<li>题目描述：统计出当前各个title类型对应的员工当前（to_date=’9999-01-01’）薪水对应的平均工资。结果给出title以及平均工资avg。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> &quot;titles&quot; (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">title</th>
<th align="left">avg</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Engineer</td>
<td align="left">94409.0</td>
</tr>
<tr>
<td align="left">Senior Engineer</td>
<td align="left">69009.2</td>
</tr>
<tr>
<td align="left">Senior Staff</td>
<td align="left">91381.0</td>
</tr>
<tr>
<td align="left">Staff</td>
<td align="left">72527.0</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    title,</span><br><span class="line">    <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg</span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">as</span> t1</span><br><span class="line"><span class="keyword">join</span> titles <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">and</span> t1.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t2.title;</span><br></pre></td></tr></table></figure>



<h2 id="第17题"><a href="#第17题" class="headerlink" title="第17题"></a>第17题</h2><ul>
<li>题目描述：获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">salary</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10009</td>
<td align="left">94409</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    emp_no,</span><br><span class="line">    salary</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">and</span> salary<span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> salaries</span><br><span class="line">    <span class="keyword">where</span> to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> salary</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="第18题"><a href="#第18题" class="headerlink" title="第18题"></a>第18题</h2><ul>
<li>题目描述：查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">salary</th>
<th align="left">last_name</th>
<th align="left">first_name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10009</td>
<td align="left">94409</td>
<td align="left">Peac</td>
<td align="left">Sumant</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t2.emp_no,</span><br><span class="line">    t1.salary,</span><br><span class="line">    t2.last_name,</span><br><span class="line">    t2.first_name</span><br><span class="line"><span class="keyword">FROM</span> salaries <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">JOIN</span> employees <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">AND</span> t1.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> t3.salary)</span><br><span class="line">    <span class="keyword">FROM</span> salaries <span class="keyword">AS</span> t3</span><br><span class="line">    <span class="keyword">WHERE</span> t3.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> t3.salary<span class="operator">&gt;</span>t1.salary</span><br><span class="line">)<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> salary;</span><br></pre></td></tr></table></figure>



<h2 id="第19题"><a href="#第19题" class="headerlink" title="第19题"></a>第19题</h2><ul>
<li>题目描述：查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `departments` (</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_name` <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dept_emp` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`dept_no` <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`dept_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">last_name</th>
<th align="left">first_name</th>
<th align="left">dept_name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Facello</td>
<td align="left">Georgi</td>
<td align="left">Marketing</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">Sluis</td>
<td align="left">Mary</td>
<td align="left">NULL</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    last_name,</span><br><span class="line">    first_name,</span><br><span class="line">    dept_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept_emp <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> t3</span><br><span class="line"><span class="keyword">ON</span> t2.dept_no<span class="operator">=</span>t3.dept_no;</span><br></pre></td></tr></table></figure>



<h2 id="第20题"><a href="#第20题" class="headerlink" title="第20题"></a>第20题</h2><ul>
<li>查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">growth</th>
</tr>
</thead>
<tbody><tr>
<td align="left">28841</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(salary)<span class="operator">-</span><span class="built_in">min</span>(salary) <span class="keyword">as</span> growth</span><br><span class="line"><span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">where</span> emp_no<span class="operator">=</span><span class="number">10001</span>;</span><br></pre></td></tr></table></figure>



<h2 id="第21题"><a href="#第21题" class="headerlink" title="第21题"></a>第21题</h2><ul>
<li>题目描述：查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `employees` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`birth_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`first_name` <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`last_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`gender` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`hire_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">growth</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10011</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">省略</td>
<td align="left">省略</td>
</tr>
<tr>
<td align="left">10010</td>
<td align="left">54496</td>
</tr>
<tr>
<td align="left">10004</td>
<td align="left">34003</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	emp_no,</span><br><span class="line">	growth</span><br><span class="line"><span class="keyword">FROM</span>(<span class="keyword">SELECT</span></span><br><span class="line">		a.emp_no,</span><br><span class="line">		b.salary<span class="operator">-</span>a.salary <span class="keyword">AS</span> growth</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		(<span class="keyword">SELECT</span></span><br><span class="line">			t1.emp_no,</span><br><span class="line">			salary</span><br><span class="line">		<span class="keyword">FROM</span> </span><br><span class="line">			employees <span class="keyword">AS</span> t1,</span><br><span class="line">			salaries <span class="keyword">AS</span> t2</span><br><span class="line">		<span class="keyword">WHERE</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line">		<span class="keyword">AND</span> t1.hire_date<span class="operator">=</span>t2.from_date) <span class="keyword">AS</span> a,</span><br><span class="line">		(<span class="keyword">SELECT</span></span><br><span class="line">			t1.emp_no,</span><br><span class="line">			salary</span><br><span class="line">		<span class="keyword">FROM</span> </span><br><span class="line">			employees <span class="keyword">AS</span> t1,</span><br><span class="line">			salaries <span class="keyword">AS</span> t2</span><br><span class="line">		<span class="keyword">WHERE</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line">		<span class="keyword">AND</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span>) <span class="keyword">AS</span> b</span><br><span class="line">	<span class="keyword">WHERE</span> a.emp_no<span class="operator">=</span>b.emp_no)<span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.growth</span><br></pre></td></tr></table></figure>



<h2 id="第22题"><a href="#第22题" class="headerlink" title="第22题"></a>第22题</h2><ul>
<li>对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `salaries` (</span><br><span class="line">`emp_no` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`from_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`to_date` <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure>
<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">emp_no</th>
<th align="left">salary</th>
<th align="left">rank</th>
</tr>
</thead>
<tbody><tr>
<td align="left">10005</td>
<td align="left">94692</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10009</td>
<td align="left">94409</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">10010</td>
<td align="left">94409</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">10001</td>
<td align="left">88958</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">10007</td>
<td align="left">88070</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">10004</td>
<td align="left">74057</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">10002</td>
<td align="left">72527</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">10003</td>
<td align="left">43311</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">10006</td>
<td align="left">43311</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">10011</td>
<td align="left">25828</td>
<td align="left">8</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	emp_no,</span><br><span class="line">	growth</span><br><span class="line"><span class="keyword">FROM</span>(<span class="keyword">SELECT</span></span><br><span class="line">		a.emp_no,</span><br><span class="line">		b.salary<span class="operator">-</span>a.salary <span class="keyword">AS</span> growth</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		(<span class="keyword">SELECT</span></span><br><span class="line">			t1.emp_no,</span><br><span class="line">			salary</span><br><span class="line">		<span class="keyword">FROM</span> </span><br><span class="line">			employees <span class="keyword">AS</span> t1,</span><br><span class="line">			salaries <span class="keyword">AS</span> t2</span><br><span class="line">		<span class="keyword">WHERE</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line">		<span class="keyword">AND</span> t1.hire_date<span class="operator">=</span>t2.from_date) <span class="keyword">AS</span> a,</span><br><span class="line">		(<span class="keyword">SELECT</span></span><br><span class="line">			t1.emp_no,</span><br><span class="line">			salary</span><br><span class="line">		<span class="keyword">FROM</span> </span><br><span class="line">			employees <span class="keyword">AS</span> t1,</span><br><span class="line">			salaries <span class="keyword">AS</span> t2</span><br><span class="line">		<span class="keyword">WHERE</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line">		<span class="keyword">AND</span> t2.to_date<span class="operator">=</span><span class="string">&#x27;9999-01-01&#x27;</span>) <span class="keyword">AS</span> b</span><br><span class="line">	<span class="keyword">WHERE</span> a.emp_no<span class="operator">=</span>b.emp_no)<span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> c.growth</span><br></pre></td></tr></table></figure>

<ul>
<li>输出示例：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">dept_no</th>
<th align="left">dept_name</th>
<th align="left">sum</th>
</tr>
</thead>
<tbody><tr>
<td align="left">d001</td>
<td align="left">Marketing</td>
<td align="left">24</td>
</tr>
<tr>
<td align="left">d002</td>
<td align="left">Finance</td>
<td align="left">14</td>
</tr>
<tr>
<td align="left">d003</td>
<td align="left">Human Resources</td>
<td align="left">13</td>
</tr>
<tr>
<td align="left">d004</td>
<td align="left">Production</td>
<td align="left">24</td>
</tr>
<tr>
<td align="left">d005</td>
<td align="left">Development</td>
<td align="left">25</td>
</tr>
<tr>
<td align="left">d006</td>
<td align="left">Quality Management</td>
<td align="left">25</td>
</tr>
</tbody></table>
<ul>
<li>答案：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    t1.dept_no,</span><br><span class="line">    t3.dept_name,</span><br><span class="line">    <span class="built_in">count</span>(t2.salary) <span class="keyword">as</span> sum</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    dept_emp <span class="keyword">as</span> t1,</span><br><span class="line">    salaries <span class="keyword">as</span> t2,</span><br><span class="line">    departments <span class="keyword">as</span> t3</span><br><span class="line"><span class="keyword">where</span> t3.dept_no<span class="operator">=</span>t1.dept_no</span><br><span class="line"><span class="keyword">and</span> t1.emp_no<span class="operator">=</span>t2.emp_no</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.dept_no</span><br></pre></td></tr></table></figure>

<h2 id="第22-61题"><a href="#第22-61题" class="headerlink" title="第22-61题"></a>第22-61题</h2><p>后面太多，就不罗列上去了，附上仓库地址</p>
<p><a href ="https://github.com/impn/nowcoder/tree/master/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E5%AE%9E%E6%88%98" target="_blank" >Github仓库</a></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>Hive的一次踩坑</title>
    <url>/blog/26a5.html</url>
    <content><![CDATA[<p>今天周末，新冠疫情虽然已经逐渐退去，但仍然不能掉以轻心，而且外面还在下雨，正是窝在家看书的好时机，拿出《Hive编程指南》再看一遍，书读百遍，其义自见，这种经典书每看一遍都会有新的收获。当然光看书是不行的，学习必须要有输出，必须要上手实际操作才会印象深刻。</p>
<p>今天按照书上关于分区的部分实际上手操作了一把，发现还是有一些坑在里面的。</p>
<p>本文测试环境：<code>2.1.1-cdh6.3.2, rb3393cf499504df1d2a12d34b4285e5d0c02be11</code></p>
<h3 id="1-字段注释乱码"><a href="#1-字段注释乱码" class="headerlink" title="1. 字段注释乱码"></a>1. 字段注释乱码</h3><p>在建表时没有添加<code>COMMENT 字段注释</code>，后面我想通过<code>ALTER TABLE</code>给表字段添加注释时候，发现添加后是<code>??</code>，那么肯定是字符集设置的有问题。打开MySQL，进入Hive的元数据的数据库<br>修改<code>表注释</code>和<code>字段注释</code>在MySQL数据库中对应的字段字符类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table COLUMNS_V2 modify column COMMENT varchar(256) character set utf8;</span><br><span class="line"></span><br><span class="line">alter table TABLE_PARAMS modify column PARAM_VALUE varchar(4000) character set utf8;</span><br><span class="line"></span><br><span class="line">alter table PARTITION_KEYS modify column PKEY_COMMENT varchar(4000) character set utf8;</span><br></pre></td></tr></table></figure>
<p>再次执行ALTER TABLE 修改表注释，然后DESC 表名，字段注释恢复成中文，问题解决。</p>
<p>我安装的是MySQL5.7版本，由于强迫症，我直接修改了MySQL的配置文件<br>root用户下 <code>vim /etc/my.cnf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在[mysqld]下添加两行</span><br><span class="line">character_set_server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line"></span><br><span class="line"># 新添加两行</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
<p>最后重新启动MySQL<br><code>systemctl restart mysqld</code><br>【请勿模仿】而且我还尝试修改了MySQL中的<code>hive</code>库的编码方式为<code>utf8</code>，以及<code>hive</code>库下所有的表的编码方式为<code>utf8</code>,后来才看到网上有文章说有不要改，否则有意外的惊喜。不过我启动集群，暂时一切正常。</p>
<h3 id="2-外部分区表新增字段后插入数据为NULL"><a href="#2-外部分区表新增字段后插入数据为NULL" class="headerlink" title="2. 外部分区表新增字段后插入数据为NULL"></a>2. 外部分区表新增字段后插入数据为NULL</h3><p>这个坑可以稳定复现</p>
<p>描述：</p>
<p><strong>对于分区表新增字段，向已存在分区中插入数据，新增字段的值全部为NULL。</strong></p>
<p><strong>已存在</strong>分区有此问题，新分区并不会产生该问题；</p>
<p>无论是管理表还是外部表都有该问题。</p>
<p>网上搜索答案，在新增字段后，对表进行<code>msck repair table tablename</code>，实际验证此方法无效。</p>
<p>复现过程：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> temp01;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> temp01(id string,name string) partitioned <span class="keyword">by</span> (sex string) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> stored <span class="keyword">as</span> textfile;</span><br><span class="line"><span class="comment">-- 添加分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp01 <span class="keyword">add</span> <span class="keyword">partition</span>(sex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> temp01 <span class="keyword">partition</span> (sex<span class="operator">=</span>&quot;M&quot;) </span><br><span class="line"><span class="keyword">select</span> &quot;1001&quot;,&quot;张三&quot;;</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp01;</span><br></pre></td></tr></table></figure>

<img src="/blog/26a5/image-20200328232729273.png" class="image-20200328232729273">

<p>到这里一切正常</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp01 <span class="keyword">add</span> columns (birth String comment &quot;生日&quot;);</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp01 <span class="keyword">partition</span> (sex<span class="operator">=</span>&quot;M&quot;) </span><br><span class="line"><span class="keyword">select</span> &quot;1001&quot;,&quot;刘备&quot;,&quot;1999-08-09&quot;;</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp01;</span><br></pre></td></tr></table></figure>

<p>下面就出问题了，刘备同学的生日实际提示是插入成功了，但这里显示为NULL。</p>
<img src="/blog/26a5/image-20200328232907371.png" class="image-20200328232907371">

<p>其实问题很简单，分区表的元数据没有更新导致的。</p>
<p>首选的方法是针对该分区单独增加字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table temp01 partition(sex=‘M’) add columns(birth string comment ‘生日’);</span><br></pre></td></tr></table></figure>

<p>另外一种方法是重建该分区，如果是内部表，信息也会被删除。（不建议）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 重建分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp01 <span class="keyword">drop</span> <span class="keyword">partition</span> (sex<span class="operator">=</span>&quot;M&quot;);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp01 <span class="keyword">add</span> <span class="keyword">partition</span> (sex<span class="operator">=</span>&quot;M&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> temp01;</span><br></pre></td></tr></table></figure>

<p>刘备同学的生日已经出现了。</p>
<img src="/blog/26a5/image-20200328233140947.png" class="image-20200328233140947">



<p>下次一定注意要规避这种情况，直接在添加字段的时候，就要考虑这种情况，可以使用<strong>cascade</strong>关键字添加字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp01 <span class="keyword">add</span> columns (birth String comment &quot;生日&quot;) cascade;</span><br></pre></td></tr></table></figure>

<p>然后回刷数据的时候就不会出现NULL值情况了。</p>
<p>【附】：<a href="26a5/Hive编程指南.pdf" target="_blank">《Hive编程指南》PDF下载</a></p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>一道有意思的SQL</title>
    <url>/blog/5acd.html</url>
    <content><![CDATA[<p>今天题发现一个有趣的题目：找到一个班级里成绩排名，并算出每个人的前1名和前2名作为超越的对手，如果没有前1名，则找前2名和前3名。例如：有两个第八名，则没有第九名，第十名的前一名是第八名，第十名的前2名是第七名</p>
<p>举个例子：<br>一个班级的某科目成绩单如下：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td>赵君</td>
<td>48</td>
</tr>
<tr>
<td>1002</td>
<td>钱不</td>
<td>95</td>
</tr>
<tr>
<td>1003</td>
<td>孙见</td>
<td>64</td>
</tr>
<tr>
<td>1004</td>
<td>李黄</td>
<td>77</td>
</tr>
<tr>
<td>1005</td>
<td>周河</td>
<td>82</td>
</tr>
<tr>
<td>1006</td>
<td>吴之</td>
<td>77</td>
</tr>
<tr>
<td>1007</td>
<td>郑水</td>
<td>64</td>
</tr>
<tr>
<td>1008</td>
<td>王天</td>
<td>92</td>
</tr>
<tr>
<td>1009</td>
<td>冯上</td>
<td>77</td>
</tr>
<tr>
<td>1010</td>
<td>褚来</td>
<td>82</td>
</tr>
<tr>
<td>1011</td>
<td>卫奔</td>
<td>85</td>
</tr>
<tr>
<td>1012</td>
<td>蒋流</td>
<td>67</td>
</tr>
</tbody></table>
<p>需要获取到每个人的排名以及他所在前1名同学和前2名同学的姓名，目标结果如下所示。</p>
<img src="/blog/5acd/image-20200508220830448.png" class="image-20200508220830448">

<p>拿到题目首先造数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> SCORE;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> score(ID STRING,NAME STRING,SC STRING)</span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">STORED <span class="keyword">AS</span> ORC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> SCORE <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;1001&#x27;</span>,<span class="string">&#x27;赵君&#x27;</span>,<span class="string">&#x27;48&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1002&#x27;</span>,<span class="string">&#x27;钱不&#x27;</span>,<span class="string">&#x27;95&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1003&#x27;</span>,<span class="string">&#x27;孙见&#x27;</span>,<span class="string">&#x27;64&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1004&#x27;</span>,<span class="string">&#x27;李黄&#x27;</span>,<span class="string">&#x27;77&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1005&#x27;</span>,<span class="string">&#x27;周河&#x27;</span>,<span class="string">&#x27;82&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1006&#x27;</span>,<span class="string">&#x27;吴之&#x27;</span>,<span class="string">&#x27;77&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1007&#x27;</span>,<span class="string">&#x27;郑水&#x27;</span>,<span class="string">&#x27;64&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1008&#x27;</span>,<span class="string">&#x27;王天&#x27;</span>,<span class="string">&#x27;92&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1009&#x27;</span>,<span class="string">&#x27;冯上&#x27;</span>,<span class="string">&#x27;77&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1010&#x27;</span>,<span class="string">&#x27;褚来&#x27;</span>,<span class="string">&#x27;82&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1011&#x27;</span>,<span class="string">&#x27;卫奔&#x27;</span>,<span class="string">&#x27;85&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;1012&#x27;</span>,<span class="string">&#x27;蒋流&#x27;</span>,<span class="string">&#x27;67&#x27;</span>);</span><br></pre></td></tr></table></figure>



<p>首先给每位同学成绩进行排名，分为跳跃排名和不跳跃排名。实际业务中，前1名和前2名是自己下次考试的超越对手。其中跳跃排名是正常使用的排名，而不跳跃排名是为了进行关联而使用的关联条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id, <span class="comment">-- 学号</span></span><br><span class="line">    name, <span class="comment">-- 姓名</span></span><br><span class="line">    sc,  <span class="comment">-- 成绩</span></span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk, <span class="comment">-- 排名1,带跳跃</span></span><br><span class="line">    <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk2 <span class="comment">-- 排名2,不跳跃</span></span><br><span class="line"><span class="keyword">FROM</span> score</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>sc</th>
<th>rk</th>
<th>rk2</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>钱不</td>
<td>95</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1008</td>
<td>王天</td>
<td>92</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1011</td>
<td>卫奔</td>
<td>85</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>1010</td>
<td>褚来</td>
<td>82</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>1005</td>
<td>周河</td>
<td>82</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>1009</td>
<td>冯上</td>
<td>77</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>1006</td>
<td>吴之</td>
<td>77</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>1004</td>
<td>李黄</td>
<td>77</td>
<td>6</td>
<td>5</td>
</tr>
<tr>
<td>1012</td>
<td>蒋流</td>
<td>67</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>1007</td>
<td>郑水</td>
<td>64</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>1003</td>
<td>孙见</td>
<td>64</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>1001</td>
<td>赵君</td>
<td>48</td>
<td>12</td>
<td>8</td>
</tr>
</tbody></table>
<p>然后进行两次自关联，分别找到每一位同学的前1名和前2名，由于存在排名并列的情况，join后势必存在数据膨胀，也就是说前1名可能是多位同学，这里使用collect_list函数对结果进行收敛。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> tt <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        id, <span class="comment">-- 学号</span></span><br><span class="line">        name, <span class="comment">-- 姓名</span></span><br><span class="line">        sc,  <span class="comment">-- 成绩</span></span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk, <span class="comment">-- 排名1,带跳跃</span></span><br><span class="line">        <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk2 <span class="comment">-- 排名2,不跳跃</span></span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t1.id,</span><br><span class="line">    t1.name,</span><br><span class="line">    t1.sc,</span><br><span class="line">    t1.rk,</span><br><span class="line">    <span class="comment">--t1.rk2,</span></span><br><span class="line">    <span class="comment">--COLLECT_LIST(t2.id), -- 前1名学号</span></span><br><span class="line">    COLLECT_LIST(t2.name), <span class="comment">-- 前1名姓名</span></span><br><span class="line">    <span class="comment">--COLLECT_LIST(t3.id), -- 前2名学号</span></span><br><span class="line">    COLLECT_LIST(t3.name) <span class="comment">-- 前2名姓名</span></span><br><span class="line"><span class="keyword">FROM</span> tt <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tt <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.rk2<span class="number">-1</span><span class="operator">=</span>t2.rk2</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tt <span class="keyword">AS</span> t3</span><br><span class="line"><span class="keyword">ON</span> t1.rk2<span class="number">-2</span><span class="operator">=</span>t3.rk2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t1.id,</span><br><span class="line">    t1.name,</span><br><span class="line">    t1.sc,</span><br><span class="line">    t1.rk,</span><br><span class="line">    t1.rk2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.rk;</span><br></pre></td></tr></table></figure>

<p>执行结果如下:</p>
<img src="/blog/5acd/image-20200508220901554.png" class="image-20200508220901554">

<p>不难看出最后三位同学{郑水，孙见，赵君}的数据是有问题的，前1、2名数据有重复，为什么呢？</p>
<p>经过测试，实际上单独找前1名或者前2名使用collect_list都没有重复，如果找前1名和前2名放在一起会产生重复，因为collect相当于省略了group by操作，对膨胀的数据进行聚合（列转行），在第一次join中已经出现了数据膨胀，第二次join会加剧数据膨胀，而collect_list是在所有join完成之后，对重复的数据仅进行一次收敛。所以使用collect_set才会符合预期要求。</p>
<p>代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> tt <span class="keyword">AS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        id, <span class="comment">-- 学号</span></span><br><span class="line">        name, <span class="comment">-- 姓名</span></span><br><span class="line">        sc,  <span class="comment">-- 成绩</span></span><br><span class="line">        <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk, <span class="comment">-- 排名1,带跳跃</span></span><br><span class="line">        <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> sc <span class="keyword">DESC</span>) <span class="keyword">AS</span> rk2 <span class="comment">-- 排名2,不跳跃</span></span><br><span class="line">    <span class="keyword">FROM</span> score</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    t1.id,</span><br><span class="line">    t1.name,</span><br><span class="line">    t1.sc,</span><br><span class="line">    t1.rk,</span><br><span class="line">    <span class="comment">--t1.rk2,</span></span><br><span class="line">    <span class="comment">--COLLECT_SET(t2.id), -- 前1名学号</span></span><br><span class="line">    COLLECT_SET(t2.name), <span class="comment">-- 前1名姓名</span></span><br><span class="line">    <span class="comment">--COLLECT_SET(t3.id), -- 前2名学号</span></span><br><span class="line">    COLLECT_SET(t3.name) <span class="comment">-- 前2名姓名</span></span><br><span class="line"><span class="keyword">FROM</span> tt <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tt <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">ON</span> t1.rk2<span class="number">-1</span><span class="operator">=</span>t2.rk2</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> tt <span class="keyword">AS</span> t3</span><br><span class="line"><span class="keyword">ON</span> t1.rk2<span class="number">-2</span><span class="operator">=</span>t3.rk2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    t1.id,</span><br><span class="line">    t1.name,</span><br><span class="line">    t1.sc,</span><br><span class="line">    t1.rk,</span><br><span class="line">    t1.rk2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.rk;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<img src="/blog/5acd/image-20200508221007625.png" class="image-20200508221007625">]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title>记录一次Hive中遇到的问题</title>
    <url>/blog/f16a.html</url>
    <content><![CDATA[<p>今天在测试MapJoin对优化作用的提升的时候，使用普通用户mapan在命令行hive-cli里跑一段的MapJoin得到测试HQL，发现报如下错误，学会看报错日志是非常好的解决问题的方法，通过看日志能够解决大部分常见的的问题。关键日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2020-03-26 20:42:36,065 main ERROR RandomAccessFileManager </span><br><span class="line">(/var/log/hive/operation_logs/7cbc9115-f9e8-4554-99f2-</span><br><span class="line">196aced99788/mapan_20200326204229_2b889f65-cc49-4de5-b3b5-0bccd05b3812) </span><br><span class="line">java.io.IOException: Could not create directory </span><br><span class="line">/var/log/hive/operation_logs/7cbc9115-f9e8-4554-99f2-196aced99788 </span><br><span class="line">java.io.IOException: Could not create directory </span><br><span class="line">/var/log/hive/operation_logs/7cbc9115-f9e8-4554-99f2-196aced99788</span><br><span class="line">	at org.apache.logging.log4j.core.util.FileUtils.mkdir(FileUtils.java:119)</span><br><span class="line">	at org.apache.logging.log4j.core.util.FileUtils.makeParentDirs(FileUtils.java:136)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.RandomAccessFileManager$RandomAccessFileManagerFactory.createManager(RandomAccessFileManager.java:198)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.RandomAccessFileManager$RandomAccessFileManagerFactory.createManager(RandomAccessFileManager.java:177)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.AbstractManager.getManager(AbstractManager.java:112)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.OutputStreamManager.getManager(OutputStreamManager.java:114)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.RandomAccessFileManager.getFileManager(RandomAccessFileManager.java:74)</span><br><span class="line">	at org.apache.hadoop.hive.ql.log.HushableRandomAccessFileAppender.createAppender(HushableRandomAccessFileAppender.java:178)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:132)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:952)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:892)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.routing.RoutingAppender.createAppender(RoutingAppender.java:271)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.routing.RoutingAppender.getControl(RoutingAppender.java:255)</span><br><span class="line">	at org.apache.logging.log4j.core.appender.routing.RoutingAppender.append(RoutingAppender.java:225)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AppenderControl.tryCallAppender(AppenderControl.java:156)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AppenderControl.callAppender0(AppenderControl.java:129)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AppenderControl.callAppenderPreventRecursion(AppenderControl.java:120)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AppenderControl.callAppender(AppenderControl.java:84)</span><br><span class="line">	at org.apache.logging.log4j.core.config.LoggerConfig.callAppenders(LoggerConfig.java:448)</span><br><span class="line">	at org.apache.logging.log4j.core.config.LoggerConfig.processLogEvent(LoggerConfig.java:433)</span><br><span class="line">	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:417)</span><br><span class="line">	at org.apache.logging.log4j.core.config.LoggerConfig.log(LoggerConfig.java:403)</span><br><span class="line">	at org.apache.logging.log4j.core.config.AwaitCompletionReliabilityStrategy.log(AwaitCompletionReliabilityStrategy.java:63)</span><br><span class="line">	at org.apache.logging.log4j.core.Logger.logMessage(Logger.java:146)</span><br><span class="line">	at org.apache.logging.log4j.spi.AbstractLogger.logMessageSafely(AbstractLogger.java:2091)</span><br><span class="line">	at org.apache.logging.log4j.spi.AbstractLogger.logMessage(AbstractLogger.java:1993)</span><br><span class="line">	at org.apache.logging.log4j.spi.AbstractLogger.logIfEnabled(AbstractLogger.java:1852)</span><br><span class="line">	at org.apache.logging.slf4j.Log4jLogger.info(Log4jLogger.java:179)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.mapjoin.MapJoinMemoryExhaustionHandler.&lt;init&gt;(MapJoinMemoryExhaustionHandler.java:61)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.HashTableSinkOperator.initializeOp(HashTableSinkOperator.java:129)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:358)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:546)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initializeChildren(Operator.java:498)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:368)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:546)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initializeChildren(Operator.java:498)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:368)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:546)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initializeChildren(Operator.java:498)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.Operator.initialize(Operator.java:368)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.mr.MapredLocalTask.initializeOperators(MapredLocalTask.java:514)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.mr.MapredLocalTask.startForward(MapredLocalTask.java:418)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.mr.MapredLocalTask.executeInProcess(MapredLocalTask.java:393)</span><br><span class="line">	at org.apache.hadoop.hive.ql.exec.mr.ExecDriver.main(ExecDriver.java:779)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.apache.hadoop.util.RunJar.run(RunJar.java:313)</span><br><span class="line">	at org.apache.hadoop.util.RunJar.main(RunJar.java:227)</span><br></pre></td></tr></table></figure>
<p>很明显日志中提到如下关键错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main ERROR RandomAccessFileManager </span><br><span class="line">(/var/log/hive/operation_logs/7cbc9115-f9e8-4554-99f2-</span><br><span class="line">196aced99788/mapan_20200326204229_2b889f65-cc49-4de5-b3b5-0bccd05b3812)</span><br><span class="line">java.io.IOException: Could not create directory </span><br></pre></td></tr></table></figure>
<p>由于我是使用的mapan用户登录并运行的hive-cli,所以我猜测是由于mapan用户没有<code>/var/log/hive/operation_logs/</code>的权限所导致的。切换hive用户尝试<br><code>sudo -u hive hive</code>进入hive-cli,然后跑同样一段HQL发现可以正常运行，OK那么问题基本可以确定了，给对应目录添加写权限即可。<br><code>sudo chmod -R o+w /var/log/hive/operation_logs/</code><br>再次使用mapan用户进入hive -cli,跑同样的HQL，没有再报错，问题解决。</p>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>数据质量监控</title>
    <url>/blog/2408.html</url>
    <content><![CDATA[<p>数据质量监控，在企业中实际的作用更多的是面对开发人员，例如计算出的结果值出现了明显的异常，一个日常用品的店铺，单个订单金额突破了10万，很明显是异常的订单，虽然有可能真有这样的顾客，但是需要提前预警，以提醒开发人员，这里的数据相比以往变化较大需要核实。否则等业务人员问起来了，一问三不知，很可能要被业务投诉。</p>
<p>1）单表数据量监控。<br>一张表的记录数在-一个已知的范围内，或者上下浮动不会超过某个阈值。</p>
<ul>
<li>SQL 结果：var 数据量 = count（”昨天”（如果设置了时间字段的话）满足“过滤条件”的记录）。</li>
<li>数值检测：如果数据量不在[数值下限，数值上限]，则触发报警。</li>
<li>同比增加：如果（（今 天的数据量-上周的数据量）/上周的数据量*100）不在[比例下线，比例上限]，则触发报警。</li>
<li>环比增加：如果（（今天的数据量 - 昨天的数据量）/昨天的数据量*100）不在[比例下线，比例上限]，则触发报警。</li>
<li>“阈值配置”的六个数值当中，至少配置-一个阈值.对于没有配置的阈值，不做监控。</li>
</ul>
<p>2）单表空值检测<br>某个字段为空的记录数在-一个范围内，或者占总量的百分比在某个阈值范围内</p>
<ul>
<li>目标字段：选择要监控的字段，不能选“无”;</li>
<li>SQL结果：var 异常数据量 = count（”目标字段”为空的记录）;</li>
<li>单次检测：如果（异常数据量）不在[数值下限，数值上限]，则触发报警</li>
</ul>
<p>3）单表重复值检测。<br>一个或多个字段是否满足某些规则。</p>
<ul>
<li>目标字段：选择要监控的字段，group by这里的字段列表后，没有重复;</li>
<li>单次检测：如果（异常数据量）不在[数值下限，数值上限]，则触发报警。</li>
</ul>
<p>4）单表值域检测。<br>一个或多个字段没有重复记录。</p>
<ul>
<li>目标字段：选择要监控的字段，支持多选。</li>
<li>检测规则：填写”目标字段”要满足的条件。其中$1表示第一个目标字段，$2 表示第二个目标字段，以此类推。</li>
<li>阈值配置与”空值检测”相同。</li>
</ul>
<p>6）跨表主外键对比</p>
<ul>
<li>监控字段和关联字段：需要符合外键约束的两个字段;</li>
<li>阈值配置与”空值检测”相同。</li>
</ul>
]]></content>
      <categories>
        <category>数据仓库</category>
      </categories>
  </entry>
  <entry>
    <title>Next主题添加鼠标心形点击特效</title>
    <url>/blog/76c9.html</url>
    <content><![CDATA[<p>1、在<code>\Blog\themes\next\source\js\src\</code>目录下新建<code>love.js</code>,代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure>

<p>2、在<code>Blog\themes\next\layout\_layout.swig</code>文件的最下方，<code>&lt;/body&gt;</code>前面添加<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown语法和MD编辑器</title>
    <url>/blog/b33e.html</url>
    <content><![CDATA[<h2 id="comments"><a href="#comments" class="headerlink" title="comments:"></a>comments:</h2><p>Markdown是一种轻便简单快捷的排版语言，是<code>难用到极点的Word</code>的<code>非常优秀</code>的替代。以下内容引用自维基百科。</p>
<blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<blockquote>
<p>John Gruber 在 2004 年创造了 Markdown 语言，在语法上有很大一部分是跟亚伦·斯沃茨（Aaron Swartz）共同合作的。这个语言的目的是希望大家使用“易于阅读、易于撰写的纯文字格式，并选择性的转换成有效的 XHTML (或是HTML)”。 其中最重要的设计是可读性，也就是说这个语言应该要能直接在字面上的被阅读，而不用被一些格式化指令标记 (像是 RTF 与 HTML)。 因此，它是现行电子邮件标记格式的惯例，虽然它也借鉴了很多早期的标记语言，如：setext、Texile、reStructuredText。 许多网站都使用 Markdown 或是其变种，例如：GitHub、reddit、Diaspora、Stack Exchange、OpenStreetMap 与 SourceForge 让用户更利于讨论。</p>
</blockquote>
<blockquote>
<p>Markdown同时还是一个由Gruber编写的Perl脚本：Markdown.pl。它把用markdown语法编写的内容转换成有效的、结构良好的XHTML或HTML内容，并将左尖括号(‘&lt;’)和&amp;号替换成它们各自的字符实体引用。它可以用作单独的脚本，Blosxom和Movable Type的插件又或者BBEdit的文本过滤器.</p>
</blockquote>
<blockquote>
<p>Markdown也已经被其他人用Perl和别的编程语言重新实现，其中一个Perl模块放在了CPAN(Text::Markdown)上。它基于一个BSD风格的许可证分发并可以作为几个内容管理系统的插件。</p>
</blockquote>
<p><a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin">关于md文件</a>,后缀为md的文件是markdown语法的文章。非常简单的排版语法，可以很轻易的转HTML，转PDF等。我喜欢的原因很简单，Markdown看起来非常地极客。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br></pre></td></tr></table></figure>
<p>渲染后</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><p>画表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|A|B|N|H|</span><br><span class="line">|:--:|:--:|:--:|:--:|</span><br><span class="line">|1|2|3|4|</span><br><span class="line">|a|s|d|f|</span><br><span class="line">|t|2|2|G|</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">N</th>
<th align="center">H</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">s</td>
<td align="center">d</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">t</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">G</td>
</tr>
</tbody></table>
<p><a href="http://wowubuntu.com/markdown/#list">更多语法</a></p>
<p>试用了无数个markdown编辑器，均是或丑或难用。</p>
<blockquote>
<p>MarkdownPad<br>Mahua<br>小书匠<br>Haroopad<br>Cmd Markdown上</p>
</blockquote>
<p>今天偶然发现了一款让我眼前一亮的编辑器[Yu-writter][1],界面友好，windows支持绿色化,一款能找到写作乐趣的 Markdown 文本编辑器，原生支持hexo和jeklly，Hugo三种静态博客。看样子作者还是更新中，正式版还没有发布，目前beta版本已经够日常使用，期待作者的更新。</p>
<hr>
<p>10.6更新 <br><br>Typora这个更厉害，直接把源码和预览结合到一起，有种所见即所得的感觉了。但是这样仿佛失去了markdown的乐趣，markdown的初衷是怎么在不使用鼠标仅仅用键盘的情况下，把文章和排版做好。Typora直接简化了这个过程，把源码和预览结合到一起，配合鼠标使用。<a href="https://typora.io/">Typora</a>使用起来也很不错但个人觉得少了点极客的感觉。仁者见仁智者见智咯~</p>
<hr>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>巧妙绕过加密PPT密码</title>
    <url>/blog/ea01.html</url>
    <content><![CDATA[<p>我们有时候会遇到加密的ppt文件，下面的方法可以绕过密码验证，直接删除密码。<br>和<code>.apk</code>文件一样，其实<code>.pptx</code>文件就是zip的压缩包,将其后缀改为zip就可以解压出源文件。</p>
<p>下面是破解步骤：</p>
<ul>
<li>1.将pptx文件重命名，比如现有一个加密文件名称为<code>123.pptx</code>，更名为<code>123.pptx.zip</code>，双扩展名可以有效说明文件的格式以及原始格式；</li>
<li>2.将改名后的文件<code>123.pptx.zip</code>解压缩，得到一个<code>123.pptx</code> 文件夹；</li>
<li>3.切换到<code>\ppt</code> 之下，用记事本开启 <code>presentation.xml</code> 文件；</li>
<li>4.把 <code>&lt;p:modifyVerifier ... /&gt;</code>整块选中并删除保存；</li>
<li>5.返回 <code>123.pptx</code> 文件夹第一层，注意，不要退出该文件夹之外；</li>
<li>6.选择所有文件，将其添加为 <code>zip</code> 压缩包格式，压缩方式为 标准；</li>
<li>7.将压缩包重命名为 <code>xxxx.pptx</code>，此时的pptx文件即为无密码保护的演示文稿，密码删除成功~</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>redis常用指令</title>
    <url>/blog/6c7e.html</url>
    <content><![CDATA[<p>Redis几乎覆盖了Mencached的绝大部分功能，数据都在内存中，支持持久化，主要用作备份恢复<br>除了支持简单的key-value模式，还支持多种数据结构的存储，比如list、set、hash、zset等。<br>redis一般是作为缓存数据库辅助持久化的数据库。</p>
<h3 id="Redis的常用指令"><a href="#Redis的常用指令" class="headerlink" title="Redis的常用指令"></a>Redis的常用指令</h3><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>keys *</code></td>
<td align="center">查询当前库的所有文件</td>
</tr>
<tr>
<td align="center"><code>exist &lt;key&gt;</code></td>
<td align="center">判断某个键是否存在</td>
</tr>
<tr>
<td align="center"><code>type &lt;key&gt;</code></td>
<td align="center">查看键的类型</td>
</tr>
<tr>
<td align="center"><code>del &lt;key&gt;</code></td>
<td align="center">删除某个键</td>
</tr>
<tr>
<td align="center"><code>expire &lt;key&gt; &lt;second&gt;</code></td>
<td align="center">为键值设置过期时间，单位秒</td>
</tr>
<tr>
<td align="center"><code>ttl &lt;key&gt;</code></td>
<td align="center">查看还有多少秒过期，-1表示用不过期，-2表示已经过期</td>
</tr>
<tr>
<td align="center"><code>dbsize</code></td>
<td align="center">查看当前数据库的key的数量</td>
</tr>
<tr>
<td align="center"><code>flushdb</code></td>
<td align="center">清空当前库</td>
</tr>
<tr>
<td align="center"><code>flushall</code></td>
<td align="center">通杀全部库</td>
</tr>
<tr>
<td align="center"><code>append</code></td>
<td align="center">为指定的 key 追加值</td>
</tr>
<tr>
<td align="center"><code>setnx &lt;key&gt; &lt;value&gt;</code></td>
<td align="center">若key 不存在,将键 key 的值设置为 value,若key已存在,则不作任何操作</td>
</tr>
<tr>
<td align="center"><code>incr &lt;key&gt;</code></td>
<td align="center">将key中储存的数值加1，若没有该键，则创建之</td>
</tr>
<tr>
<td align="center"><code>decr &lt;key&gt;</code></td>
<td align="center">将key中储存的数值减1，若没有该键，则创建之</td>
</tr>
<tr>
<td align="center"><code>setex &lt;key&gt; &lt;过期时间&gt;</code></td>
<td align="center">设置键值的同时设置过期时间</td>
</tr>
<tr>
<td align="center"><code>getset &lt;key&gt; &lt;value&gt;</code></td>
<td align="center">以旧换新，设置新值的同时获取旧值</td>
</tr>
<tr>
<td align="center"><code>strlen  &lt;key&gt;</code></td>
<td align="center">获取值得长度</td>
</tr>
<tr>
<td align="center"><code>getrange &lt;key&gt; 1 4</code></td>
<td align="center">获取键值的第1-4位</td>
</tr>
<tr>
<td align="center"><code>setrange &lt;key&gt; 3 777</code></td>
<td align="center">从键值的第3位开始替换为777</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>mysql注入问题</title>
    <url>/blog/2cf8.html</url>
    <content><![CDATA[<p>在学习JDBC时，使用Statement接口会有如下SQL注入的漏洞.</p>
<p>由于没有对拼接的字符串进项检查，很容易遭受到恶意攻击，例如编程如下：<br>例如变成如下操作。<br><code>select * from user where username=&#39;aaa&#39; or &#39;1&#39;=&#39;1&#39; and password=&#39;bbb&#39; or &#39;1&#39;=&#39;1&#39;;</code></p>
<p>解决SQL注入的漏洞的方法是使用PreparementStatement接口，以下是PreparementStatement接口的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreparedStatmentTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPreparedStatement</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//1.注册驱动</span></span><br><span class="line">		Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		<span class="comment">//2.获取连接</span></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		<span class="comment">// 假设有一个User对象，需要将User中的信息保存到数据库中</span></span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;张飞&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;zhangfei@sanguo.com&quot;</span>);</span><br><span class="line">		<span class="comment">//3.写sql语句</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br><span class="line">		<span class="comment">//4.预编译sql</span></span><br><span class="line">		<span class="type">PreparedStatement</span> <span class="variable">pst</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">//5.填充占位符</span></span><br><span class="line">		pst.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">		pst.setString(<span class="number">2</span>, user.getPassword());</span><br><span class="line">		<span class="comment">//6.执行sql</span></span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pst.executeQuery();</span><br><span class="line">		System.out.println(rs.next());</span><br><span class="line">		<span class="comment">//7.关闭资源</span></span><br><span class="line">		conn.close();</span><br><span class="line">		pst.close();</span><br><span class="line">		rs.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Xshell使用技巧</title>
    <url>/blog/e056.html</url>
    <content><![CDATA[<p>测试</p>
<p>XShell连接Linux终端，发现在Vim中编辑文件，无法使用小键盘。通过一下设置可以解决。</p>
<img src="/blog/e056/1559706987773.png" class="xshell示例图">]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>大数据时代怎么保护自己的隐私</title>
    <url>/blog/e5aa.html</url>
    <content><![CDATA[<p>互联网+大数据时代，我们的个人隐私泄露的问题变的非常严重。只要我们上网，就会留下痕迹。各种网站的注册使用，向我们索取姓名，电话，邮箱，身份证号等等。<br>那么我们怎么保护个人隐私呢？</p>
<p>首先在打开百度首页，尝试搜索自己的 <em>姓名</em>，<em>电话</em>，<em>常用用户名</em>，<em>邮箱</em>，<em>qq号</em>，看看能找到多少自己留下的信息。通过搜索引擎就能搜出来这么多和个人相关的片面信息。如果吧这些信息综合起来，一个人的基本的个人肖像就可以描绘出来了。</p>
<p>本文写如何保护隐私，也可以说是如何反社工，那么首先请遵循以下建议：</p>
<h4 id="1、拥有2-3个手机号-比如ABC-："><a href="#1、拥有2-3个手机号-比如ABC-：" class="headerlink" title="1、拥有2-3个手机号(比如ABC)："></a>1、拥有2-3个手机号(比如ABC)：</h4><ul>
<li>A号码（隐私号码）使用保号套餐(例如月租5元保号卡)，仅用来接收短信验证码，这个号码越少人知道越好，用来绑定重要的信息，如银行卡，信用卡，支付宝等对个人十分重要的账户，通常这些账户会伴随我们一生中的很长一段时间，这张卡可以插在单独的备用机上(比如诺基亚按键机)。</li>
<li>B号码（生活号码）尽量不绑定任何账号（可以仅绑定微信），用来联系亲朋好友。</li>
<li>C号码（工作号码）同样建议不绑定私人账号（可以绑定如钉钉类型的工作账号）用来联系同事，沟通工作使用。</li>
<li>一些不太常用，仅使用一段时间，同时也不太知名的网站，请使用匿名邮箱注册，或绑定匿手机号。<br>如果有可能的话，手机可以再下载一个小号的APP，申请一个虚拟号码，这个号码仅仅用来网购，外卖，个人租房，被推销等待，虚拟号码的好处是可以随时换，随时扔，号码携带的信息是个人随机填写的，扔掉也不介意。<h4 id="2、每个网站的用户名和昵称请不要使用相同的名字。"><a href="#2、每个网站的用户名和昵称请不要使用相同的名字。" class="headerlink" title="2、每个网站的用户名和昵称请不要使用相同的名字。"></a>2、每个网站的用户名和昵称请不要使用相同的名字。</h4><h4 id="3、在论坛和贴吧等互联网公共场合，慎重留下个人邮箱手机号qq号等。"><a href="#3、在论坛和贴吧等互联网公共场合，慎重留下个人邮箱手机号qq号等。" class="headerlink" title="3、在论坛和贴吧等互联网公共场合，慎重留下个人邮箱手机号qq号等。"></a>3、在论坛和贴吧等互联网公共场合，慎重留下个人邮箱手机号qq号等。</h4><h4 id="4、注册各种网站请不要填写真实的身份信息，其中包括，姓名，出生日期，籍贯，星座。这些建议随机填写。"><a href="#4、注册各种网站请不要填写真实的身份信息，其中包括，姓名，出生日期，籍贯，星座。这些建议随机填写。" class="headerlink" title="4、注册各种网站请不要填写真实的身份信息，其中包括，姓名，出生日期，籍贯，星座。这些建议随机填写。"></a>4、注册各种网站请不要填写真实的身份信息，其中包括，姓名，出生日期，籍贯，星座。这些建议随机填写。</h4><h4 id="5、每个注册网站使用不同的密码。"><a href="#5、每个注册网站使用不同的密码。" class="headerlink" title="5、每个注册网站使用不同的密码。"></a>5、每个注册网站使用不同的密码。</h4><h4 id="6、拥有多个邮箱，每个邮箱用来绑定不同的网站，例如信用卡绑定专用邮箱，游戏账户绑定专用邮箱，工作专用邮箱，联系网友专用邮箱，等等。每个邮箱各司其职，不要乱用。"><a href="#6、拥有多个邮箱，每个邮箱用来绑定不同的网站，例如信用卡绑定专用邮箱，游戏账户绑定专用邮箱，工作专用邮箱，联系网友专用邮箱，等等。每个邮箱各司其职，不要乱用。" class="headerlink" title="6、拥有多个邮箱，每个邮箱用来绑定不同的网站，例如信用卡绑定专用邮箱，游戏账户绑定专用邮箱，工作专用邮箱，联系网友专用邮箱，等等。每个邮箱各司其职，不要乱用。"></a>6、拥有多个邮箱，每个邮箱用来绑定不同的网站，例如信用卡绑定专用邮箱，游戏账户绑定专用邮箱，工作专用邮箱，联系网友专用邮箱，等等。每个邮箱各司其职，不要乱用。</h4><h4 id="7、如果使用安卓手机，尽量不要下载一些小众的不知名的App，使用权限管理禁掉各种软件的联系人、短信、定位、录音、粘贴板、摄像头权限，使用白名单制，权限按需分配，这个可能对自己的使用带来不便。"><a href="#7、如果使用安卓手机，尽量不要下载一些小众的不知名的App，使用权限管理禁掉各种软件的联系人、短信、定位、录音、粘贴板、摄像头权限，使用白名单制，权限按需分配，这个可能对自己的使用带来不便。" class="headerlink" title="7、如果使用安卓手机，尽量不要下载一些小众的不知名的App，使用权限管理禁掉各种软件的联系人、短信、定位、录音、粘贴板、摄像头权限，使用白名单制，权限按需分配，这个可能对自己的使用带来不便。"></a>7、如果使用安卓手机，尽量不要下载一些小众的不知名的App，使用权限管理禁掉各种软件的联系人、短信、定位、录音、粘贴板、摄像头权限，使用白名单制，权限按需分配，这个可能对自己的使用带来不便。</h4><h4 id="8、如果使用iPhone手机，那么恭喜你，除了苹果窥探你的隐私之外，其他App相对来说不太容易读取到个人的隐私信息，苹果应用商店是封闭的，不合规的App会被下架。"><a href="#8、如果使用iPhone手机，那么恭喜你，除了苹果窥探你的隐私之外，其他App相对来说不太容易读取到个人的隐私信息，苹果应用商店是封闭的，不合规的App会被下架。" class="headerlink" title="8、如果使用iPhone手机，那么恭喜你，除了苹果窥探你的隐私之外，其他App相对来说不太容易读取到个人的隐私信息，苹果应用商店是封闭的，不合规的App会被下架。"></a>8、如果使用iPhone手机，那么恭喜你，除了苹果窥探你的隐私之外，其他App相对来说不太容易读取到个人的隐私信息，苹果应用商店是封闭的，不合规的App会被下架。</h4></li>
</ul>
<p>上面两条换句话说，使用苹果手机，是把隐私交给一个大流氓来管理，小流氓就得乖乖听大流氓的话。使用安卓手机，需要自己管理一堆小流氓和一个大流氓(flyme、MIUI、EMUI)。别忘了手机系统软件也会窃取个人隐私信息。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>shell基本语法</title>
    <url>/blog/5ef7.html</url>
    <content><![CDATA[<h1 id="0-Shell概述"><a href="#0-Shell概述" class="headerlink" title="0_Shell概述"></a>0_Shell概述</h1><ul>
<li>内核</li>
</ul>
<p>内核其主要模块（或组件）包括以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信，以及系统的初始化（引导）、系统调用等，完成对硬件的控制。</p>
<ul>
<li>Shell：</li>
</ul>
<p>俗称壳（用来区别于内核），是机器外面的一层壳，用于人机交互，是人与电脑之间交互的接口，“提供使用者使用界面”的软件（命令解析器）它接收用户命令，然后调用相应的应用程序。表现为其作用是用户输入一条命令，shell 就立即解释执行一条。不局限于系统、语言等概念、操作方式和表现方式等。 比如我们平时在黑框框里输入命令，叫 command-line interface (CLI)；在屏幕上点点点，叫graphical user interface (GUI)</p>
<ul>
<li>Bash：</li>
</ul>
<p>它的名字是一系列缩写：Bourne-Again SHell，顾名思义，再生的Shell，所以，Bash是Shell的一种，而且是最常见的shell，Mac 中默认 shell 就是 bash</p>
<img src="/blog/5ef7/1560773228203.png" class="1560773228203">

<h1 id="1-Shell解析器"><a href="#1-Shell解析器" class="headerlink" title="1_Shell解析器"></a>1_Shell解析器</h1><p>（1）Linux提供的Shell解析器有：</p>
<p>centOS6下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 ~]$ <span class="built_in">cat</span> /etc/shells </span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure>
<p>Raspberry下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ <span class="built_in">cat</span> /etc/shells</span><br><span class="line"><span class="comment"># /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/screen</span><br></pre></td></tr></table></figure>

<p>（2）bash和sh的关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 bin]$ ll | grep bash</span><br><span class="line">-rwxr-xr-x. 1 root root 941880 5月  11 2016 bash</span><br><span class="line">lrwxrwxrwx. 1 root root      4 5月  27 2017 sh -&gt; bash</span><br></pre></td></tr></table></figure>
<p>（3）Centos默认的解析器是bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 bin]$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<h1 id="2-Shell脚本入门"><a href="#2-Shell脚本入门" class="headerlink" title="2_Shell脚本入门"></a>2_Shell脚本入门</h1><h2 id="2-1格式"><a href="#2-1格式" class="headerlink" title="2.1格式"></a>2.1格式</h2><p>脚本以#!/bin/bash开头（指定解析器）</p>
<h2 id="2-2第一个Shell脚本：helloworld"><a href="#2-2第一个Shell脚本：helloworld" class="headerlink" title="2.2第一个Shell脚本：helloworld"></a>2.2第一个Shell脚本：helloworld</h2><p>（1）需求：创建一个Shell脚本，输出helloworld<br>（2）案例实操：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch helloworld.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vi helloworld.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在helloworld.sh中输入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure>
<p>（3）脚本的常用执行方式<br>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh+脚本的相对路径</span><br><span class="line">[mapan@hadoop101 datas]$ sh helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sh+脚本的绝对路径</span><br><span class="line">[mapan@hadoop101 datas]$ sh /home/mapan/datas/helloworld.sh </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash+脚本的相对路径</span><br><span class="line">[mapan@hadoop101 datas]$ bash helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash+脚本的绝对路径</span><br><span class="line">[mapan@hadoop101 datas]$ bash /home/mapan/datas/helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）<br>（a）首先要赋予helloworld.sh 脚本的+x权限<br><code>[mapan@hadoop101 datas]$ chmod +x helloworld.sh</code><br>（b）执行脚本<br>相对路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ ./helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>绝对路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ /home/mapan/datas/helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。<br>3．第二个Shell脚本：多命令处理<br>（1）需求：<br>在/home/mapan/目录下创建一个banzhang.txt,在banzhang.txt文件中增加“I love cls”。<br>（2）案例实操：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> batch.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vi batch.sh</span><br></pre></td></tr></table></figure>
<p>在batch.sh中输入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /home/mapan</span><br><span class="line"><span class="built_in">touch</span> cls.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I love cls&quot;</span> &gt;&gt;cls.txt</span><br></pre></td></tr></table></figure>
<h1 id="3-Shell中的变量"><a href="#3-Shell中的变量" class="headerlink" title="3_Shell中的变量"></a>3_Shell中的变量</h1><h2 id="3-1系统变量"><a href="#3-1系统变量" class="headerlink" title="3.1系统变量"></a>3.1系统变量</h2><p>1.常用系统变量<br><code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>、<code>$USER</code>等</p>
<p>2.案例实操<br>（1）查看系统变量的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/mapan</span><br></pre></td></tr></table></figure>
<p>（2）显示当前Shell中所有变量：<code>set</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">set</span></span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure>
<h2 id="3-2定义变量"><a href="#3-2定义变量" class="headerlink" title="3.2定义变量"></a>3.2定义变量</h2><p>1．基本语法<br>（1）定义变量：变量=值<br>（2）撤销变量：unset 变量<br>（3）声明静态变量：readonly变量，注意：不能unset<br>2．变量定义规则<br>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写。<br>（2）等号两侧不能有空格<br>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。<br>（4）变量的值如果有空格，需要使用双引号或单引号括起来。<br>3．案例实操<br>（1）定义变量A</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ A=5</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>（2）给变量A重新赋值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ A=8</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>（3）撤销变量A</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">unset</span> A</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure>

<p>（4）声明静态的变量B=2，不能unset</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">readonly</span> B=2</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> <span class="variable">$B</span></span><br><span class="line">2</span><br><span class="line">[mapan@hadoop101 datas]$ B=9</span><br><span class="line">-bash: B: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure>
<p>（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 ~]$ C=1+2</span><br><span class="line">[mapan@hadoop102 ~]$ <span class="built_in">echo</span> <span class="variable">$C</span></span><br><span class="line">1+2</span><br></pre></td></tr></table></figure>
<p>（6）变量的值如果有空格，需要使用双引号或单引号括起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 ~]$ D=I love banzhang</span><br><span class="line">-bash: world: <span class="built_in">command</span> not found</span><br><span class="line">[mapan@hadoop102 ~]$ D=<span class="string">&quot;I love banzhang&quot;</span></span><br><span class="line">[mapan@hadoop102 ~]$ <span class="built_in">echo</span> <span class="variable">$D</span></span><br><span class="line">I love banzhang</span><br></pre></td></tr></table></figure>
<p>（7）可把变量提升为全局环境变量，可供其他Shell程序使用<br><code>export 变量名</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ vim helloworld.sh </span><br></pre></td></tr></table></figure>
<p>在helloworld.sh文件中增加echo $B</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$B</span></span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ ./helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure>
<p>发现并没有打印输出变量B的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">export</span> B</span><br><span class="line">[mapan@hadoop101 datas]$ ./helloworld.sh </span><br><span class="line">helloworld</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="3-3特殊变量"><a href="#3-3特殊变量" class="headerlink" title="3.3特殊变量"></a>3.3特殊变量</h2><p>特殊变量：$n<br>1．基本语法<br>$n    （功能描述：n为数字，$0代表该脚本名称，$1-$9代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}）<br>2．案例实操<br>（1）输出该脚本文件名称、输入参数1和输入参数2 的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> parameter.sh </span><br><span class="line">[mapan@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>   <span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ ./parameter.sh cls  xz</span><br><span class="line">./parameter.sh  cls   xz</span><br></pre></td></tr></table></figure>
<p>特殊变量：$#<br>1．基本语法<br>$#    （功能描述：获取所有输入参数个数，常用于循环）。<br>2．案例实操<br>（1）获取输入参数的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>   <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ ./parameter.sh cls  xz</span><br><span class="line">parameter.sh cls xz </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p> 特殊变量：$<em>、$@<br>1．基本语法<br>$</em>    （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）<br>$@    （功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）<br>2．案例实操<br>（1）打印输入的所有参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>   <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ bash parameter.sh 1 2 3</span><br><span class="line">parameter.sh  1   2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p>特殊变量：$？<br>1．基本语法<br><code>$？</code>（功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）<br>2．案例实操<br>（1）判断helloworld.sh脚本是否正确执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ ./helloworld.sh </span><br><span class="line">hello world</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4_运算符"></a>4_运算符</h1><h2 id="4-1基本语法"><a href="#4-1基本语法" class="headerlink" title="4.1基本语法"></a>4.1基本语法</h2><p>（1）“$((运算式))”或“$[运算式]”</p>
<p>（2）<code>expr  + , - , \*,  /,  % </code>   加，减，乘，除，取余</p>
<p>注意：expr运算符间要有空格</p>
<h2 id="4-2案例实操："><a href="#4-2案例实操：" class="headerlink" title="4.2案例实操："></a>4.2案例实操：</h2><p>（1）计算3+2的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">expr</span> 2 + 3</span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>（2）计算3-2的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">expr</span> 3 - 2 </span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>（3）计算（2+3）X4的值</p>
<p>（a）expr一步完成计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">expr</span> `<span class="built_in">expr</span> 2 + 3` \* 4</span><br><span class="line"></span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>（b）采用$[运算式]方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]<span class="comment"># S=$[(2+3)*4]</span></span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]<span class="comment"># echo $S</span></span><br></pre></td></tr></table></figure>

<h1 id="5-条件判断"><a href="#5-条件判断" class="headerlink" title="5_条件判断"></a>5_条件判断</h1><h2 id="5-1基本语法"><a href="#5-1基本语法" class="headerlink" title="5.1基本语法"></a>5.1基本语法</h2><p><code>[ condition ]（注意condition前后要有空格）</code><br>注意：条件非空即为<code>true</code>，<code>[ mapan ]</code>返回<code>true</code>，<code>[]</code> 返回<code>false</code>。</p>
<h2 id="5-2常用判断条件"><a href="#5-2常用判断条件" class="headerlink" title="5.2常用判断条件"></a>5.2常用判断条件</h2><p>（1）两个整数之间比较<br><code>=</code> 字符串比较<br><code>-lt</code> 小于（less than）           <code> -le</code> 小于等于（less equal）<br><code>-eq</code> 等于（equal）               <code> -gt</code> 大于（greater than）<br><code>-ge</code> 大于等于（greater equal）    <code>-ne</code> 不等于（Not equal）<br>（2）按照文件权限进行判断<br><code>-r</code> 有读的权限（read）           <code>-w</code> 有写的权限（write）<br><code>-x</code> 有执行的权限（execute）<br>（3）按照文件类型进行判断<br><code>-f</code> 文件存在并且是一个常规的文件（file）<br><code>-e</code> 文件存在（existence）        <code>-d</code> 文件存在并是一个目录（directory）</p>
<h2 id="5-3案例实操"><a href="#5-3案例实操" class="headerlink" title="5.3案例实操"></a>5.3案例实操</h2><p>（1）23是否大于等于22</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ [ 23 -ge 22 ]</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>（2）helloworld.sh是否具有写权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ [ -w helloworld.sh ]</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>（3）/home/mapan/cls.txt目录中的文件是否存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ [ -e /home/mapan/cls.txt ]</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 ~]$ [ condition ] &amp;&amp; <span class="built_in">echo</span> OK || <span class="built_in">echo</span> notok</span><br><span class="line">OK</span><br><span class="line">[mapan@hadoop101 datas]$ [ condition ] &amp;&amp; [ ] || <span class="built_in">echo</span> notok</span><br><span class="line">notok</span><br></pre></td></tr></table></figure>
<h1 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6_流程控制"></a>6_流程控制</h1><h2 id="6-1if-判断"><a href="#6-1if-判断" class="headerlink" title="6.1if 判断"></a>6.1if 判断</h2><p>1．基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then </span><br><span class="line">  程序 </span><br><span class="line">fi </span><br><span class="line">或者 </span><br><span class="line">if [ 条件判断式 ] </span><br><span class="line">  then </span><br><span class="line">    程序 </span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">else</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>注意事项：<br>（1）[ 条件判断式 ]，中括号和条件判断式之间必须有空格<br>（2）if后要有空格<br>2．案例实操<br>    （1）输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> if.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim if.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -eq <span class="string">&quot;1&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;banzhang zhen shuai&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -eq <span class="string">&quot;2&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cls zhen mei&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 if.sh </span><br><span class="line">[mapan@hadoop101 datas]$ ./if.sh 1</span><br><span class="line">banzhang zhen shuai</span><br></pre></td></tr></table></figure>
<h2 id="6-2case-语句"><a href="#6-2case-语句" class="headerlink" title="6.2case 语句"></a>6.2case 语句</h2><p>1．基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in </span><br><span class="line">  &quot;值1&quot;） </span><br><span class="line">    如果变量的值等于值1，则执行程序1 </span><br><span class="line">    ;; </span><br><span class="line">  &quot;值2&quot;） </span><br><span class="line">    如果变量的值等于值2，则执行程序2 </span><br><span class="line">    ;; </span><br><span class="line">  …省略其他分支… </span><br><span class="line">  *） </span><br><span class="line">    如果变量的值都不是以上的值，则执行此程序 </span><br><span class="line">    ;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>case行尾必须为单词“in”，每一个模式匹配必须以右括号“）”结束。</li>
<li>双分号“;;”表示命令序列结束，相当于java中的break。</li>
<li>最后的“*）”表示默认模式，相当于java中的default。<br>2．案例实操<br>（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch case.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim case.sh</span><br><span class="line"> </span><br><span class="line">!/bin/bash</span><br><span class="line"> </span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">        echo &quot;banzhang&quot;</span><br><span class="line">;;</span><br><span class="line"> </span><br><span class="line">&quot;2&quot;)</span><br><span class="line">        echo &quot;cls&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">        echo &quot;renyao&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"> </span><br><span class="line">[mapan@hadoop101 datas]$ chmod 777 case.sh</span><br><span class="line">[mapan@hadoop101 datas]$ ./case.sh 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="6-3for-循环"><a href="#6-3for-循环" class="headerlink" title="6.3for 循环"></a>6.3for 循环</h2>1．基本语法1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 )) </span><br><span class="line">  do </span><br><span class="line">    程序 </span><br><span class="line">  done</span><br></pre></td></tr></table></figure>
2．案例实操<br> （1）从1加到100<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch for1.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim for1.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for((i=0;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">s=$[$s+$i]</span><br><span class="line">done</span><br><span class="line">echo $s</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ chmod 777 for1.sh </span><br><span class="line">[mapan@hadoop101 datas]$ ./for1.sh </span><br><span class="line">“5050”</span><br></pre></td></tr></table></figure>
3．基本语法2<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3… </span><br><span class="line">do </span><br><span class="line">程序 </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
4．案例实操<br>（1）打印所有输入参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch for2.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim for2.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">#打印数字</span><br><span class="line"></span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $i &quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ chmod 777 for2.sh </span><br><span class="line">[mapan@hadoop101 datas]$ bash for2.sh cls xz bd</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure>
（2）比较<code>$*</code>和<code>$@</code>区别<br>（a）<code>$*</code>和<code>$@</code>都表示传递给函数或脚本的所有参数，不被双引号<code>“”</code>包含时，都以<code>$1 $2 …$n</code>的形式输出所有参数。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch for.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim for.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash </span><br><span class="line"></span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">echo &quot;ban zhang love $i &quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for j in $@</span><br><span class="line">do      </span><br><span class="line">echo &quot;ban zhang love $j&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ bash for.sh cls xz bd</span><br><span class="line">ban zhang love cls </span><br><span class="line">ban zhang love xz </span><br><span class="line">ban zhang love bd </span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure>
（b）当它们被双引号“”包含时，“$*”会将所有的参数作为一个整体，以<code>“$1 $2 …$n”</code>的形式输出所有参数；<code>“$@”</code>会将各个参数分开，以<code>“$1” “$2”…”$n”</code>的形式输出所有参数。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ vim for.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span> </span><br><span class="line"><span class="comment">#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次 </span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="comment">#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 </span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$j</span>&quot;</span> </span><br><span class="line">		<span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 for.sh</span><br><span class="line">[mapan@hadoop101 datas]$ bash for.sh cls xz bd</span><br><span class="line">ban zhang love cls xz bd</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure>
<h2 id="6-4while-循环"><a href="#6-4while-循环" class="headerlink" title="6.4while 循环"></a>6.4while 循环</h2> 1．基本语法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ] </span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    程序</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
2．案例实操<br>（1）从1加到100<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> while.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim while.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        s=$[<span class="variable">$s</span>+<span class="variable">$i</span>]</span><br><span class="line">        i=$[<span class="variable">$i</span>+1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$s</span></span><br><span class="line"> </span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 while.sh </span><br><span class="line">[mapan@hadoop101 datas]$ ./while.sh </span><br><span class="line">5050</span><br></pre></td></tr></table></figure>
<h1 id="07-read指令"><a href="#07-read指令" class="headerlink" title="07_read指令"></a>07_read指令</h1><h2 id="7-1基本语法"><a href="#7-1基本语法" class="headerlink" title="7.1基本语法"></a>7.1基本语法</h2><code>read(选项)(参数)</code><br>选项：<br><code>-p</code>：指定读取值时的提示符；<br><code>-t</code>：指定读取值时等待的时间（秒）。<br>参数<br> 变量：指定读取值的变量名<h2 id="7-2案例实操"><a href="#7-2案例实操" class="headerlink" title="7.2案例实操"></a>7.2案例实操</h2>（1）提示7秒内，读取控制台输入的名称<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> read.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim read.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">read</span> -t 7 -p <span class="string">&quot;Enter your name in 7 seconds &quot;</span> NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line"> </span><br><span class="line">[mapan@hadoop101 datas]$ ./read.sh </span><br><span class="line">Enter your name <span class="keyword">in</span> 7 seconds xiaoze</span><br><span class="line">xiaoze</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="08-函数"><a href="#08-函数" class="headerlink" title="08_函数"></a>08_函数</h1><h2 id="8-1系统函数"><a href="#8-1系统函数" class="headerlink" title="8.1系统函数"></a>8.1系统函数</h2><p>1．<code>basename</code>基本语法<br><code>basename [string / pathname] [suffix]  </code><br>（功能描述：basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来。<br>选项：<br><code>suffix</code>为后缀，如果<code>suffix</code>被指定了，<code>basename</code>会将<code>pathname</code>或<code>string</code>中的suffix去掉。<br>2．案例实操<br>（1）截取该/home/mapan/banzhang.txt路径的文件名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">basename</span> /home/mapan/banzhang.txt </span><br><span class="line">banzhang.txt</span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">basename</span> /home/mapan/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure>
<p>3.<code>dirname</code>基本语法<br><code>dirname 文件绝对路径  </code><br>（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））<br>4．案例实操<br>（1）获取<code>banzhang.txt</code>文件的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 ~]$ <span class="built_in">dirname</span> /home/mapan/banzhang.txt </span><br><span class="line">/home/mapan</span><br></pre></td></tr></table></figure>
<h2 id="8-2自定义函数"><a href="#8-2自定义函数" class="headerlink" title="8.2自定义函数"></a>8.2自定义函数</h2><p>1．基本语法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">	Action;</span><br><span class="line">	[<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure>
<p>2．经验技巧<br>（1）必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。<br>（2）函数返回值，只能通过$?系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)<br>3．案例实操<br>    （1）计算两个输入参数的和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">touch</span> fun.sh</span><br><span class="line">[mapan@hadoop101 datas]$ vim fun.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    s=0</span><br><span class="line">    s=$[ <span class="variable">$1</span> + <span class="variable">$2</span> ]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$s</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input the number1: &quot;</span> n1;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input the number2: &quot;</span> n2;</span><br><span class="line"><span class="built_in">sum</span> <span class="variable">$n1</span> <span class="variable">$n2</span>;</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ <span class="built_in">chmod</span> 777 fun.sh</span><br><span class="line">[mapan@hadoop101 datas]$ ./fun.sh </span><br><span class="line">Please input the number1: 2</span><br><span class="line">Please input the number2: 5</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h1 id="09-Shell工具"><a href="#09-Shell工具" class="headerlink" title="09_Shell工具"></a>09_Shell工具</h1><h2 id="9-1-cut"><a href="#9-1-cut" class="headerlink" title="9.1 cut"></a>9.1 cut</h2><p>cut的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p>
<p>1.基本用法</p>
<p><code>cut [选项参数]  filename</code></p>
<p>说明：默认分隔符是制表符</p>
<p>2.选项参数说明</p>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-f</td>
<td>列号，提取第几列</td>
</tr>
<tr>
<td>-d</td>
<td>分隔符，按照指定分隔符分割列</td>
</tr>
<tr>
<td>-c</td>
<td>指定具体的字符</td>
</tr>
</tbody></table>
<p>3.案例实操</p>
<p>（0）数据准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ touch cut.txt</span><br><span class="line"></span><br><span class="line">[mapan@hadoop101 datas]$ vim cut.txt</span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">wo  wo</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<p>（1）切割cut.txt第一列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ cut -d &quot; &quot; -f 1 cut.txt </span><br><span class="line"></span><br><span class="line">dong</span><br><span class="line"></span><br><span class="line">guan</span><br><span class="line"></span><br><span class="line">wo</span><br><span class="line"></span><br><span class="line">lai</span><br><span class="line"></span><br><span class="line">le</span><br></pre></td></tr></table></figure>
<p>（2）切割cut.txt第二、三列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ cut -d &quot; &quot; -f 2,3 cut.txt </span><br><span class="line"></span><br><span class="line">shen</span><br><span class="line"></span><br><span class="line">zhen</span><br><span class="line"></span><br><span class="line"> wo</span><br><span class="line"></span><br><span class="line"> lai</span><br><span class="line"></span><br><span class="line"> le</span><br></pre></td></tr></table></figure>
<p>（3）在cut.txt文件中切割出guan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ cat cut.txt | grep &quot;guan&quot; | cut -d &quot; &quot; -f 1</span><br><span class="line"></span><br><span class="line">guan</span><br></pre></td></tr></table></figure>
<p>（4）选取系统PATH变量值，第2个“：”开始后的所有路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ echo $PATH</span><br><span class="line"></span><br><span class="line">/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/mapan/bin</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">[mapan@hadoop102 datas]$ echo $PATH | cut -d: -f 2-</span><br><span class="line"></span><br><span class="line">/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/mapan/bin</span><br></pre></td></tr></table></figure>
<p>（5）切割ifconfig 后打印的IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop101 datas]$ ifconfig eth0 | grep &quot;inet addr&quot; | cut -d: -f 2 | cut -d&quot; &quot; -f1</span><br><span class="line"></span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<h2 id="9-2-sed"><a href="#9-2-sed" class="headerlink" title="9.2 sed"></a>9.2 sed</h2><p>sed是一种流编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。</p>
<ol>
<li>基本用法</li>
</ol>
<p><code>sed [选项参数]  ‘command’  filename</code></p>
<ol>
<li>选项参数说明</li>
</ol>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-e</td>
<td>直接在指令列模式上进行sed的动作编辑。</td>
</tr>
<tr>
<td>-i</td>
<td>直接编辑文件</td>
</tr>
</tbody></table>
<ol>
<li>命令功能描述</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><em>a</em></td>
<td>新增，a的后面可以接字串，在下一行出现</td>
</tr>
<tr>
<td>d</td>
<td>删除</td>
</tr>
<tr>
<td>s</td>
<td>查找并替换</td>
</tr>
</tbody></table>
<ol>
<li>案例实操</li>
</ol>
<p>（0）数据准备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ <span class="built_in">touch</span> sed.txt</span><br><span class="line"></span><br><span class="line">[mapan@hadoop102 datas]$ vim sed.txt</span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">wo  wo</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<p>（1）将“mei nv”这个单词插入到sed.txt第二行下，打印。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ sed &#x27;2a mei nv&#x27; sed.txt </span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">mei nv</span><br><span class="line"></span><br><span class="line">wo  wo</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line"></span><br><span class="line">[mapan@hadoop102 datas]$ cat sed.txt </span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">wo  wo</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<p>注意：文件并没有改变</p>
<p>（2）删除sed.txt文件所有包含wo的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ sed <span class="string">&#x27;/wo/d&#x27;</span> sed.txt</span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<p>（3）将sed.txt文件中wo替换为ni</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ sed <span class="string">&#x27;s/wo/ni/g&#x27;</span> sed.txt </span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">guan zhen</span><br><span class="line"></span><br><span class="line">ni  ni</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<p>注意：‘g’表示global，全部替换</p>
<p>（4）将sed.txt文件中的第二行删除并将wo替换为ni</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ sed -e <span class="string">&#x27;2d&#x27;</span> -e <span class="string">&#x27;s/wo/ni/g&#x27;</span> sed.txt </span><br><span class="line"></span><br><span class="line">dong shen</span><br><span class="line"></span><br><span class="line">ni  ni</span><br><span class="line"></span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure>
<h2 id="9-3-awk"><a href="#9-3-awk" class="headerlink" title="9.3 awk"></a>9.3 awk</h2><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p>
<ol>
<li>基本用法</li>
</ol>
<p><code>awk [选项参数] ‘pattern1&#123;action1&#125;  pattern2&#123;action2&#125;...’ filename</code></p>
<p><code>pattern</code>：表示AWK在数据中查找的内容，就是匹配模式</p>
<p><code>action</code>：在找到匹配内容时所执行的一系列命令</p>
<ol>
<li>选项参数说明</li>
</ol>
<table>
<thead>
<tr>
<th>选项参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>指定输入文件折分隔符</td>
</tr>
<tr>
<td>-v</td>
<td>赋值一个用户定义变量</td>
</tr>
</tbody></table>
<ol>
<li>案例实操</li>
</ol>
<p>（0）数据准备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ sudo <span class="built_in">cp</span> /etc/passwd ./</span><br></pre></td></tr></table></figure>
<p>（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk -F: <span class="string">&#x27;/^root/&#123;print $7&#125;&#x27;</span> passwd </span><br><span class="line"></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>
<p>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“，”号分割。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk -F: <span class="string">&#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27;</span> passwd </span><br><span class="line"></span><br><span class="line">root,/bin/bash</span><br></pre></td></tr></table></figure>
<p>注意：只有匹配了pattern的行才会执行action</p>
<p>（3）只显示/etc/passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，/bin/zuishuai”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk -F : <span class="string">&#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END&#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27;</span> passwd</span><br><span class="line"></span><br><span class="line">user, shell</span><br><span class="line"></span><br><span class="line">root,/bin/bash</span><br><span class="line"></span><br><span class="line">bin,/sbin/nologin</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">mapan,/bin/bash</span><br><span class="line"></span><br><span class="line">dahaige,/bin/zuishuai</span><br></pre></td></tr></table></figure>
<p>注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</p>
<p>（4）将passwd文件中的用户id增加数值1并输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk -v i=1 -F: <span class="string">&#x27;&#123;print $3+i&#125;&#x27;</span> passwd</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<ol>
<li>awk的内置变量</li>
</ol>
<table>
<thead>
<tr>
<th>变量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>FILENAME</td>
<td>文件名</td>
</tr>
<tr>
<td>NR</td>
<td>已读的记录数</td>
</tr>
<tr>
<td>NF</td>
<td>浏览记录的域的个数（切割后，列的个数）</td>
</tr>
</tbody></table>
<ol>
<li>案例实操</li>
</ol>
<p>（1）统计passwd文件名，每行的行号，每行的列数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk -F: <span class="string">&#x27;&#123;print &quot;filename:&quot;  FILENAME &quot;, linenumber:&quot; NR  &quot;,columns:&quot; NF&#125;&#x27;</span> passwd </span><br><span class="line"></span><br><span class="line">filename:passwd, linenumber:1,columns:7</span><br><span class="line"></span><br><span class="line">filename:passwd, linenumber:2,columns:7</span><br><span class="line"></span><br><span class="line">filename:passwd, linenumber:3,columns:7</span><br></pre></td></tr></table></figure>
<p>  （2）切割IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ ifconfig eth0 | grep <span class="string">&quot;inet addr&quot;</span> | awk -F: <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> </span><br><span class="line"></span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>

<p>（3）查询sed.txt中空行所在的行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ awk <span class="string">&#x27;/^$/&#123;print NR&#125;&#x27;</span> sed.txt </span><br><span class="line"></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="9-4-sort"><a href="#9-4-sort" class="headerlink" title="9.4 sort"></a>9.4 sort</h2><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p>
<ol>
<li>基本语法</li>
</ol>
<p>sort(选项)(参数)</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>依照数值的大小排序</td>
</tr>
<tr>
<td>-r</td>
<td>以相反的顺序来排序</td>
</tr>
<tr>
<td>-t</td>
<td>设置排序时所用的分隔字符</td>
</tr>
<tr>
<td>-k</td>
<td>指定需要排序的列</td>
</tr>
</tbody></table>
<p>参数：指定待排序的文件列表</p>
<ol start="2">
<li>案例实操</li>
</ol>
<p>（0）数据准备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ <span class="built_in">touch</span> sort.sh</span><br><span class="line"></span><br><span class="line">[mapan@hadoop102 datas]$ vim sort.sh </span><br><span class="line"></span><br><span class="line">bb:40:5.4</span><br><span class="line"></span><br><span class="line">bd:20:4.2</span><br><span class="line"></span><br><span class="line">xz:50:2.3</span><br><span class="line"></span><br><span class="line">cls:10:3.5</span><br><span class="line"></span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure>
<p>（1）按照“：”分割后的第三列倒序排序。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mapan@hadoop102 datas]$ <span class="built_in">sort</span> -t : -nrk 3  sort.sh </span><br><span class="line"></span><br><span class="line">bb:40:5.4</span><br><span class="line"></span><br><span class="line">bd:20:4.2</span><br><span class="line"></span><br><span class="line">cls:10:3.5</span><br><span class="line"></span><br><span class="line">xz:50:2.3</span><br><span class="line"></span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/blog/2148.html</url>
    <content><![CDATA[<p>一开始接触Git是搭建hexo 博客的时候，对Git没有什么理解和印象只感觉是一个上传东西的工具。<br>在刚来上海求职时候，一间公司面试官问我会不会Git，我说了解。现在已经学习了一部分的Git用法和指令，在这里整理记录下来，以备不时之需。</p>
<p>初始化本地仓库<br><code>git init</code></p>
<p>本地仓库添加到暂存区<br><code>git add .</code></p>
<p>提交到主要分支<br><code>git commint -m &quot;XXX&quot;</code></p>
<p>推送到远程仓库<br><code>git push oririn master</code></p>
<p>撤销暂存区的修改<br><code>git checkout -- xxx.xx(文件名)</code></p>
<p>查看当前仓库状态<br><code>git status</code></p>
<p>返回根目录<br><code>cd ../..</code><br>cd命令是切换目录的作用</p>
<p><code>git pull origin master</code>这条指令是把远程仓库拉回本地。<br>但是远程仓库比本地新的时候，需要执行下面一条，意思是把远程的仓库master同步到本地。<br><code>git pull origin master --allow-unrelated-histories</code></p>
<p>使用git add添加要提交的文件的时候，如果文件名是中文，会显示形如<code>274\232\350\256\256\346\200\273\347\273\223.txt</code>的乱码。<br>解决方案：<br>在bash提示符下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.quotepath false  </span><br></pre></td></tr></table></figure>


<p>使用<code>git log</code>或者<code>git commit -m &quot;更新xx文件&quot;</code>显示提交的中文信息乱码。</p>
<p>解决方案：<br>设置git gui的界面编码<br>在bash提示符下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global gui.encoding utf-8 </span><br></pre></td></tr></table></figure>

<p>使用<code>git push origin master</code>提交代码时候出现如下<code>warning</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">warning: LF will be replaced by CRLF in /*/*.***.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br></pre></td></tr></table></figure>
<p>解决方案:<br>在bash提示符下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false  //禁止自动转换</span><br></pre></td></tr></table></figure>

<p>千万不要手贱执行下面的命令<br><code>rm -rf .git</code><br>这是删除<code>.git</code>文件夹的命令，删除了就不太容易找回来了，不会告诉你我是怎么知道的。<br>还有<code>git clean -df</code>这条指令。不要碰</p>
]]></content>
  </entry>
  <entry>
    <title>再谈电子DIY</title>
    <url>/blog/58c8.html</url>
    <content><![CDATA[<p>今天无意翻到一个<a href="http://www.pengzhihui.xyz/">稚晖的博客</a>，看到那些精美的电子制作，把自己的创意一个个变为实物。这种过程真是极美的，又想到自己在大学的时候，那股认真劲儿。大学时候并没有高人指点，另外由于囊中羞涩，许多设备也买不起，没有3D打印机这类高端玩意儿，PCB还仅限于手工制版的阶段，限于工艺限制也只能画单层板，然而这就玩的不亦乐乎。</p>
<p>就现在的工作认识来看，一个创意从雏形到实物无非就是把创意变成产品，然后卖出去。然而大学里并不考虑卖产品，仅仅限于好玩，开阔专业视野。</p>
<p>要玩得好电子DIY，把自己的小点子和创意实现。<br>首先需要最基础的模电数电知识，这是硬件搭建的基础。</p>
<p>原理图要逻辑清晰，原理连接无误，绘制出尽量小的PCB板。可以淘宝打板或者手工制板(麻烦)</p>
<ul>
<li>这就需要一定的EDA基础，学会PADS 、Altium等EDA软件。</li>
</ul>
<p>程序就是小制作的灵魂，是你的创意实现的过程</p>
<ul>
<li>一般使用C、C++等语言。</li>
</ul>
<p>ID设计，如果有条件可以用3D打印机，打印出外壳，把硬件电路放壳子里。</p>
<ul>
<li>我没有涉及过，不知要学什么。简单点一把热胶枪可以搞定许多事情。</li>
</ul>
<p>要做出精美的制作，上面3步都需要做的相当好。</p>
<p>现在的我，工作一年多了，已经慢慢离开了电子工程，转到计算机科学方向，都已经褪去了这种激情，只剩下写Bug和Debug。<br>没有心思再做什么DIY啦！</p>
]]></content>
      <categories>
        <category>电子</category>
      </categories>
  </entry>
  <entry>
    <title>密码和方言</title>
    <url>/blog/3e9.html</url>
    <content><![CDATA[<p>今天在思考一个问题，如何加密数据才能让自己的通信更安全。诸如我们所使用的微信和QQ、短信等，均有可能被第三方监视和窃取。在这个大数据的时代，自己怎么才能不<strong>被</strong>大数据了呢？</p>
<p>今天上班走在路上听见前面阿姨大妈用上海话叽里呱啦的说话，我一句也听不懂。忽然脑袋里就跳出一个想法，对我来说这不就是所谓的加密了么？</p>
<p>如果把每个人都看成一个系统，那么两个系统之间的通信，可以被中间者窃听，但是能不能解码出其中的含义就不一定了。</p>
<blockquote>
<p>普通话就是为了人与人沟通方便，而约定的一种<code>开源</code>的沟通传递工具语言。</p>
</blockquote>
<blockquote>
<p>每个人都会说，能听得懂。对每个人来说，相当于明文。</p>
</blockquote>
<blockquote>
<p>对外地人来说，上海话听不懂，在自己的语言系统中，听不懂。上海话就是一个经过加密的信息，密钥就是上海话的说法，说上海话就是加密，听上海话就是解密。</p>
</blockquote>
<blockquote>
<p>上海人即能听得懂，又会说的出。这样就完成了最基本的加密解密。</p>
</blockquote>
<p>抛开通信的原理不讲，只当通信系统是一个黑盒，微信和QQ是一个黑盒。在这个黑盒实现通信的过程中，是经过第三方的服务器的，数据是有可能<strong>被</strong>大数据的。</p>
<p>为了保障被践踏的隐私权，我们怎么办呢？</p>
<p>回到上海阿姨说上海话，如果上海话只有谈话间的阿姨两个人可以听得懂，那么这次谈话就是安全的。在这次安全的通信中，上海话充当了密钥的作用。</p>
<p>由于上海话即可以说也可以听，所以就充当了加密和解密的两个作用，所以属于对称加密。</p>
<blockquote>
<p>这样一来，上海话就是属于一种对称加密算法。</p>
</blockquote>
<p>我在想，可以借助如微信、QQ等现有的通信工具，实现简单的通信加密。在发送信息之前，发送的信息经过RSA非对称算法加密，对方收到的消息是一堆乱码。经过密钥解密之后，才可以看到真实的信息。实现类似的效果：</p>
<blockquote>
<p>A: Gjhk89kjh89HKJ)6%76GHBJk7T%^90hlkG&amp;^</p>
</blockquote>
<blockquote>
<p>B: &amp;(HG^8ThhniJ09(yhKH89^Y&amp;^)ijlGyih()uij)</p>
</blockquote>
<blockquote>
<p>A: asdBH和ugdas82^9780HJ#@56gh^Jk0U5</p>
</blockquote>
<blockquote>
<p>B: #$khj)j^JjY8jLK;p-)978&amp;^667yh^%%$</p>
</blockquote>
<blockquote>
<p>A: HJh&amp;uhy速JKHJuu6hH”sd9kG%j%ijH_=Its </p>
</blockquote>
<blockquote>
<p>B: ASHGd876asd5%$^f%^TTG7G&amp;g7y78T6rt%R%5e</p>
</blockquote>
<hr>
<p>自己太菜，并没有技术能力实现。只是灵机一动的想法，如果有机会再去学习相关知识，先马一下自己灵感。</p>
<hr>
<p>琢磨了一下，需要安卓手机安装Xposed，还要写相对应的框架，自己微信和QQ还有被封的风险，还是算了吧。</p>
]]></content>
      <categories>
        <category>灵感一现</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop之集群搭建</title>
    <url>/blog/21a2.html</url>
    <content><![CDATA[<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><p>三台linux服务器：系统：双核CPU，CentOS6.8、内存：4G、硬盘：50G+</p>
<p>服务器对应的hostname和IP地址</p>
<table>
<thead>
<tr>
<th align="center">hostname</th>
<th align="center">ip</th>
</tr>
</thead>
<tbody><tr>
<td align="center">linux101</td>
<td align="center">192.168.1.101</td>
</tr>
<tr>
<td align="center">linux102</td>
<td align="center">192.168.1.102</td>
</tr>
<tr>
<td align="center">linux103</td>
<td align="center">192.168.1.103</td>
</tr>
</tbody></table>
<p>集群规划：</p>
<table>
<thead>
<tr>
<th align="center">linux101</th>
<th align="center">linux102</th>
<th align="center">linux103</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DataNode</td>
<td align="center">DataNode</td>
<td align="center">DataNode</td>
</tr>
<tr>
<td align="center">NodeManager</td>
<td align="center">NodeManager</td>
<td align="center">NodeManager</td>
</tr>
<tr>
<td align="center">NameNode</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">ResourceManager</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">JobHistoryServer</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">hadoop使用2.7.2版本，<a href="https://archive.apache.org/dist/hadoop/core/hadoop-2.7.2/">下载地址</a>, 安装包名为<code>hadoop-2.7.2.tar.gz</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">JDK使用jdk8_144版本，<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html">下载地址</a>, 安装包名为<code>jdk-8u144-linux-x64.tar.gz</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">使用root用户登录linux101</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">依次配置三台服务器的/etc/hosts</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>vim /etc/hosts</code></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.101   linux101</span><br><span class="line">192.168.1.102   linux102</span><br><span class="line">192.168.1.103   linux103</span><br></pre></td></tr></table></figure>
<h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><p>在三台服务器各创建一个普通用户mapan，并配置密码<br><code>useradd mapan</code><br><code>passwd 123456</code></p>
<p>配置这个用户为sudoers<br><code>vim /etc/sudoers</code><br>在<code>root    ALL=(ALL)       ALL</code>一行下面<br>添加<code>mapan    ALL=(ALL)       NOPASSWD:ALL</code><br>保存时wq!强制保存</p>
<p>在/opt目录下创建两个文件夹module和software，并把所有权赋给mapan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/module /opt/software</span><br><span class="line"><span class="built_in">chown</span> mapan:mapan /opt/module /opt/software</span><br></pre></td></tr></table></figure>
<h1 id="创建分发脚本"><a href="#创建分发脚本" class="headerlink" title="创建分发脚本"></a>创建分发脚本</h1><p>以下使用mapan用户登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /bin/xsync</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#1. 判断参数个数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Not Enough Arguement!</span><br><span class="line">    <span class="built_in">exit</span>;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 遍历所有目录，挨个发送</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment">#4.5 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="variable">$file</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment">#3. 获取父目录</span></span><br><span class="line">        pdir=$(<span class="built_in">cd</span> -P $(<span class="built_in">dirname</span> <span class="variable">$file</span>); <span class="built_in">pwd</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#4. 获取当前文件的名称</span></span><br><span class="line">        fname=$(<span class="built_in">basename</span> <span class="variable">$file</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#5. 遍历集群所有机器，拷贝</span></span><br><span class="line">        <span class="keyword">for</span> host <span class="keyword">in</span> linux101 linux102 linux103</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">echo</span> ====================    <span class="variable">$host</span>    ====================</span><br><span class="line">            ssh <span class="variable">$host</span> <span class="string">&quot;mkdir -p <span class="variable">$pdir</span>&quot;</span></span><br><span class="line">            rsync -av <span class="variable">$pdir</span>/<span class="variable">$fname</span> <span class="variable">$USER</span>@<span class="variable">$host</span>:<span class="variable">$pdir</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$file</span> does not exists!</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h1 id="创建群呼脚本"><a href="#创建群呼脚本" class="headerlink" title="创建群呼脚本"></a>创建群呼脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /bin/xcall</span><br></pre></td></tr></table></figure>
<p>输入下面内容并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> linux101 linux102 linux103</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">echo</span> ---------<span class="variable">$i</span>---------</span><br><span class="line">	ssh <span class="variable">$i</span> <span class="string">&quot;$*&quot;</span> </span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;			&quot;</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;			&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>赋执行权限，分发上面的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /bin/xsync /bin/xcall</span><br><span class="line">sudo xsync /bin/xsync /bin/xcall</span><br></pre></td></tr></table></figure>
<h1 id="配置免密登陆"><a href="#配置免密登陆" class="headerlink" title="配置免密登陆"></a>配置免密登陆</h1><ol>
<li>生成密钥对<br><code>ssh-keygen -t rsa</code> 三次回车</li>
<li>发送公钥到本机<br><code>ssh-copy-id linux001</code> 输入一次密码</li>
<li>分别ssh登陆一下所有虚拟机<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh linux102</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">ssh linux103</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure></li>
<li>把~/.ssh 文件夹发送到集群所有服务器<br><code>xsync ~/.ssh</code></li>
</ol>
<h1 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h1><p>关闭四台服务器的防火墙和SELINUX</p>
<p>查看防火墙状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service iptables stop </span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>

<p>关闭SELINUX</p>
<p><code>sudo vim /etc/selinux/config</code></p>
<p>修改SELINUX的属性为<code>disable</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>分发config文件</p>
<p><code>sudo xsync /etc/selinux/config</code></p>
<p>重启三台服务器</p>
<h1 id="安装jdk和hadoop"><a href="#安装jdk和hadoop" class="headerlink" title="安装jdk和hadoop"></a>安装jdk和hadoop</h1><p>先在一台机器上安装Java和Hadoop，并配置环境变量，并分发到集群其他机器<br>准备安装文件<br><code>jdk-8u144-linux-x64.tar.gz</code><br><code>hadoop-2.7.2.tar.gz</code></p>
<ol>
<li><p>拷贝安装文件到<code>/opt/software</code>，两个tar包</p>
</li>
<li><p><code>tar -zxvf /opt/software/hadoop-2.7.2.tar.gz -C /opt/module</code></p>
</li>
<li><p><code>tar -zxvf /opt/software/jdk-8u144-linux-x64.tar.gz -C /opt/module</code></p>
</li>
<li><p><code>sudo vim /etc/profile.d/jdk.sh</code><br>输入下面内容并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#JAVA_HOME</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="comment"># 注: jdk1.7及之前需要配置classpath变量，1.7之后不需要</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>sudo vim /etc/profile.d/hadoop.sh</code><br>输入下面内容并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#HADOOP_HOME</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/opt/module/hadoop-2.7.2</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin</span><br></pre></td></tr></table></figure></li>
<li><p>同步JDK和hadoop的安装文件<br><code>xsync /opt/module</code></p>
</li>
<li><p>同步环境变量的配置文件<br><code>sudo xsync /etc/profile.d/jdk.sh /etc/profile.d/hadoop.sh</code></p>
</li>
<li><p>使三台服务器的环境变量生效<br><code>xcall source /etc/profile</code></p>
</li>
</ol>
<h1 id="配置hadoop"><a href="#配置hadoop" class="headerlink" title="配置hadoop"></a>配置hadoop</h1><p> 所有配置文件都在$HADOOP_HOME/etc/hadoop<br> 一共有8个文件需要配置：</p>
<table>
<thead>
<tr>
<th align="center">*-env.sh</th>
<th align="center">*-site.xml</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hadoop-env.sh</td>
<td align="center">hdfs-site.xml</td>
</tr>
<tr>
<td align="center">yarn-env.sh</td>
<td align="center">yarn-site.xml</td>
</tr>
<tr>
<td align="center">mapred-env.sh</td>
<td align="center">mapred-site.xml</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">core-site.xml</td>
</tr>
</tbody></table>
<p>最后一个是slaves文件。</p>
<ol>
<li><p>首先配置<code>hadoop-env.sh</code>,<code>yarn-env.sh</code>,<code>mapred-env.sh</code>文件,配置JAVA_HOME<br>在每个文件第二行添加 <code>export JAVA_HOME=/opt/module/jdk1.8.0_144</code></p>
</li>
<li><p>配置Core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定HDFS中NameNode的地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://linux101:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定Hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/module/hadoop-2.7.2/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置hdfs-site.xml</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据的副本数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置yarn-site.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Reducer获取数据的方式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定YARN的ResourceManager的地址 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux102<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志聚集功能使能 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志保留时间设置7天 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>配置mapred-site.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 历史服务器端地址 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux101:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 历史服务器web端地址 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>linux101:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动历史服务器的命令：<code>mr-jobhistory-daemon.sh start historyserver</code></p>
<ol start="6">
<li><p>配置slaves文件<br>注意slaves文件不要有空格，不要有空行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux101</span><br><span class="line">linux102</span><br><span class="line">linux103</span><br></pre></td></tr></table></figure></li>
<li><p>分发配置文件<br><code>xsync /opt/module/hadoop-2.7.2/etc</code></p>
</li>
<li><p>在linux001上格式化Namenode<br><code>hdfs namenode -format</code></p>
</li>
<li><p>启动hdfs<br><code>start-dfs.sh</code></p>
</li>
<li><p>在配置了Resourcemanager机器linux002上启动yarn<br><code>start-yarn.sh</code></p>
</li>
</ol>
<h1 id="编写hadoop脚本"><a href="#编写hadoop脚本" class="headerlink" title="编写hadoop脚本"></a>编写hadoop脚本</h1><p>每次开集群都需要单个执行上面脚本，于是可以编写一个集群启动/停止脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line"><span class="built_in">mkdir</span> bin</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">vim hdp</span><br></pre></td></tr></table></figure>
<p>输入下面内容并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;start&quot;</span>)&#123;</span><br><span class="line">	ssh linux101 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/start-dfs.sh&quot;</span></span><br><span class="line"></span><br><span class="line">	ssh linux102 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/start-yarn.sh&quot;</span></span><br><span class="line"></span><br><span class="line">	ssh linux101 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh start historyserver&quot;</span></span><br><span class="line">&#125;;;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;stop&quot;</span>)&#123;</span><br><span class="line"></span><br><span class="line">	ssh linux101 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/mr-jobhistory-daemon.sh stop historyserver&quot;</span></span><br><span class="line"></span><br><span class="line">	ssh linux102 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/stop-yarn.sh&quot;</span></span><br><span class="line"></span><br><span class="line">	ssh linux101 <span class="string">&quot;/opt/module/hadoop-2.7.2/sbin/stop-dfs.sh&quot;</span></span><br><span class="line">&#125;;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>给予执行权限<br><code>chmod +x hdp</code><br>以后每次开启集群只需要 执行 <code>hdp start</code><br>关闭集群只需要<code>hdp stop</code></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop集群优化</title>
    <url>/blog/929b.html</url>
    <content><![CDATA[<h2 id="HDFS小文件的影响："><a href="#HDFS小文件的影响：" class="headerlink" title="HDFS小文件的影响："></a>HDFS小文件的影响：</h2><ol>
<li>影响NameNode的寿命，文件的元数据存储在NameNode的内存当中</li>
<li>音响计算引擎的任务数量，比如每个小的文件都会生成一个Map任务</li>
</ol>
<h2 id="数据输入小文件处理："><a href="#数据输入小文件处理：" class="headerlink" title="数据输入小文件处理："></a>数据输入小文件处理：</h2><ol>
<li>合并小文件：对小文件进行归档（Har）、自定义Inputformat将小文件存储成SequenceFile文件。</li>
<li>采用ConbinFileInputFormat来作为输入，解决输入端大量小文件场景。</li>
<li>对于大量小文件Job，可以开启JVM重用。</li>
</ol>
<h2 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h2><ol>
<li>增大环形缓冲区大小。由100m扩大到200m</li>
<li>增大环形缓冲区溢写的比例。由80%扩大到90%</li>
<li>减少对溢写文件的merge次数。</li>
<li>不影响实际业务的前提下，采用Combiner提前合并，减少 I/O。</li>
</ol>
<h2 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h2><ol>
<li><p>合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致 Map、Reduce任务间竞争资源，造成处理超时等错误。</p>
</li>
<li><p>设置Map、Reduce共存：调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。</p>
</li>
<li><p>规避使用Reduce，因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</p>
</li>
<li><p>增加每个Reduce去Map中拿数据的并行数</p>
</li>
<li><p>集群性能可以的前提下，增大Reduce端存储数据内存的大小。</p>
</li>
</ol>
<h2 id="IO传输"><a href="#IO传输" class="headerlink" title="IO传输"></a>IO传输</h2><ol>
<li>采用数据压缩的方式，减少网络IO的的时间。安装Snappy和LZOP压缩编码器。</li>
<li>使用SequenceFile二进制文件</li>
</ol>
<h2 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h2><ol>
<li>MapTask默认内存大小为1G，可以增加MapTask内存大小为4-5g</li>
<li>ReduceTask默认内存大小为1G，可以增加ReduceTask内存大小为4-5g</li>
<li>可以增加MapTask的cpu核数，增加ReduceTask的CPU核数</li>
<li>增加每个Container的CPU核数和内存大小</li>
<li>调整每个Map Task和Reduce Task最大重试次数</li>
</ol>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop序列化</title>
    <url>/blog/51f3.html</url>
    <content><![CDATA[<p>Hadoop序列化<br>序列化就是吧内存中的对象没转换成字节序列，以便于存储到磁盘和网络传输。<br>反序列化就是将收到的字节序列，或者磁盘的持久化数据，转换成内存中的对象。<br>为什么需要序列化<br>一般来说获得对象滋生存在内存里，关机断电就没了，而且活的对象只能由本地的进程使用，不能被发送到网路上的另外一台计算机，然而序列化可以存储活的对象，可以将活的对象发送到远程计算机。</p>
<p>为什么不用Java的序列化<br>Java的序列化是一个重量级序列化框架，一个对象被序列化以后，会附带很多额外的信息，不便于在网络中高效的传输。所以Hadoop自己开发了一套序列化机制。<br>Hadoop序列化特点：<br>1、紧凑<br>2、快速<br>3、可扩展<br>4、互操作</p>
<p>自定义bean对象实现序列化接口<br>在企业开发中往往常用的基本序列化类型不能满足所有需求，比如在Hadoop框架内部传递一个bean对象，那么该对象就需要实现序列化接口。<br>具体实现bean对象序列化步骤如下7步。<br>（1）必须实现Writable接口<br>（2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造<br>（3）重写序列化方法<br>（4）重写反序列化方法<br>（5）注意反序列化的顺序和序列化的顺序完全一致<br>（6）要想把结果显示在文件中，需要重写toString()，可用”\t”分开，方便后续用。<br>（7）如果需要将自定义的bean放在key中传输，则还需要实现Comparable接口，因为MapReduce框中的Shuffle过程要求对key必须能排序。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>RDD的持久化机制</title>
    <url>/blog/56dc.html</url>
    <content><![CDATA[<h3 id="RDD的持久化机制"><a href="#RDD的持久化机制" class="headerlink" title="RDD的持久化机制"></a>RDD的持久化机制</h3><p>弹性分布式数据集（RDD）作为 Spark 最根本的数据抽象，是只读的分区记录（Partition）的集合，只能基于在稳定物理存储中的数据集上创建，或者在其他已有的 RDD 上执行转换（Transformation）操作产生一个新的 RDD。转换后的 RDD 与原始的 RDD 之间产生的依赖关系，构成了血统（Lineage）。<strong>凭借血统，Spark</strong> <strong>保证了每一个</strong> <strong>RDD</strong> <strong>都可以被重新恢复</strong>。但 RDD 的所有转换都是惰性的，即只有当一个返回结果给 Driver 的行动（Action）发生时，Spark 才会创建任务读取 RDD，然后真正触发转换的执行。</p>
<p>Task 在启动之初读取一个分区时，会先判断这个分区是否已经被持久化，如果没有则需要检查 Checkpoint 或按照血统重新计算。所以如果一个 RDD 上要执行多次行动，可以在第一次行动中使用 persist 或 cache 方法，在内存或磁盘中持久化或缓存这个 RDD，从而在后面的行动时提升计算速度。</p>
<p>事实上，cache 方法是使用默认的 MEMORY_ONLY 的存储级别将 RDD 持久化到内存，故缓存是一种特殊的持久化。 <strong>堆内和堆外存储内存的设计，便可以对缓存</strong> <strong>RDD</strong> <strong>时使用的内存做统一的规划和管理</strong>。</p>
<p>RDD 的持久化由 Spark 的 Storage 模块负责，实现了 RDD 与物理存储的解耦合。Storage 模块负责管理 Spark 在计算过程中产生的数据，将那些在内存或磁盘、在本地或远程存取数据的功能封装了起来。在具体实现时 Driver 端和 Executor 端的 Storage 模块构成了主从式的架构，即 Driver 端的 BlockManager 为 Master，Executor 端的 BlockManager 为 Slave。</p>
<p>Storage 模块在逻辑上以 Block 为基本存储单位，<strong>RDD</strong> <strong>的每个</strong> <strong>Partition</strong> <strong>经过处理后唯一对应一个</strong> <strong>Block</strong>（BlockId 的格式为 rdd_RDD-ID_PARTITION-ID ）。Driver端的Master 负责整个 Spark 应用程序的 Block 的元数据信息的管理和维护，而Executor端的 Slave 需要将 Block 的更新等状态上报到 Master，同时接收 Master 的命令，例如新增或删除一个 RDD。</p>
<img src="/blog/56dc/clip_image001.jpg" class="img">

<p>在对 RDD 持久化时，Spark 规定了 MEMORY_ONLY、MEMORY_AND_DISK 等 7 种不同的<a href="http://spark.apache.org/docs/latest/programming-guide.html#rdd-persistence">存储级别 </a>，而存储级别是以下 5 个变量的组合：</p>
<p>resourceOffer代码</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StorageLevel</span> <span class="title">private</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">private var _useDisk: <span class="type">Boolean</span>, //磁盘</span></span></span><br><span class="line"><span class="params"><span class="class">private var _useMemory: <span class="type">Boolean</span>, //这里其实是指堆内内存</span></span></span><br><span class="line"><span class="params"><span class="class">private var _useOffHeap: <span class="type">Boolean</span>, //堆外内存</span></span></span><br><span class="line"><span class="params"><span class="class">private var _deserialized: <span class="type">Boolean</span>, //是否为非序列化</span></span></span><br><span class="line"><span class="params"><span class="class">private var _replication: <span class="type">Int</span> = 1 //副本个数</span></span></span><br><span class="line"><span class="params"><span class="class"></span>)</span></span><br></pre></td></tr></table></figure>

<p>Spark中7种存储级别如下：</p>
<table>
<thead>
<tr>
<th><strong>持久化级别</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>MEMORY_ONLY</strong></td>
<td>以非序列化的Java对象的方式持久化在JVM内存中。如果内存无法完全存储RDD所有的partition，那么那些没有持久化的partition就会在下一次需要使用它们的时候，重新被计算</td>
</tr>
<tr>
<td><strong>MEMORY_AND_DISK</strong></td>
<td>同上，但是当某些partition无法存储在内存中时，会持久化到磁盘中。下次需要使用这些partition时，需要从磁盘上读取</td>
</tr>
<tr>
<td><strong>MEMORY_ONLY_SER</strong></td>
<td>同MEMORY_ONLY，但是会使用Java序列化方式，将Java对象序列化后进行持久化。可以减少内存开销，但是需要进行反序列化，因此会加大CPU开销</td>
</tr>
<tr>
<td><strong>MEMORY_AND_DISK_SER</strong></td>
<td>同MEMORY_AND_DISK，但是使用序列化方式持久化Java对象</td>
</tr>
<tr>
<td><strong>DISK_ONLY</strong></td>
<td>使用非序列化Java对象的方式持久化，完全存储到磁盘上</td>
</tr>
<tr>
<td><strong>MEMORY_ONLY_2</strong>   <strong>MEMORY_AND_DISK_2</strong>   <strong>等等</strong></td>
<td>如果是尾部加了2的持久化级别，表示将持久化数据复用一份，保存到其他节点，从而在数据丢失时，不需要再次计算，只需要使用备份数据即可</td>
</tr>
</tbody></table>
<p>通过对数据结构的分析，可以看出存储级别从三个维度定义了 RDD 的 Partition（同时也就是 Block）的存储方式：</p>
<ol>
<li><strong>存储位置</strong>：磁盘／堆内内存／堆外内存。如      MEMORY_AND_DISK 是同时在磁盘和堆内内存上存储，实现了冗余备份。OFF_HEAP      则是只在堆外内存存储，目前选择堆外内存时不能同时存储到其他位置。</li>
<li><strong>存储形式</strong>：Block 缓存到存储内存后，是否为非序列化的形式。如 MEMORY_ONLY 是非序列化方式存储，OFF_HEAP 是序列化方式存储。</li>
<li><strong>副本数量</strong>：大于 1 时需要远程冗余备份到其他节点。如 DISK_ONLY_2 需要远程备份 1 个副本。</li>
</ol>
<h3 id="RDD的缓存过程"><a href="#RDD的缓存过程" class="headerlink" title="RDD的缓存过程"></a>RDD的缓存过程</h3><p>RDD 在缓存到存储内存之前，Partition 中的数据一般以迭代器（<a href="http://www.scala-lang.org/docu/files/collections-api/collections_43.html">Iterator</a>）的数据结构来访问，这是 Scala 语言中一种遍历数据集合的方法。通过 Iterator 可以获取分区中每一条序列化或者非序列化的数据项(Record)，这些 Record 的对象实例在逻辑上占用了 JVM 堆内内存的 other 部分的空间，<strong>同一</strong> <strong>Partition</strong> <strong>的不同</strong> <strong>Record</strong> <strong>的存储空间并不连续</strong>。</p>
<p>RDD 在缓存到存储内存之后，Partition 被转换成 Block，Record 在堆内或堆外存储内存中占用一块连续的空间。<strong>将Partition由不连续的存储空间转换为连续存储空间的过程，Spark称之为”展开”（Unroll）</strong>。</p>
<p>Block 有序列化和非序列化两种存储格式，具体以哪种方式取决于该 RDD 的存储级别。非序列化的 Block 以一种 DeserializedMemoryEntry 的数据结构定义，用一个数组存储所有的对象实例，序列化的 Block 则以 SerializedMemoryEntry的数据结构定义，用字节缓冲区（ByteBuffer）来存储二进制数据。每个 Executor 的 Storage 模块用一个链式 Map 结构（LinkedHashMap）来管理堆内和堆外存储内存中所有的 Block 对象的实例，对这个 LinkedHashMap 新增和删除间接记录了内存的申请和释放。</p>
<p><strong>因为不能保证存储空间可以一次容纳</strong> <strong>Iterator</strong> <strong>中的所有数据，当前的计算任务在</strong> <strong>Unroll</strong> <strong>时要向</strong> <strong>MemoryManager</strong> <strong>申请足够的</strong> <strong>Unroll</strong> <strong>空间来临时占位，空间不足则</strong> <strong>Unroll</strong> <strong>失败，空间足够时可以继续进行</strong>。</p>
<p>对于序列化的 Partition，其所需的 Unroll 空间可以直接累加计算，一次申请。</p>
<p>对于非序列化的 Partition 则要在遍历 Record 的过程中依次申请，即每读取一条 Record，采样估算其所需的 Unroll 空间并进行申请，空间不足时可以中断，释放已占用的 Unroll 空间。</p>
<p>如果最终 Unroll 成功，当前 Partition 所占用的 Unroll 空间被转换为正常的缓存 RDD 的存储空间，如下图所示。</p>
<img src="/blog/56dc/clip_image002.jpg" class="img">

<p> Spark Unroll</p>
<p>在静态内存管理时，Spark 在存储内存中专门划分了一块 Unroll 空间，其大小是固定的，统一内存管理时则没有对 Unroll 空间进行特别区分，当存储空间不足时会根据动态占用机制进行处理。</p>
<h3 id="淘汰与落盘"><a href="#淘汰与落盘" class="headerlink" title="淘汰与落盘"></a>淘汰与落盘</h3><p><strong>由于同一个</strong> <strong>Executor</strong> <strong>的所有的计算任务共享有限的存储内存空间，当有新的</strong> <strong>Block</strong> <strong>需要缓存但是剩余空间不足且无法动态占用时，就要对</strong> <strong>LinkedHashMap</strong> <strong>中的旧</strong> <strong>Block</strong> <strong>进行淘汰（Eviction），而被淘汰的</strong> <strong>Block</strong> <strong>如果其存储级别中同时包含存储到磁盘的要求，则要对其进行落盘（Drop），否则直接删除该</strong> <strong>Block</strong>。</p>
<p>存储内存的淘汰规则为：</p>
<ul>
<li>被淘汰的旧 Block 要与新 Block 的 MemoryMode 相同，即同属于堆外或堆内内存；</li>
<li>新旧 Block 不能属于同一个 RDD，避免循环淘汰；</li>
<li>旧 Block 所属 RDD 不能处于被读状态，避免引发一致性问题；</li>
<li>遍历 LinkedHashMap 中 Block，按照最近最少使用（LRU）的顺序淘汰，直到满足新 Block 所需的空间。其中 LRU 是 LinkedHashMap 的特性。</li>
</ul>
<p>落盘的流程则比较简单，如果其存储级别符合_useDisk 为 true 的条件，再根据其_deserialized 判断是否是非序列化的形式，若是则对其进行序列化，最后将数据存储到磁盘，在 Storage 模块中更新其信息。</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客实现后台管理</title>
    <url>/blog/ab82.html</url>
    <content><![CDATA[<p>Hexo博客是是静态的方式，原理是通过本地.md文件生成静态的.html文件，通过git指令把.html文件上传到服务器(或者代码托管平台)。和Wordpress相比，缺少了许多动态博客能实现的功能，比如后台管理，评论，文章阅读数等等需要实时和服务器交互的动作。但是随着技术的发展，这些功能逐一被攻克。文章阅读计数，网站访问量可以通过<a href="http://busuanzi.ibruce.info/">不蒜子</a>来实现。评论可以通过第三方评论（友言，网易云跟帖，畅言等等）来实现。后台管理可以通过插件<a href="http://jaredforsyth.com/hexo-admin/">Hexo-Admin</a>来实现。<br>今天把这个Hexo-Admin插件的安装和使用方法记录下来。<br>由于官方插件对windows平台的有一些bug，所以我们安装升级版。<br>1、首先你已经搭建好了自己的hexo博客。<br>2、在命令行中依次输入下面三条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin-yf</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure>
<p>第一条命令是安装Hexo-Admin插件，时间可能长一些。<br>第二条命令是打开本地服务器。<br>第三条是在浏览器中打开<a href="http://localhost:4000/admin">http://localhost:4000/admin</a></p>
<p>3、修改Hexo根目录(以下统称<code>D:\Blog</code>)下<code>_config.yml</code>文件，在合适位置添加以下代码。这段代码的作用是设置用户名和密码，空着为无密码。详细内容可以在设置里面修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hexo-admin authentification</span><br><span class="line">admin:</span><br><span class="line">  username: </span><br><span class="line">  password_hash:</span><br><span class="line">  secret:</span><br><span class="line">  deployCommand: &#x27;deploy.cmd&#x27;</span><br></pre></td></tr></table></figure>

<p>4、在<code>D:\Blog</code>目录下创建<code>deploy.cmd</code>并写入一下内容。这个脚本的作用是渲染html、压缩html，css和js、部署文件到服务器端。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">call hexo g</span><br><span class="line">call gulp</span><br><span class="line">call hexo d</span><br></pre></td></tr></table></figure>

<p>5、在<code>C:\Users\username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>下创建<code>hexo_s.vbs</code>,写入以下内容。作用是开机自动运行<code>D:\Blog\Start.bat</code>脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set ws=WScript.CreateObject(&quot;WScript.Shell&quot;)</span><br><span class="line">ws.Run &quot;D:\\Blog\\Start.bat /start&quot;,0</span><br></pre></td></tr></table></figure>

<p>6、在<code>D:\Blog</code>目录下新建<code>Start.bat</code>并写入以下内容。作用是在<code>D:/Blog</code>运行<code>hexo s</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:/Blog</span><br><span class="line">hexo s -d</span><br></pre></td></tr></table></figure>

<p>7、在<code>D:\Blog</code>目录下新<code>browser.bat</code>并写入以下内容,这个脚本的作用是打开浏览器进入<a href="http://localhost:4000/admin">http://localhost:4000/admin</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">start explorer http://localhost:4000/admin</span><br></pre></td></tr></table></figure>
<p>右键该脚本<code>发送到桌面</code>,下次开机直接双击该快捷方式即可。</p>
<hr>
<p>我对这个插件进行了汉化，汉化需要修改的文件是<code>D:\Blog\node_modules\hexo-admin-yf\www\bundle.js</code></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>SQL的两道练习</title>
    <url>/blog/d61c.html</url>
    <content><![CDATA[<p>找了两道Hive有关的SQL练习题目，第一道是统计用户浏览量的数据。第二道是统计京东商铺浏览量的数据。</p>
<h1 id="（一）统计用户浏览量"><a href="#（一）统计用户浏览量" class="headerlink" title="（一）统计用户浏览量"></a>（一）统计用户浏览量</h1><p>我们有如下的用户访问数据</p>
<table>
<thead>
<tr>
<th align="center">userId</th>
<th align="center">visitDate</th>
<th align="center">visitCount</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u01</td>
<td align="center">2017/1/21</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">u02</td>
<td align="center">2017/1/23</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">u03</td>
<td align="center">2017/1/22</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">u04</td>
<td align="center">2017/1/20</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">u01</td>
<td align="center">2017/1/23</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">u01</td>
<td align="center">2017/2/21</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">u02</td>
<td align="center">2017/1/23</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">u01</td>
<td align="center">2017/2/22</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>要求使用SQL统计出每个用户的累积访问次数，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">用户id</th>
<th align="center">月份</th>
<th align="center">小计</th>
<th align="center">累积</th>
</tr>
</thead>
<tbody><tr>
<td align="center">u01</td>
<td align="center">2017-01</td>
<td align="center">11</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">u01</td>
<td align="center">2017-02</td>
<td align="center">12</td>
<td align="center">23</td>
</tr>
<tr>
<td align="center">u02</td>
<td align="center">2017-01</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">u03</td>
<td align="center">2017-01</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">u04</td>
<td align="center">2017-01</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p><a href="./d61c/action.txt">原始数据</a>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u01     2017/1/21       5</span><br><span class="line">u02     2017/1/23       6</span><br><span class="line">u03     2017/1/22       8</span><br><span class="line">u04     2017/1/20       3</span><br><span class="line">u01     2017/1/23       6</span><br><span class="line">u01     2017/2/21       8</span><br><span class="line">u02     2017/1/23       6</span><br><span class="line">u01     2017/2/22       4</span><br></pre></td></tr></table></figure>
<p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> action</span><br><span class="line">(userId string,</span><br><span class="line">visitDate string,</span><br><span class="line">visitCount <span class="type">int</span>) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> &quot;\t&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><p>一、首先转换月份格式，统计每个月、每个用户的访问量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    userid id , </span><br><span class="line">    date_format(REGEXP_REPLACE(visitdate,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>),<span class="string">&#x27;yyyy-MM&#x27;</span>) mon , </span><br><span class="line">    <span class="built_in">sum</span>(visitcount) views</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    action</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    userid , visitdate;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	mon	views</span><br><span class="line">u01	2017-01	5</span><br><span class="line">u01	2017-01	6</span><br><span class="line">u01	2017-02	8</span><br><span class="line">u01	2017-02	4</span><br><span class="line">u02	2017-01	12</span><br><span class="line">u03	2017-01	8</span><br><span class="line">u04	2017-01	3</span><br></pre></td></tr></table></figure>
<p>二、再按照月份和用户进行分组并统计访问量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id , </span><br><span class="line">    mon , </span><br><span class="line">    <span class="built_in">sum</span>(visitcount) views</span><br><span class="line"><span class="keyword">FROM</span>(<span class="keyword">SELECT</span> </span><br><span class="line">    userid id , </span><br><span class="line">    date_format(REGEXP_REPLACE(visitdate,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>),<span class="string">&#x27;yyyy-MM&#x27;</span>) mon , </span><br><span class="line">    visitcount</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    action) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> id ,mon;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	mon	views</span><br><span class="line">u01	2017-01	11</span><br><span class="line">u01	2017-02	12</span><br><span class="line">u02	2017-01	12</span><br><span class="line">u03	2017-01	8</span><br><span class="line">u04	2017-01	3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三、 对每个用户的数据进行累加，再次子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    userid,</span><br><span class="line">    mon,</span><br><span class="line">    views,</span><br><span class="line">    (<span class="built_in">sum</span>(views) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> userid <span class="keyword">order</span> <span class="keyword">by</span> mon)) total</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        userid , </span><br><span class="line">        mon , </span><br><span class="line">        <span class="built_in">sum</span>(visitcount) views</span><br><span class="line">    <span class="keyword">FROM</span>(<span class="keyword">SELECT</span> </span><br><span class="line">            userid , </span><br><span class="line">            date_format(REGEXP_REPLACE(visitdate,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>),<span class="string">&#x27;yyyy-MM&#x27;</span>) mon , </span><br><span class="line">            visitcount</span><br><span class="line">        <span class="keyword">FROM</span> </span><br><span class="line">            action) t1</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">            userid ,mon)t2;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userid	mon	views	total</span><br><span class="line">u01	2017-01	11	11</span><br><span class="line">u01	2017-02	12	23</span><br><span class="line">u02	2017-01	12	12</span><br><span class="line">u03	2017-01	8	8</span><br><span class="line">u04	2017-01	3	3</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="（二）统计网店访问量"><a href="#（二）统计网店访问量" class="headerlink" title="（二）统计网店访问量"></a>（二）统计网店访问量</h1><p>有50W个京东店铺，每个顾客访问任何一个店铺的任何一个商品时都会产生一条访问日志，访问日志存储的表名为visit，访客的用户id为user_id，被访问的店铺名称为shop，请统计：<br><a href="./d61c/visit.txt">原始数据</a>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u1	a</span><br><span class="line">u2	b</span><br><span class="line">u1	b</span><br><span class="line">u1	a</span><br><span class="line">u3	c</span><br><span class="line">u4	b</span><br><span class="line">u1	a</span><br><span class="line">u2	c</span><br><span class="line">u5	b</span><br><span class="line">u4	b</span><br><span class="line">u6	c</span><br><span class="line">u2	c</span><br><span class="line">u1	b</span><br><span class="line">u2	a</span><br><span class="line">u2	a</span><br><span class="line">u3	a</span><br><span class="line">u5	a</span><br><span class="line">u5	a</span><br><span class="line">u5	a</span><br></pre></td></tr></table></figure>
<p>建表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> visit(user_id string,shop string) </span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>问：<br>1）每个店铺的UV（访客数）<br>2）每个店铺访问次数top3的访客信息。输出店铺名称、访客id、访问次数</p>
<h2 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h2><h3 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h3><p>一、使用GROUP BY对用户进行去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        visit</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">        shop,</span><br><span class="line">        user_id</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shop	user_id</span><br><span class="line">a	u1</span><br><span class="line">a	u2</span><br><span class="line">a	u3</span><br><span class="line">a	u5</span><br><span class="line">b	u1</span><br><span class="line">b	u2</span><br><span class="line">b	u4</span><br><span class="line">b	u5</span><br><span class="line">c	u2</span><br><span class="line">c	u3</span><br><span class="line">c	u6</span><br></pre></td></tr></table></figure>


<p>二、对去重的结果进行用户数目统计</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    shop,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) uv</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        visit</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">        shop,</span><br><span class="line">        user_id) t1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    shop;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shop	uv</span><br><span class="line">a	4</span><br><span class="line">b	4</span><br><span class="line">c	3</span><br></pre></td></tr></table></figure>



<h3 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h3><p>一、计算每个人访问每个店铺的总次数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    shop,</span><br><span class="line">    user_id,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    visit</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    shop,</span><br><span class="line">    user_id;</span><br></pre></td></tr></table></figure>

<p>二、针对同一店铺，对方问次数进行逆序排序，并计算rank值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    shop,</span><br><span class="line">    user_id,</span><br><span class="line">    ct,</span><br><span class="line">    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> shop <span class="keyword">order</span> <span class="keyword">by</span> ct <span class="keyword">desc</span> ) rk</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        shop,</span><br><span class="line">        user_id,</span><br><span class="line">        <span class="built_in">count</span>(<span class="operator">*</span>) ct</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        visit</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id) t1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>三、去店铺访问前三名的用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    shop,</span><br><span class="line">    user_id,</span><br><span class="line">    ct</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span></span><br><span class="line">        shop,</span><br><span class="line">        user_id,</span><br><span class="line">        ct,</span><br><span class="line">        <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> shop <span class="keyword">order</span> <span class="keyword">by</span> ct <span class="keyword">desc</span> ) rk</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        (<span class="keyword">SELECT</span> </span><br><span class="line">            shop,</span><br><span class="line">            user_id,</span><br><span class="line">            <span class="built_in">count</span>(<span class="operator">*</span>) ct</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            visit</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">            shop,</span><br><span class="line">            user_id) t1)t2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    rk <span class="operator">&lt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Exer4：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_age</span><br><span class="line">(dt STRING, <span class="operator">/</span><span class="operator">/</span>日期</span><br><span class="line">user_id STRING, <span class="operator">/</span><span class="operator">/</span>用户</span><br><span class="line">age <span class="type">INT</span>) <span class="operator">/</span><span class="operator">/</span>年龄</span><br></pre></td></tr></table></figure>
<p>1、所有用户的总数及平均年龄</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    user_id,</span><br><span class="line">    <span class="built_in">AVG</span>(age) age</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    user_age</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    user_id;t1</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="operator">*</span>) count1,</span><br><span class="line">    <span class="built_in">AVG</span>(aage) avg_total_age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">    user_id,</span><br><span class="line">    <span class="built_in">AVG</span>(age) aage</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    user_age</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    user_id)t1;t0</span><br></pre></td></tr></table></figure>

<p>~~~~~~~~~~~结果~~~~~~~~~~~<br>count1  avg_total_age<br>3   27.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2、活跃用户的总数及其平均年龄(2种方法)</span><br><span class="line">① 用lead或者tag,在用Datediff找相邻一天的，然后去重就得出结果，不具备扩展性，实现多天活跃比较复杂。</span><br><span class="line">② 等差数列</span><br><span class="line">2.1 给每个用户的日期,同一天去重rank</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    dt,</span><br><span class="line">    ROW_Number() OVER(PARTITION BY user_id ORDER BY dt) rk</span><br><span class="line">FROM </span><br><span class="line">    user_age</span><br><span class="line">GROUP BY</span><br><span class="line">    user_id,dt;t2</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2 用等差数列</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    DATE_SUB(dt,rk) diff</span><br><span class="line">FROM</span><br><span class="line">    t2;t3</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">2.3 求出差距</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    COUNT(diff) OVER(PARTITION BY user_id,diff) count_diff</span><br><span class="line">FROM</span><br><span class="line">    t3;t4</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">2.4 最大连续天数</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    user_id</span><br><span class="line">FROM</span><br><span class="line">    t4</span><br><span class="line">WHERE</span><br><span class="line">    count_diff &gt;= 2</span><br><span class="line">GROUP BY</span><br><span class="line">    user_id;t5</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">2.5 去重并且得到age</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    user_age.user_id,</span><br><span class="line">    user_age.age</span><br><span class="line">FROM</span><br><span class="line">    user_age,t5</span><br><span class="line">WHERE</span><br><span class="line">    user_age.user_id = t5.user_id;t6</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">    COUNT(*) active_count,</span><br><span class="line">    AVG(age) active_avg_age</span><br><span class="line">FROM</span><br><span class="line">    t6; t7</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">3、合并</span><br><span class="line"></span><br><span class="line">最终SQL：</span><br><span class="line">```sql</span><br><span class="line">SELECT</span><br><span class="line">    count_total,</span><br><span class="line">    avg_total_age,</span><br><span class="line">    active_count,</span><br><span class="line">    active_avg_age</span><br><span class="line">FROM</span><br><span class="line">(SELECT</span><br><span class="line">    COUNT(*) count_total,</span><br><span class="line">    AVG(aage) avg_total_age</span><br><span class="line">FROM</span><br><span class="line">    (SELECT </span><br><span class="line">    user_id,</span><br><span class="line">    AVG(age) aage</span><br><span class="line">FROM </span><br><span class="line">    user_age</span><br><span class="line">GROUP BY </span><br><span class="line">    user_id)t1)t0</span><br><span class="line">,</span><br><span class="line">(SELECT</span><br><span class="line">    COUNT(*) active_count,</span><br><span class="line">    AVG(age) active_avg_age</span><br><span class="line">FROM</span><br><span class="line">(SELECT</span><br><span class="line">    DISTINCT user_age.user_id,</span><br><span class="line">    user_age.age</span><br><span class="line">FROM</span><br><span class="line">    user_age,</span><br><span class="line">    (SELECT</span><br><span class="line">    user_id</span><br><span class="line">FROM</span><br><span class="line">    (SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    COUNT(diff) OVER(PARTITION BY user_id,diff) count_diff</span><br><span class="line">FROM</span><br><span class="line">    (SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    DATE_SUB(dt,rk) diff</span><br><span class="line">FROM</span><br><span class="line">    (SELECT</span><br><span class="line">    user_id,</span><br><span class="line">    dt,</span><br><span class="line">    ROW_Number() OVER(PARTITION BY user_id ORDER BY dt) rk</span><br><span class="line">FROM </span><br><span class="line">    user_age</span><br><span class="line">GROUP BY</span><br><span class="line">    user_id,dt)t2)t3)t4</span><br><span class="line">WHERE</span><br><span class="line">    count_diff &gt;= 2</span><br><span class="line">GROUP BY</span><br><span class="line">    user_id)t5</span><br><span class="line">WHERE</span><br><span class="line">    user_age.user_id = t5.user_id)t6)t7;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~结果~~~~~~~~~~~</span><br><span class="line">count_total avg_total_age   active_count    active_avg_age</span><br><span class="line">3   27.0    1   19.0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>java中[i=i++]问题</title>
    <url>/blog/68f0.html</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">add</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i = i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为10，反编译结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;add.java&quot;</span><br><span class="line">public class tech.mapan.add &#123;</span><br><span class="line">  public tech.mapan.add();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        10</span><br><span class="line">       2: istore_1</span><br><span class="line">       3: iload_1</span><br><span class="line">       4: iinc          1, 1</span><br><span class="line">       7: istore_1</span><br><span class="line">       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      15: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.mapan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">add</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        i = ++i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为11，反编译结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Compiled from &quot;add.java&quot;</span><br><span class="line">public class tech.mapan.add &#123;</span><br><span class="line">  public tech.mapan.add();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        10</span><br><span class="line">       2: istore_1</span><br><span class="line">       3: iinc          1, 1</span><br><span class="line">       6: iload_1</span><br><span class="line">       7: istore_1</span><br><span class="line">       8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      11: iload_1</span><br><span class="line">      12: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">      15: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>maven加速</title>
    <url>/blog/d3cd.html</url>
    <content><![CDATA[<p>maven源在国外由于防火墙原因很慢，使用国内加速源方法：</p>
<img src="/blog/d3cd/1565941484403.png" class="1565941484403">

<p>如上图找到maven的配置文件路径，使用编辑器修改这个<code>setting.xml</code>文件，定位到<code>&lt;mirrors&gt;</code> <code>&lt;/mirrors&gt;</code>这一对标签，在中间添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-osc<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus osc<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.oschina.net/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改好之后如下图</p>
<img src="/blog/d3cd/1565942794080.png" class="1565942794080">

<p>重启IDEA，刷新Maven，导包速度跑满带宽。</p>
<p>Enjoy！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>SQL相关</title>
    <url>/blog/bec5.html</url>
    <content><![CDATA[<h1 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h1><p>SQL, 全称为Structured Query Language（结构化查询语言)。 要讲SQL就绕不开database(数据库), 平时所说的数据库，一般就是指的 Relational database(关系型数据库).</p>
<p>大家知道数据库是用来存储大量数据的一种软件，那么SQL呢是用来操作数据里的数据，具体来说SQL可以做数据查询，数据更新，写入数据等等。</p>
<p>如果把数据库比作盘子，那数据就是盘子里的菜，SQL则是你的筷子。</p>
<img src="/blog/bec5/timg.jpg" class="timg">

<p>因为SQL和数据库是天生的一对，又相对简单，目前世界上大部分网站和APP背后的数据都是建立在SQL数据库基础之上。</p>
<h1 id="关系型数据库（Relational-databases"><a href="#关系型数据库（Relational-databases" class="headerlink" title="关系型数据库（Relational databases)"></a>关系型数据库（Relational databases)</h1><p>在学习SQL语法之前有必要解释一下什么是关系型数据库（Relational databases)？数据库由若干张<code>表</code>(Table)组成，这里说的数据Table很像Excel里的表; 正如Excel里的表格，Table也是由 <code>行(rows)</code>和<code>列(columns)</code>组成</p>
<p>一个Table存储一个类别的数据，每一行是一条数据，每一列是这种数据的一个属性； Table就像一个二维的表格，<code>列(columns)</code>是有限固定的，<code>行(rows)</code>是无限不固定的</p>
<p>举个例子, 比如我们数据库里有一张<code>表(Table)</code>. 是用来存储世界上所有的狗，每一<code>行(rows)</code>是一条狗的信息。那么你会在这个狗Table里存储 哪些狗的属性<code>列(columns)</code>呢？比如 编号，名字，体重，身高，品种，年龄，毛发颜色。</p>
<p>SELECT 语句, 通常又称为 查询 （queries), 正如其名, SELECT 可以用来从数据库中取出数据. 一条 SELECT 语句或者叫一个查询, 可以描述我们要从什么表取数据， 要取哪些数据，在返回之前怎么对结果做一些转化计算等等. 我们接下来会说明 SELECT 的语法，看 SELECT 是怎么来实现上述的取数据任务的。</p>
<p>你可以把一个表(Table)想象成一个类别的事物，比如 狗 (Dogs), 表里的每一行就是 一条狗，每一列代表了狗的一种属性，比如： 颜色，长度等等）</p>
<p>现在有了这么一张表，最常见的一种查询就是取出表中的 一个或某几个属性列（注意：是所有数据的某几个属性列）</p>
<p>Select 查询某些属性列（specific columns）的语法<br>SELECT column（列名）, another_column, …<br>FROM mytable（表名）;<br>查询的结果是一个二维的表格，由行（rows）和列（columns）组成, 看起来像是复制了一遍原有的表（Table）,只不过列是我们选定的，而不是所有的列.</p>
<p>如果我们想取出所有列的数据, 当然可以把所有列名写上，不过更简单的方式用星号 (*) 来代表所有列.如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> 查询所有列</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable（表名）;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table. </span><br></pre></td></tr></table></figure>
<p>这条语句经常用来在不清楚table(表）中有什么数据时，能取出所有的数据瞜一眼。</p>
<p>如果数据表里有100万行数据？真实世界中确实存在，世界上肯定有100万条狗那么多. 如果数据量这么大 之前的SQL语句很可能运行时会崩溃（想象一下你一次性下载1T的电影）</p>
<p>真实情况下，我们很少直接查所有行，即使查询出来也看不完。为了更精确的查询出特定数据，我们需要学习一个新的SQL语法：SELECT查询的 WHERE 子句. 一个查询的 WHERE子句用来描述哪些行应该进入结果，具体就是通过 condition条件 限定这些行的属性满足某些具体条件。比如：WHERE 体重大于 10KG的狗。你可以把 WHERE想象成一个 筛子，每一个特定的筛子都可以筛下某些豆子。</p>
<p>条件查询语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, another_column, …</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> another_condition</span><br><span class="line">    <span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> …;</span><br></pre></td></tr></table></figure>
<p>注：这里的 condition 都是描述属性列的，具体会在下面的表格体现。<br>可以用 AND or OR 这两个关键字来组装多个条件（表示并且，或者） (ie. num_wheels &gt;= 4 AND doors &lt;= 2 这个组合表示 num_wheels属性 大于等于 4 并且 doors 属性小于等于 2). 下面的具体语法规则，可以用来筛选数字属性列（包括 整数，浮点数） :</p>
<table>
<thead>
<tr>
<th>Operator（关键字）</th>
<th>Condition（意思）</th>
<th>SQL Example(例子）</th>
</tr>
</thead>
<tbody><tr>
<td>=, !=, &lt; &lt;=, &gt;, &gt;=</td>
<td>Standard numerical operators 基础的 大于，等于等比较</td>
<td>col_name != 4</td>
</tr>
<tr>
<td>BETWEEN … AND …</td>
<td>Number is within range of two values (inclusive) 在两个数之间</td>
<td>col_name BETWEEN 1.5 AND10.5</td>
</tr>
<tr>
<td>NOT BETWEEN … AND …</td>
<td>Number is not within range of two values (inclusive) 不在两个数之间</td>
<td>col_name NOT BETWEEN 1 AND10</td>
</tr>
<tr>
<td>IN (…)</td>
<td>Number exists in a list 在一个列表</td>
<td>col_name IN (2, 4, 6)</td>
</tr>
<tr>
<td>NOT IN (…)</td>
<td>Number does not exist in a list 不在一个列表</td>
<td>col_name NOT IN (1, 3, 5)</td>
</tr>
</tbody></table>
<p>越是精确的条件筛选，会让结果更容易理解，同时因为条件在返回之前筛掉不必要的结果，SQL的运行速度也会快很多（想象一下你只是想看下最近有哪些大片上映，你没必要下载整个电影看一遍）.</p>
<p>如果属性是字符串, 我们会用到字符串相关的一些操作符号，其中 LIKE（模糊查询） 和 %（通配符） 是新增的两个. 下面这个表格对字符串操作符有详细的描述:</p>
<table>
<thead>
<tr>
<th>Operator（操作符）</th>
<th>Condition（解释）</th>
<th>Example（例子）</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>Case sensitive exact string comparison (<em>notice the single equals</em>)完全等于</td>
<td>col_name = “abc”</td>
</tr>
<tr>
<td>!= or &lt;&gt;</td>
<td>Case sensitive exact string inequality comparison 不等于</td>
<td>col_name != “abcd”</td>
</tr>
<tr>
<td>LIKE</td>
<td>Case insensitive exact string comparison 没有用通配符等价于 =</td>
<td>col_name LIKE “ABC”</td>
</tr>
<tr>
<td>NOT LIKE</td>
<td>Case insensitive exact string inequality comparison 没有用通配符等价于 !=</td>
<td>col_name NOT LIKE”ABCD”</td>
</tr>
<tr>
<td>%</td>
<td>Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符</td>
<td>col_name LIKE “%AT%” (matches “AT”, “ATTIC”, “CAT” or even “BATS”) “%AT%” 代表AT 前后可以有任意字符</td>
</tr>
<tr>
<td>_</td>
<td>Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符</td>
<td>col_name LIKE “AN_” (matches “AND”, but not “AN”)</td>
</tr>
<tr>
<td>IN (…)</td>
<td>String exists in a list 在列表</td>
<td>col_name IN (“A”, “B”, “C”)</td>
</tr>
<tr>
<td>NOT IN (…)</td>
<td>String does not exist in a list 不在列表</td>
<td>col_name NOT IN (“D”, “E”, “F”)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>什么是RDD</title>
    <url>/blog/1bb.html</url>
    <content><![CDATA[<p>RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p>
<h2 id="RDD的属性"><a href="#RDD的属性" class="headerlink" title="RDD的属性"></a>RDD的属性</h2><p>在Spark的RDD的源码中有下面 五句话</p>
<ul>
<li>A list of partitions</li>
<li>A function for computing each split</li>
<li>A list of dependencies on other RDDs</li>
<li>Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)</li>
<li>Optionally, a list of preferred locations to compute each split on (e.g. block locations for an HDFS file)</li>
</ul>
<p>（1）一组分区（Partition），即数据集的基本组成单位；<br>（2）一个计算每个分区的函数；<br>（3）RDD之间的依赖关系；<br>（4）一个Partitioner，即RDD的分片函数；<br>（5）一个列表，存储存取每个Partition的优先位置（preferred location）。</p>
<h2 id="RDD特点"><a href="#RDD特点" class="headerlink" title="RDD特点"></a>RDD特点</h2><p>RDD表示只读的分区的数据集，对RDD进行改动，只能通过RDD的转换操作，由一个RDD得到一个新的RDD，新的RDD包含了从其他RDD衍生所必需的信息。RDDs之间存在依赖，RDD的执行是按照血缘关系延时计算的。如果血缘关系较长，可以通过持久化RDD来切断血缘关系。</p>
<h3 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h3><ul>
<li>存储的弹性：内存与磁盘的自动切换；</li>
<li>容错的弹性：数据丢失可以自动恢复；</li>
<li>计算的弹性：计算出错重试机制；</li>
<li>分片的弹性：可根据需要重新分片。</li>
</ul>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>RDD逻辑上是分区的，每个分区的数据是抽象存在的，计算的时候会通过一个compute函数得到每个分区的数据。如果RDD是通过已有的文件系统构建，则compute函数是读取指定文件系统中的数据，如果RDD是通过其他RDD转换而来，则compute函数是执行转换逻辑将其他RDD的数据进行转换。</p>
<h3 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h3><p>RDD是只读的，要想改变RDD中的数据，只能在现有的RDD基础上创建新的RDD。<br>由一个RDD转换到另一个RDD，可以通过丰富的操作算子实现，不再像MapReduce那样只能写map和reduce了。<br>RDD的操作算子包括两类，一类叫做Transformations（转换算子），它是用来将RDD进行转化，构建RDD的血缘关系；另一类叫做Actions（行动算子），它是用来触发RDD的计算，得到RDD的相关计算结果或者将RDD保存的文件系统中。下图是RDD所支持的操作算子列表。</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>RDDs通过操作算子进行转换，转换得到的新RDD包含了从其他RDDs衍生所必需的信息，RDDs之间维护着这种血缘关系，也称之为依赖。如下图所示，依赖包括两种，一种是窄依赖，RDDs之间分区是一一对应的，另一种是宽依赖（也叫Shuffle依赖），下游RDD的每个分区与上游RDD(也称之为父RDD)的每个分区都有关，是多对多的关系。</p>


<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果在应用程序中多次使用同一个RDD，可以将该RDD缓存起来，该RDD只有在第一次计算的时候会根据血缘关系得到分区的数据，在后续其他地方用到该RDD的时候，会直接从缓存处取而不用再根据血缘关系计算，这样就加速后期的重用。如下图所示，RDD-1经过一系列的转换后得到RDD-n并保存到hdfs，RDD-1在这一过程中会有个中间结果，如果将其缓存到内存，那么在随后的RDD-1转换到RDD-m这一过程中，就不会计算其之前的RDD-0了。</p>


<h3 id="CheckPoint"><a href="#CheckPoint" class="headerlink" title="CheckPoint"></a>CheckPoint</h3><p>虽然RDD的血缘关系天然地可以实现容错，当RDD的某个分区数据失败或丢失，可以通过血缘关系重建。但是对于长时间迭代型应用来说，随着迭代的进行，RDDs之间的血缘关系会越来越长，一旦在后续迭代过程中出错，则需要通过非常长的血缘关系去重建，势必影响性能。为此，RDD支持checkpoint将数据保存到持久化的存储中，这样就可以切断之前的血缘关系，因为checkpoint后的RDD不需要知道它的父RDDs了，它可以从checkpoint处拿到数据。</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>数据库中间件Canal</title>
    <url>/blog/3c75.html</url>
    <content><![CDATA[<h3 id="canal-快速上手"><a href="#canal-快速上手" class="headerlink" title="canal 快速上手"></a>canal 快速上手</h3><h4 id="什么是canal"><a href="#什么是canal" class="headerlink" title="什么是canal"></a>什么是canal</h4><p>阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，从2010年开始，阿里系公司开始逐步的尝试基于数据库的日志解析，获取增量变更进行同步，由此衍生出了增量订阅&amp;消费的业务。</p>
<p>canal是用java开发的基于数据库增量日志解析，提供增量数据订阅&amp;消费的中间件。目前，canal主要支持了MySQL的binlog解析，解析完成后才利用canal client 用来处理获得的相关数据。（数据库同步需要阿里的otter中间件，基于canal）。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1）原始场景： 阿里otter中间件的一部分</p>
<p>otter是阿里用于进行异地数据库之间的同步框架，canal是其中一部分。</p>
<img src="/blog/3c75/clip_image001.png" class="img">

<p>2） 常见场景1：更新缓存</p>
<img src="/blog/3c75/clip_image002.png" class="img">

<p>   3）  场景2：抓取业务数据新增变化表，用于制作拉链表。</p>
<p>   4）  场景3：抓取业务表的新增变化数据，用于制作实时统计。</p>
<h4 id="canal的工作原理"><a href="#canal的工作原理" class="headerlink" title="canal的工作原理"></a>canal的工作原理</h4><img src="/blog/3c75/clip_image003.png" class="img">

<p>复制过程分成三步：</p>
<p>1）Master主库将改变记录写到二进制日志(binary log)中；</p>
<p>2）Slave从库向MySQL Master发送dump协议，将Master主库的binary log events拷贝到它的中继日志(relay log)；</p>
<p>3）Slave从库读取并重做中继日志中的事件，将改变的数据同步到自己的数据库。</p>
<p>canal的工作原理很简单，就是把自己伪装成slave，假装从master复制数据。</p>
<img src="/blog/3c75/clip_image004.png" class="img">

<h3 id="MySQL的binlog"><a href="#MySQL的binlog" class="headerlink" title="MySQL的binlog"></a>MySQL的binlog</h3><h4 id="什么是binlog"><a href="#什么是binlog" class="headerlink" title="什么是binlog"></a>什么是binlog</h4><p>MySQL的二进制日志可以说是MySQL最重要的日志了，它记录了所有的DDL和DML(除了数据查询语句)语句，以事件形式记录，还包含语句所执行的消耗的时间，MySQL的二进制日志是事务安全型的。</p>
<p>一般来说开启二进制日志大概会有1%的性能损耗 。二进制有两个最重要的使用场景: </p>
<p>其一：MySQL Replication在Master端开启binlog，Mster把它的二进制日志传递给slaves来达到master-slave数据一致的目的。 </p>
<p>其二：自然就是数据恢复了，通过使用mysqlbinlog工具来使恢复数据。</p>
<p>二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件。</p>
<h4 id="binlog的开启"><a href="#binlog的开启" class="headerlink" title="binlog的开启"></a>binlog的开启</h4><p>在mysql的配置文件(Linux: /etc/my.cnf ,  Windows: \my.ini)下,修改配置</p>
<p>在[mysqld] 区块</p>
<p>设置/添加 </p>
<p>这个表示binlog日志的前缀是mysql-bin，以后生成的日志文件就是 mysql-bin.123456 的文件后面的数字按顺序生成。每次mysql重启或者到达单个文件大小的阈值时，新生一个文件，按顺序编号。</p>
<h4 id="binlog的分类设置"><a href="#binlog的分类设置" class="headerlink" title="binlog的分类设置"></a>binlog的分类设置</h4><p>mysql binlog的格式，那就是有三种，分别是STATEMENT,MIXED,ROW。</p>
<p>在配置文件中可以选择配置</p>
<p>区别：</p>
<p>1）statement</p>
<ul>
<li>语句级，binlog会记录每次一执行写操作的语句。</li>
<li>相对row模式节省空间，但是可能产生不一致性，比如update  tt set create_date=now()</li>
<li>如果用binlog日志进行恢复，由于执行时间不同可能产生的数据就不同。</li>
<li>优点：节省空间</li>
<li>缺点：有可能造成数据不一致。</li>
</ul>
<p>2）row</p>
<ul>
<li>行级，binlog会记录每次操作后每行记录的变化。</li>
<li>优点：保持数据的绝对一致性。因为不管sql是什么，引用了什么函数，他只记录执行后的效果。</li>
<li>缺点：占用较大空间。</li>
</ul>
<p>3）mixed</p>
<ul>
<li>statement的升级版，一定程度上解决了，因为一些情况而造成的statement模式不一致问题</li>
<li>在某些情况下譬如：</li>
<li>当函数中包含 UUID() 时；</li>
<li>包含 AUTO_INCREMENT 字段的表被更新时；</li>
<li>执行 INSERT DELAYED 语句时；</li>
<li>用 UDF 时；</li>
<li>会按照 ROW的方式进行处理</li>
<li>优点：节省空间，同时兼顾了一定的一致性。</li>
<li>缺点：还有些极个别情况依旧会造成不一致，另外statement和mixed对于需要对binlog的监控的情况都不方便。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
  </entry>
  <entry>
    <title>零基础免费搭建个人博客网站</title>
    <url>/blog/e10b.html</url>
    <content><![CDATA[<p>Coding被腾讯收购后改名为腾讯开发者平台，在2020年1月又再次改名为新Coding，网站页面换了又换改了又改，而新浪图床也已经失效，图片全部挂掉。时过境迁，三年前的教程放到现在已经不适用，但是原理和思想都是一样的。有空我会更新下教程，把丢失的图片补充成最新的。</p>
<p>在大学时候自学过一丁点HTML的基础皮毛，对建站有那么一丁点的认识。作为自己业余爱好建立了本博客，简单的写下来搭建方法给搞技术的朋友们。</p>
<h3 id="一、网站概念"><a href="#一、网站概念" class="headerlink" title="一、网站概念"></a>一、网站概念</h3><p>首先来科普下网站的概念:<br>笼统的讲，网站有两类：<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99/2776858?fr=aladdin">动态网站</a>和<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/2776875?fr=aladdin">静态网站</a>。并不是动态网站会动，静态网站不会动，千万不要这样理解，是会被笑话的。<br>简单地说，程序是否在服务器端运行，是<strong>重要标志</strong>。<br>在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如ASP、PHP、JSP、 CGI等。</p>
<p>而静态网站只有固定的文件，是单向的，类似你用文件管理器浏览你硬盘里面的资料，这些资料并不会由于不同用户，不同时间浏览而对你显示不同的效果，无论你在何地、何时打开播放<code>1.MP3</code>，他就只会播放<code>1.MP3</code>。详细的解释可以点前面超链接了解区别。</p>
<h3 id="二、最终选择"><a href="#二、最终选择" class="headerlink" title="二、最终选择"></a>二、最终选择</h3><p>既然标题说了是0元建站，那就该省的都省了(省了服务器费用，域名费用)，为了保证良好的访问速度和体验，我们选择静态网站。</p>
<p>静态网站是需要有本地的网站渲染程序进行渲染我们的网站文件，不然纯手敲HTML+CSS+JS，那更新一篇文章可敲到何年何月了。<br>简单的说，我们搭建好环境后，我们只负责写文章内容，其他网页代码交给程序渲染生成。然后把这套网站代码上传服务器即可。<br>同类的静态博客程序有很多，前3名依次是Jekyll 、 Hexo 、 Hugo。三个我都有尝试过，最后选择了用户量第二的Hexo，个人感觉是三者中最简单快捷的。</p>
<img src="/blog/e10b/timg.jpg" class="timg">
<p>据说Hexo是一个台湾学生的毕业设计，所以比较符合国人的使用习惯，支持国产。原理：<code>hexo</code>渲染出网站文件，使用<code>git</code>工具上传到<code>Coding</code>服务器。</p>
<h3 id="三、准备工作"><a href="#三、准备工作" class="headerlink" title="三、准备工作"></a>三、准备工作</h3><p>Windows 7 &amp;&amp; 10 环境下 需要安装：</p>
<blockquote>
<ul>
<li>Node.js</li>
<li>Git</li>
<li>文本编辑器(推荐Sublime)</li>
</ul>
</blockquote>
<p>需要注册的网站：Coding</p>
<h4 id="3-1-安装node-js-必须"><a href="#3-1-安装node-js-必须" class="headerlink" title="3.1 安装node.js(必须)"></a>3.1 安装node.js(必须)</h4><p>下载: <a href="https://nodejs.org/en/">官网下载</a> </p>
<img src="/blog/e10b/image-20200324205036111.png" class="image-20200324205036111">
<p>推荐安装LTS版本，下载安装，一路Next即可<br>最后点Finsh，安装完毕。<br>（PS: 如果安装失败，提示ERROR code：XXXX 巴拉巴拉等字样，请尝试用管理员权限安装。）</p>
<h4 id="3-2-安装Git-必须"><a href="#3-2-安装Git-必须" class="headerlink" title="3.2 安装Git(必须)"></a>3.2 安装Git(必须)</h4><p>下载: <a href="https://git-scm.com/download/win">官网下载</a> <a href="https://pan.baidu.com/s/1bZI2Zk">百度云</a> 密码:2d4b</p>
<img src="/blog/e10b/image-20200324205237305.png" class="image-20200324205237305">

<img src="/blog/e10b/image-20200324205340862.png" class="image-20200324205340862">
<p>同样一路Next</p>
<img src="/blog/e10b/image-20200324205417021.png" class="image-20200324205417021">

<img src="/blog/e10b/image-20200324205429102.png" class="image-20200324205429102">



<p>最后点Finsh，安装完毕。</p>
<h4 id="3-3-安装编辑器"><a href="#3-3-安装编辑器" class="headerlink" title="3.3 安装编辑器"></a>3.3 安装编辑器</h4><p>可以选择 Sublime Text3或者VScode或者Notepad++，推荐VScode</p>
<p>SublimeText3下载: <a href="https://www.sublimetext.com/">官网下载</a> <a href="https://pan.baidu.com/s/1nuXulwl">百度云</a> 密码:uhzl<br>VScode下载: <a href="https://code.visualstudio.com/">官网下载</a></p>
<img src="/blog/e10b/image-20200324205835673.png" class="image-20200324205835673">

<p>安装一路Next ，最后Finsh即可。</p>
<h4 id="3-4-注册Coding-必须"><a href="#3-4-注册Coding-必须" class="headerlink" title="3.4 注册Coding(必须)"></a>3.4 注册Coding(必须)</h4><p>(PS：Coding已经被腾讯收购，变成了腾讯开发者平台，2020年1月改名为新Coding，真的命途多舛。其他托管服务商同样可以用，本文以Coding举例)</p>
<p><a href="https://coding.net/r/LTANRJ">Coding</a>提供了page服务，是我们用来放网站文件的免费**’服务器’**</p>
<img src="/blog/e10b/image-20200324210127710.png" class="image-20200324210127710">

<img src="/blog/e10b/image-20200324210439178.png" class="image-20200324210439178">

<img src="/blog/e10b/image-20200324210612194.png" class="image-20200324210612194">

<p>注册好之后，创建项目</p>
<img src="/blog/e10b/image-20200324210712769.png" class="image-20200324210712769">

<img src="/blog/e10b/image-20200324210827937.png" class="image-20200324210827937">

<img src="/blog/e10b/image-20200324210920019.png" class="image-20200324210920019">

<p>Ps: 同类的代码托管网站有Gitee、Github等。本文选择国内速度比较块快，功能完善的Coding。<br>其他托管网站也可使用，与Coding大同小异，这里不再赘述。</p>
<h3 id="四、安装Hexo"><a href="#四、安装Hexo" class="headerlink" title="四、安装Hexo"></a>四、安装Hexo</h3><h4 id="4-1-创建网站本地目录"><a href="#4-1-创建网站本地目录" class="headerlink" title="4.1 创建网站本地目录"></a>4.1 创建网站本地目录</h4><p>在电脑上新建一个<code>Blog</code>文件夹，建议D盘根目录如 <code>D:/Blog</code>，这个文件夹是我们本地网站的目录。由于我在虚拟机下，只有C盘，所以我建在桌面。</p>
<img src="/blog/e10b/image-20200406203718826.png" class="image-20200406203718826">

<h4 id="4-2-切换NPM源"><a href="#4-2-切换NPM源" class="headerlink" title="4.2 切换NPM源"></a>4.2 切换NPM源</h4><p>NPM源由于服务器在国外，速度比较慢。为了避免安装中断，我们使用<a href="http://npm.taobao.org/">淘宝NPM镜像</a>，输入以下命令安装cnpm，等待几分钟完成(我这里用了131s)。(仅需一次)<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<img src="/blog/e10b/image-20200406203629220.png" class="image-20200406203629220">
<p>(如果此步骤提示找不到npm指令，请检查node.js是否安装成功,另外检查指令是npm！是npm！是npm！，不要输错了)</p>
<h4 id="4-3-安装Hexo"><a href="#4-3-安装Hexo" class="headerlink" title="4.3 安装Hexo"></a>4.3 安装Hexo</h4><p>使用以下命令安装Hexo(仅需一次)<br><code>cnpm install -g hexo-cli</code></p>
<img src="/blog/e10b/image-20200406204035609.png" class="image-20200406204035609">


<p>使用<code>hexo -v</code>指令查看hexo的版本，如下图可以看出</p>
<img src="/blog/e10b/image-20200406204109848.png" class="image-20200406204109848">

<p>使用<code>hexo init</code>指令初始化hexo(仅需一次)</p>
<img src="/blog/e10b/image-20200406204815728.png" class="image-20200406204815728">

<h4 id="4-4-本地预览网站"><a href="#4-4-本地预览网站" class="headerlink" title="4.4 本地预览网站"></a>4.4 本地预览网站</h4><p>使用<code>hexo s</code>指令预览网站，可能Windows防火墙会弹出提示，这时候我们选择允许访问</p>
<img src="/blog/e10b/image-20200406204839024.png" class="image-20200406204839024">

<p>上图提示信息意思为hexo已经运行在<code>http://localhost:4000/</code>,你可使用<code>Ctrl + C</code>组合键来停止预览。现在不要动这个窗口(不要按CTRL+C，否则就退出了)，我们打开浏览器访问<code>http://localhost:4000/</code></p>
<img src="/blog/e10b/image-20200406204926522.png" class="image-20200406204926522">
<p>如上图，你现在已经成功一大半了。现在网站已经可以运行在我们电脑本地了，但是别人还不能访问，因为网站文件仅仅在我们自己电脑上。需要传到Coding上之后，别人才可以访问你的网站。</p>
<h4 id="4-5-Blog文件夹的目录结构-了解"><a href="#4-5-Blog文件夹的目录结构-了解" class="headerlink" title="4.5 Blog文件夹的目录结构(了解)"></a>4.5 Blog文件夹的目录结构(了解)</h4><p>我们可以了解下Blog目录下的每个文件夹及文件的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy       #需要部署的文件</span><br><span class="line">├── node_modules  #Hexo插件</span><br><span class="line">├── public        #生成的静态网页文件</span><br><span class="line">├── scaffolds     #模板</span><br><span class="line">├── source        #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</span><br><span class="line">|   ├── _drafts   #草稿</span><br><span class="line">|   └── _posts    #文章</span><br><span class="line">├── themes        #主题</span><br><span class="line">├── _config.yml   #全局配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>


<h3 id="五、配置SSH部署公钥-仅需一次"><a href="#五、配置SSH部署公钥-仅需一次" class="headerlink" title="五、配置SSH部署公钥(仅需一次)"></a>五、配置SSH部署公钥(仅需一次)</h3><p>本步骤的目的是<strong>确保只有你本人才能改动和编辑网站内容</strong>。<br>回到bash黑窗口，输入指令<code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code>(你的邮箱)，连续点击 Enter 键即可。(** 指令中的字母 C要大写、C要大写、C要大写 ，注意空格、注意空格、注意空格，重要的事情说三遍！**)<br>如下图</p>
<img src="/blog/e10b/image-20200406205159688.png" class="image-20200406205159688">
<p><a href="https://coding.net/help/doc/account/ssh-key.html">官方参考</a></p>
<p>配置的目的是为了保证只有自己可以改动和上传到仓库，防止别人更改你网站的内容。<br>找到我们刚刚生成的公钥<code>id_rsa.pub</code>,查看，并复制里面的内容</p>
<p>输入<code>cat ~/.ssh/id_rsa.pub</code>回车</p>
<img src="/blog/e10b/image-20200406205401320.png" class="image-20200406205401320">

<p>回到Coding网站，把粘贴板上的内容粘贴到里面，如下图。</p>
<img src="/blog/e10b/image-20200406205742403.png" class="image-20200406205742403">
<p>点击添加，会验证Coding的密码，输入Coding的密码即可。</p>
<img src="/blog/e10b/image-20200406205849977.png" class="image-20200406205849977">

<p>这样就完成了公钥的配置。</p>
<h3 id="六、配置博客网站"><a href="#六、配置博客网站" class="headerlink" title="六、配置博客网站"></a>六、配置博客网站</h3><p>打开Blog文件夹，如下图我们使用Sublime或者VScode 打开<code>_config.yml</code>文件，对博客进行配置。</p>


<p>配置文件使用的语法<strong>大小写敏感</strong>，<strong>空格敏感</strong>。<strong>英文冒号后必须有空一个空格</strong> 使用<code>#</code>号注释<br>我们可以随意更改的有<code>tittle</code>网站标题，<code>subtitle</code>小标题， <code>description</code>网站描述。</p>

<p>第10和11行<code>语言</code>和<code>时区</code>可以默认空着。如需填写可复制如下配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>第15行<code>url:</code>这里填写我们第三步中提示的URL，即我们以后将使用的域名(域名就是网址)。</p>

<p>其他项如不清楚含义或者格式，强烈建议不要修改。</p>
<p>配置文件拉到最下面 (<strong>重要</strong>)，本部分修改的是上传的地址，是网站是否能成功上传到服务器的关键</p>

<p>配置原文如下，coding部分替换成你自己的Coding地址。<br>当然也可以配置多个远程地址，自定义添加即可。如下图，记得替换仓库地址。不要忘记添加相应的SSH密钥到对应的平台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo:</span><br><span class="line">      coding: git@git.dev.tencent.com:mapan/posts.git</span><br><span class="line">      #github: git@github.com:username/xxx.git</span><br><span class="line">      #gitee: git@gitee.com:username/posts.git </span><br><span class="line">    branch: master</span><br><span class="line">    message: xx更新了博客更新了博客 # 这里可以随便写，每次更新博客提交的显示的信息。</span><br></pre></td></tr></table></figure>
<p>Coding地址从Coding网站的这里找到:</p>


<h3 id="七、配置Git和Git部署插件"><a href="#七、配置Git和Git部署插件" class="headerlink" title="七、配置Git和Git部署插件"></a>七、配置Git和Git部署插件</h3><h4 id="7-1-配置git昵称和邮箱-仅需一次"><a href="#7-1-配置git昵称和邮箱-仅需一次" class="headerlink" title="7.1 配置git昵称和邮箱(仅需一次)"></a>7.1 配置git昵称和邮箱(仅需一次)</h4><p>继续回到bash黑色框框<br>使用命令<code>git config --global user.email &quot;you@email.com&quot;</code>配置Git邮箱，记得把邮箱替换成自己的<br>使用命令<code>git config --global user.name &quot;Kevin&quot;</code>配置Git用户名，记得把昵称替换成自己的</p>
<img src="/blog/e10b/image-20200406211848046.png" class="image-20200406211848046">

<h4 id="7-2-安装git上传插件-只需一次"><a href="#7-2-安装git上传插件-只需一次" class="headerlink" title="7.2 安装git上传插件(只需一次)"></a>7.2 安装git上传插件(只需一次)</h4><p>使用以下命令安装hexo-deployer-git工具<br><code>cnpm install hexo-deployer-git --save</code></p>
<h3 id="八、网站PUSH到Coding"><a href="#八、网站PUSH到Coding" class="headerlink" title="八、网站PUSH到Coding"></a>八、网站PUSH到Coding</h3><p><code>hexo g</code>代表渲染网站文件，<code>hexo d</code>代表push网站文件到云端仓库，这两条指令可以单独依次执行。<br>（<code>hexo g &amp;&amp; hexo d</code>或者<code>hexo d -g</code>这两个是组合命令，作用相同，以后熟练可以使用。）</p>


<p>然后会弹出一个让你确认的窗口，你输入<code>yes</code>后确定即可。</p>


<h3 id="九、访问网站"><a href="#九、访问网站" class="headerlink" title="九、访问网站"></a>九、访问网站</h3><p>现在我们访问自己的域名 <a href="https://mapann.coding.me/">https://mapann.coding.me</a>即可访问我们自己搭建的网站了。如果看到已经可以访问，那么恭喜！大功告成！</p>
<hr>
<h3 id="如何写文章？"><a href="#如何写文章？" class="headerlink" title="如何写文章？"></a>如何写文章？</h3><p>可以看我这篇文章 <a href="/cn/2b94.html" target="_blank">使用Hexo写文章</a></p>
<h3 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h3><h4 id="如何更改主题？"><a href="#如何更改主题？" class="headerlink" title="如何更改主题？"></a>如何更改主题？</h4><p>(挖坑待填)<br>可以自定义和优化的有很多，比如不喜欢默认的主题，我们可以去<a href="https://hexo.io/themes/">hexo官网</a><br>下载更漂亮的主题，如比较火的<a href="http://theme-next.iissnan.com/">NexT主题</a>。</p>
<h4 id="如何绑定自定义域名？"><a href="#如何绑定自定义域名？" class="headerlink" title="如何绑定自定义域名？"></a>如何绑定自定义域名？</h4><p>(挖坑待填)<br>可以绑定自己的域名。(域名就收费了，不在本文探讨范围内)</p>
<h4 id="如何压缩网站文件，加快访问速度？"><a href="#如何压缩网站文件，加快访问速度？" class="headerlink" title="如何压缩网站文件，加快访问速度？"></a>如何压缩网站文件，加快访问速度？</h4><p>可以看我这篇文章 <a href="/cn/8f24.html" target="_blank">HEXO优化之GULP</a></p>
<h4 id="如何使用图床？如何在文章插入图片？"><a href="#如何使用图床？如何在文章插入图片？" class="headerlink" title="如何使用图床？如何在文章插入图片？"></a>如何使用图床？如何在文章插入图片？</h4><p>可以看我这篇文章 <a href="/cn/c9c3.html" target="_blank">使Hexo文章图文并茂</a></p>
<h4 id="如何升级为HTTPS访问？"><a href="#如何升级为HTTPS访问？" class="headerlink" title="如何升级为HTTPS访问？"></a>如何升级为HTTPS访问？</h4><p>现在Coding默认支持https，在Coding端打开即可，其他部署平台类似。</p>
<p>快去写文章吧，网站只是载体和工具，内容才是主要的。等待你的友链！<br>如果你在按照教程走出现了问题，可以在下方评论区留言，或者进Q群讨论 613284009</p>


<p><a href="http://blog.csdn.net/jzooo/article/details/46781805">本文参考</a></p>
<hr>
<p>2017-12更新</p>
<p>如果觉得有难度不容易上手，那么还可以有以下几个选择：<br><a href="http://blog.csdn.net/">CSDN博客</a>: 集成好的功能，只需要注册即可使用，但并不是独立博客。<br><a href="https://www.jianshu.com/">简书</a>:  一个比较文艺的地方，你同样可以用来写技术文章，同样注册即可使用，不是独立博客。<br><a href="https://www.cnblogs.com/">博客园</a>: 可定制化比较强，听名字就知道是做什么了。<br><a href="https://cn.wordpress.org/">wordpress</a>、<a href="http://typecho.org/">typecho</a>等其他动态博客程序 ：部署简单、需要购买虚拟主机或者VPS服务器。</p>
<p>···</p>
<p>其实说到底博客只是一个用来展示自己的地方，重要的还是自己有所学习，一个博客的内容才是最重要的。写本文的目的仅仅是为了帮助一些做技术但对网站前端不太懂，而且想少花钱搭建独博客的人。<br>做技术本身就要一股钻劲儿，要知道专业领域比搭网站复杂的多。</p>
<hr>
<p>2019-02更新<br>如今Coding已经被腾讯收购，变身为<a href="https://dev.tencent.com/">腾讯开发者平台</a>,但是换汤不换药，仍然提供pages服务，而且不需要再页面底部添加<code>hosted by</code>的广告，据说还是Coding的原班人马在运营维护。另外Hexo的同类产品<a href="https://gohugo.io/">Hugo</a>发展迅猛，官方宣传现在主题数目已经超过Hexo。我试用了Hugo，安装十分方便，渲染速度快，当然也有缺点，现阶段Hugo在国内使用的人还是相对较少，所以中文文档和资料少，遇到问题一般要去搜索英文论坛之类。国外火爆的另一个缺点是网站默认引用许多国外的CDN资源，众所周知的大陆网络的情况，国外的CDN资源加载速度比较慢甚至不能访问，需要自己去优化，把国外资源本地化或者换成国内的CDN。</p>
<hr>
<blockquote>
<h3 id="FAQ-常见问题"><a href="#FAQ-常见问题" class="headerlink" title="FAQ (常见问题)"></a><em>FAQ</em> (常见问题)</h3></blockquote>
<h4 id="1-执行hexo-d报错"><a href="#1-执行hexo-d报错" class="headerlink" title="1.执行hexo d报错"></a>1.执行<code>hexo d</code>报错</h4>
<p>原因: <code>_config.yml</code> 文件内容格式错误，其实上图已经提示的非常清楚了。其中错误是在第9行，第9个字符<code>keywords:</code>附近出现，而且非常贴心的使用箭头指出了位置。<br>我们看一下出错原因，看下图。</p>

<p>英文冒号之后，是需要加一个空格的。为什么推荐使用sublime这个编辑器呢？原因就在这里，这个默认的语法高亮很贴心，当你语法出错的时候，颜色就不变的不同。<br>解决方法：<strong>英文冒号</strong> 后添加一个空格。</p>
<h4 id="2-npm-commnd-not-found"><a href="#2-npm-commnd-not-found" class="headerlink" title="2.npm commnd not found"></a>2.npm commnd not found</h4><p>首先排查npm是否安装成功，在git bash里分别输入<code>npm -v</code> 和<code>node -v</code></p>

<p>如果出现<code>bash: node: command not found </code>说明node安装失败，请尝试使用管理员权限重新安装。</p>
<p>如果出现正确的版本号，说明npm和node安装成功了。请继续往下看</p>

<p>原因：仔细看下，是npm！不是nmp！复制粘贴不比手敲要快准确率要高啊？<br>建议直接鼠标复制，粘贴操作，减少错误概率。<br>解决方法： nmp更正为npm<br>类似的 <strong>少个空格</strong>，<strong>大小写错</strong>，<strong>多个空格</strong>之类的低级错误，请先与示例图片对比检查。</p>
<h4 id="3-除了Coding，有别的托管服务商吗？"><a href="#3-除了Coding，有别的托管服务商吗？" class="headerlink" title="3.除了Coding，有别的托管服务商吗？"></a>3.除了Coding，有别的托管服务商吗？</h4><p>有，除了Coding（腾讯开发者平台），还有<a href="https://gitee.com/">Gitee</a>，<a href="https://github.com/">Github</a>，<a href="https://about.gitlab.com/">Gitlab</a>，<a href="https://bitbucket.org/">Bitbucket</a>等等。</p>
<h4 id="4-有没有免费的顶级域名？"><a href="#4-有没有免费的顶级域名？" class="headerlink" title="4.有没有免费的顶级域名？"></a>4.有没有免费的顶级域名？</h4><p>有，<a href="http://www.freenom.com/en/index.html">freenom</a>这个网站提供最长一年的顶级域名注册,一年到期还可以手动续。</p>
]]></content>
  </entry>
  <entry>
    <title>HEXO优化之GULP</title>
    <url>/blog/8f24.html</url>
    <content><![CDATA[<p>现在你可以鼠标右键单击空白处，选择查看源代码。</p>

<p>你会发现本页面只有一行代码。把网页文件中的空格换行和注释等删除，可以在一定程度上减小网页的文件大小，进而加快访问速度，这就是网页压缩。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="什么是Gulp"><a href="#什么是Gulp" class="headerlink" title="什么是Gulp"></a>什么是Gulp</h4><p>gulp.js是一种基于流的，代码优于配置的新一代构建工具.</p>
<p>Gulp和Grunt类似。但相比于 Grunt 的频繁的 I/O 操作，Gulp 的流操作，能更快地完成构建</p>
<h3 id="Gulp特性"><a href="#Gulp特性" class="headerlink" title="Gulp特性"></a>Gulp特性</h3><h4 id="使用方便"><a href="#使用方便" class="headerlink" title="使用方便"></a>使用方便</h4><p>通过代码优于配置的策略，Gulp可以让简单的任务简单，复杂的任务更可管理。</p>
<h4 id="构建快速"><a href="#构建快速" class="headerlink" title="构建快速"></a>构建快速</h4><p>通过流式操作，减少频繁的 IO 操作，更快地构建项目。</p>
<h4 id="插件高质"><a href="#插件高质" class="headerlink" title="插件高质"></a>插件高质</h4><p>Gulp 有严格的插件指导策略，确保插件能简单高质的工作。</p>
<h4 id="易于学习"><a href="#易于学习" class="headerlink" title="易于学习"></a>易于学习</h4><p>少量的API，掌握Gulp可以毫不费力。构建就像流管道一样，轻松加愉快。</p>
<h3 id="Gulp安装"><a href="#Gulp安装" class="headerlink" title="Gulp安装"></a>Gulp安装</h3><p>Gulp是基于Node.js的，故要首先安装 Node.js。</p>
<p><code>npm install -g gulp</code></p>
<p>然后按以下清单文件安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gulp</span><br><span class="line">gulp-htmlclean</span><br><span class="line">gulp-htmlmin</span><br><span class="line">gulp-minify-css</span><br><span class="line">gulp-clean-css</span><br><span class="line">gulp-uglify</span><br></pre></td></tr></table></figure>
<p>方法是同样的,<code>npm install xxx --save</code>，xxx即为清单列表文件名</p>
<p>其中gulp是工程的核心程序，Gulp采用插件方式进行工作，下面的5个文件就是基于Gulp的插件.Gulp插件列表</p>
<h3 id="使用Gulp优化Hexo"><a href="#使用Gulp优化Hexo" class="headerlink" title="使用Gulp优化Hexo"></a>使用Gulp优化Hexo</h3><p>建立gulpfile.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var cleancss = require(&#x27;gulp-clean-css&#x27;);</span><br><span class="line">var uglify = require(&#x27;gulp-uglify&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">//  css</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, () =&gt; &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/*.css&#x27;,&#x27;!./public/**/*.min.css&#x27;])</span><br><span class="line">        .pipe(cleancss())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//  html</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: true,</span><br><span class="line">         minifyJS: true,</span><br><span class="line">         minifyCSS: true,</span><br><span class="line">         minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">// js</span><br><span class="line">gulp.task(&#x27;minify-js&#x27;, function() &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/*.js&#x27;,&#x27;!./public/assets/js/*.js&#x27;])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// </span><br><span class="line">gulp.task(&#x27;default&#x27;, [</span><br><span class="line">    &#x27;minify-html&#x27;,&#x27;minify-css&#x27;,&#x27;minify-js&#x27;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>要运行gulp任务，只需切换到存放gulpfile.js文件的目录，然后在终端中执行gulp命令就行了，gulp后面可以加上要执行的任务名，例如gulp task1，如果没有指定任务名，则会执行任务名为default的默认任务。</p>
]]></content>
  </entry>
  <entry>
    <title>戴明环在自我管理中的应用</title>
    <url>/blog/a2ab.html</url>
    <content><![CDATA[<p>PDCA是英语单词Plan(计划)、Do(执行)、Check(检查)和Action(调整)的第一个字母，PDCA循环就是按照这样的顺序进行质量管理，并且循环不止地进行下去的科学程序。PDCA循环是美国质量管理专家休哈特博士首先提出的，由戴明采纳、宣传，获得普及，所以又称戴明环。</p>
<blockquote>
<p>1、P (plan) 计划</p>
</blockquote>
<p>包括方针和目标的确定，以及活动规划的制定。</p>
<blockquote>
<p>2、D (Do) 执行</p>
</blockquote>
<p>根据已知的信息，设计具体的方法、方案和计划布局；再根据设计和布局，进行具体运作，实现计划中的内容。</p>
<blockquote>
<p>3、C (check) 检查</p>
</blockquote>
<p>总结执行计划的结果，分清哪些对了，哪些错了，明确效果，找出问题。</p>
<blockquote>
<p>4、A (Adjust)调整</p>
</blockquote>
<p>对总结检查的结果进行处理，对成功的经验加以肯定，并予以标准化；对于失败的教训也要总结，引起重视。对于没有解决的问题，应提交给下一个PDCA循环中去解决</p>


<hr>
<p>上面是<a href="https://baike.baidu.com/item/PDCA%E5%BE%AA%E7%8E%AF">百度百科</a>给出的定义与解释，有按照自己理解轻微改动。戴明环是一种企业管理方法，现在我觉得<br>**应用在个人的自我管理当中也是非常好的一种方法 **<br>近期我在制定自己的学习规划和时间规划，就是按照这样的方法一直循环下去。觉得完全可以作为个人管理的一种高效方法。通过几轮循环，自己的计划越来越适合自己，越来越接近完美。</p>
<h4 id="制定计划-–-gt-执行-–-gt-检查-–-gt-调整-···"><a href="#制定计划-–-gt-执行-–-gt-检查-–-gt-调整-···" class="headerlink" title="制定计划 –&gt; 执行 –&gt; 检查 –&gt; 调整 ···"></a>制定计划 –&gt; 执行 –&gt; 检查 –&gt; 调整 ···</h4><p>举个例子，要考研的小明同学想制定时间规划，计划每天学习12h，他制定了下面的时间表。这就是<strong>Plan阶段</strong>。</p>
<blockquote>
<p>06:30 - 07:00 起床&amp;&amp;洗漱<br>08:00 - 13:00 数学<br>14:30 - 19:00 数据结构<br>20:00 - 21:00 数学<br>22:00 - 23:30 英语<br>00:00 - 06:30 睡觉</p>
</blockquote>
<p>小明最初的计划是这样的，很认真的执行了半个月，现在是属于<strong>Do阶段</strong>。<br>慢慢的小明发现，在下午的14:30 - 15:30 学习效率极低，而在晚上23:30达到一天中最高的学习效率。<br>小明分析效率低是由于中午吃过午饭，身体血液涌向消化系统，大脑血液含量下降，脑子转的速度变慢，效率变低。而晚上睡前，一天的学习虽然疲倦但是夜幕降临，丰富的夜生活开始，大脑变得兴奋，效率也急剧提高。那么现在是属于<strong>Check阶段</strong>。 </p>
<p>小明决定调整复习计划，把效率最低的时间段去安排到别的事情上，把效率最高的时间段做延长调整，这个阶段成为<strong>Adjust阶段</strong>。</p>
<p>小明重新制定计划：</p>
<blockquote>
<p>07:00 - 07:30 起床&amp;&amp;洗漱<br>08:00 - 13:00 数学<br>14:30 - 15:30 散步&amp;&amp;单词记忆<br>15:30 - 19:00 数据结构<br>20:00 - 21:00 数学<br>22:00 - 23:30 英语<br>23:30 - 00:30 数据结构<br>00:30 - 07:00 睡觉</p>
</blockquote>
<p>那么现在属于第二轮的PDCA循环的<strong>P阶段</strong>，依此类推，一个一个循环下去，这个计划会越来越适合小明。</p>
<hr>
<p>每个戴明环的阶段，也可以有小戴明环，形成了大环套小环的状态，如下图。<br>举个例子，还是上文的小明，小明在Do阶段，即按照计划学习阶段，制定了英语学习计划，作文，阅读理解，翻译等等怎么怎么学习，这是可执行的一个小戴明环。在作文学习中，分为画图说话，书信，引言等几类作文，每一类作文的格式是什么，计划怎么学习，这又可以细化为小的戴明环。</p>


<p>如果用在一个更大更长远的目标上呢？如下图，把大目标分解为阶段目标，阶段目标细化落实为行动，这样一个大的目标就会越来越清晰，能感受到距离目标越来越近。当a、b、c、d达到时，你就完成了1，当1、2、3、4完成时，你就实现了目标A。</p>


<p>这是一个神奇的管理方法，不仅在质量管理上用处颇大，在个人的自我管理上也是非常好的方法。</p>
<p>如果真正的做到了，那么这种可以**<a href="#jump1">控制自我</a>**的快感和愉悦是难以用语言来分享的。</p>
<hr>
<p><span id = "jump1">控制自我</span> : 这里的控制自我指的是<strong>在大的时间跨度上，能够通过自我规划和管理实现自身意愿</strong>。而不是抬抬左手，左手就能抬起来的这种控制。</p>
]]></content>
  </entry>
  <entry>
    <title>使用Hexo写文章</title>
    <url>/blog/2b94.html</url>
    <content><![CDATA[<p>为了帮助广大电子爱好者建立自己的独立博客，形成记录思考的习惯。上个月写了一篇<a href="https://mapan.tech/posts/e10b.html" target="_blank">怎样创建个人独立博客网站的文章</a>。没想到会有这么多的反响，有很多朋友就细节问题来咨询。<br>今天有时间整理一下网站搭建好以后，如何更新文章。</p>
<h3 id="1-本地写文章"><a href="#1-本地写文章" class="headerlink" title="1.本地写文章"></a>1.本地写文章</h3><p>选中你的Blog文件夹(我这里选择的是我自己重命名过的),鼠标右键单击，选择<code>Git Bash Here</code> </p>
<img src="/blog/2b94/005vwoCyly1fn7sob24o7j30b00ajt9k.jpg" class="">

<h5 id="1-1-新建文章"><a href="#1-1-新建文章" class="headerlink" title="1.1 新建文章"></a>1.1 新建文章</h5><p>输入指令<code>hexo new XXX</code> 如下图xxx为文章标题，根据自己情况写。</p>

<p>完成后会提示 在<code>.../Blog/source/_post/</code>目录下创建了xxx.md</p>
<h5 id="1-2-写文章"><a href="#1-2-写文章" class="headerlink" title="1.2 写文章"></a>1.2 写文章</h5><p>我们根据提示的目录，找到这个文件，然后使用编辑器打开。</p>

<p>我这里使用的是Sublime,你可以使用自己喜欢的编辑器。<br>打开后如图所示，可以开始写文章了,写完后请<code>Ctrl+S</code>保存。</p>
<img src="/blog/2b94/005vwoCyly1fn7sz7kug4j30v80i4tc4.jpg" class="">
<p>关于Markdown可以看我这篇文章<a href="https://mapan.tech/posts/b33e.html" target="_blank">Markdown语法和MD编辑器</a></p>
<h5 id="1-3如何在文章插入图片？"><a href="#1-3如何在文章插入图片？" class="headerlink" title="1.3如何在文章插入图片？"></a>1.3如何在文章插入图片？</h5><p>可以看我这篇文章 <a href="/posts/c9c3.html" target="_blank">使Hexo文章图文并茂</a></p>
<h3 id="2-本地预览-非必要，可选"><a href="#2-本地预览-非必要，可选" class="headerlink" title="2.本地预览 (非必要，可选)"></a>2.本地预览 (非必要，可选)</h3><p>在编辑文章过程中，我们肯定不想频繁的部署，查看效果。这时候使用<code>hexo s</code>指令进行本地预览，文章编辑完成，且自己满意后，再进行部署。<br>提示<code>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code><br>这句信息含义是“网站已经运行在本地 <code>http://locahost:4000/</code> ,按<code>Ctrl+C</code>可以停止预览”。<br>我们不要按<code>Ctrl+C</code>，现在直接浏览器打开 <a href="http://locahost:4000/">http://locahost:4000/</a> 即可看到预览效果。</p>


<h3 id="3-渲染并部署网站"><a href="#3-渲染并部署网站" class="headerlink" title="3.渲染并部署网站"></a>3.渲染并部署网站</h3><h5 id="3-1-hexo-g渲染生成网站"><a href="#3-1-hexo-g渲染生成网站" class="headerlink" title="3.1 hexo g渲染生成网站"></a>3.1 <code>hexo g</code>渲染生成网站</h5><p>现在我们文章已经写好，预览也比较满意。现在可以<code>Ctrl+C</code>停止预览，然后<code>hexo g</code>渲染出整套网站代码(你可以在<code>../Blog/public/</code>文件夹下看到整套网站的代码)。</p>

<p>渲染完成后，info提示信息:使用2.01秒生成了74个文件,这表示完成了渲染。</p>

<h5 id="3-2-hexo-d部署网站-把渲染好的html等网站文件，上传到Coding服务器"><a href="#3-2-hexo-d部署网站-把渲染好的html等网站文件，上传到Coding服务器" class="headerlink" title="3.2 hexo d部署网站(把渲染好的html等网站文件，上传到Coding服务器)"></a>3.2 <code>hexo d</code>部署网站(把渲染好的html等网站文件，上传到Coding服务器)</h5><p>如图，除了黄色框框内的信息或许没有，其他都应该有。</p>

<p>最后一句<code>INFO Deploy done: git</code>表示部署已完成。</p>
<blockquote>
<p>写新文章请重复步骤 1–&gt;3</p>
</blockquote>
<hr>
<p>请 <strong>每次执行完命令后 查看命令窗口返回的信息</strong> ，有很多童鞋闷头敲指令，报错了也不管。这样前面有<strong>ERROR</strong>的话，后面的指令就肯定报错。很多步骤都是活的，并不是一成不变不可变通，当你知道他的含义之后，就可以随心所欲，怎么来都行。刚开始不熟悉还是建议按照教程来。</p>
]]></content>
  </entry>
  <entry>
    <title>使Hexo文章图文并茂</title>
    <url>/blog/c9c3.html</url>
    <content><![CDATA[<h1 id="此方法已经失效"><a href="#此方法已经失效" class="headerlink" title="此方法已经失效"></a><del>此方法已经失效</del></h1><p>在上一篇<a href="http://localhost:4000/posts/e10b.html">零基础HEXO搭建博客教程</a>中，陆续有人咨询一些问题，就常见问题做一个回答，本文介绍如何写图文并茂的博客文章。</p>
<p>在Coding上我们的项目大小只有128M/256M/512M，反正我的是256M，也许你的是仓库容量是128M（普通会员），升级绑定腾讯云后壳升级为银牌会员512M仓库容量。</p>


<p>总之不管128/256/512M，对于一个网站来说，如果图片和视频多的话，那是不太够的。今天介绍一种节省空间的方法，使用图床。</p>
<p>什么是图床，我不解释了，看<a href="https://baike.baidu.com/item/%E5%9B%BE%E5%BA%8A/10721348?fr=aladdin">百度百科</a>自己了解下。<br>首先提供图床服务的有很多，收费的免费的各种。今天我们使用的是新浪微博提供的微博图床。此图床需要chrome浏览器配合图床插件使用。<br>有科学上网条件的童鞋，请在谷歌应用商店搜索关键词<code>新浪微博</code>然后安装下图所示插件。</p>


<p>没条件的同学可以去<a href="https://www.crx4chrome.com/extensions/fdfdnfpdplfbbnemmmoklbfjbhecpnhf/">镜像站点</a>安装</p>


<p>安装完成之后，在浏览器的右上角会出现一个这样的图标</p>

<p>我们点一下，会弹出一个窗口，如下图所示</p>


<p>现在随便拖进去一张图片会弹出让我们登录新浪微博，登录自己微博账号即可。<br>下次再拖进进去一张图片，就会弹出如下图所示。</p>

<p>我们选择markdown（原图、中等尺寸、缩略图 分别对应大、中、小三个尺寸，按自己需求选择）点复制即可，把复制的链接粘贴到我们文章所需要的地方，即可。如下图</p>


<p>然后就可以愉快写图文并茂的文章了。</p>
]]></content>
  </entry>
  <entry>
    <title>MR的shuffle过程</title>
    <url>/blog/5119.html</url>
    <content><![CDATA[<p>1）MapReduce计算模型主要由两个阶段构成：Map、Reduce，其中在Map方法之后，Reduce方法之前的这段处理过程叫Shuffle。</p>
<img src="/blog/5119/20151017151302759" class="这里写图片描述">

<p>2）Map方法之后，数据首先进入到分区方法，把数据标记好分区，然后把数据发送到环形缓冲区；环形缓冲区默认大小100m，环形缓冲区达到80%时，进行溢写；溢写前对数据进行排序，排序按照对key的索引进行字典顺序排序，排序的手段为快排；溢写产生大量的溢写文件，需要对溢写文件进行归并排序；对溢写的文件也可以进行Combiner操作，前提是汇总操作，求平均值不行。最后将文件按照分区存储到磁盘，等待Reduce端拉取。</p>
<img src="/blog/5119/20151017160804118" class="这里写图片描述">

<p>3）每个Reduce拉取Map端对应分区的数据。拉取数据后先存储到内存中，内存不够了，再存储到磁盘。拉取完所有数据后，采用归并排序将内存和磁盘中的数据都进行排序。在进入Reduce方法前，可以对数据进行分组操作。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
  </entry>
  <entry>
    <title>SparkSQL概念</title>
    <url>/blog/d275.html</url>
    <content><![CDATA[<h2 id="什么是Spark-SQL"><a href="#什么是Spark-SQL" class="headerlink" title="什么是Spark SQL"></a>什么是Spark SQL</h2><p>Spark SQL是Spark用来处理结构化数据的一个模块，它提供了2个编程抽象：DataFrame和DataSet，并且作为分布式SQL查询引擎的作用。</p>
<p>我们已经学习了Hive，它是将Hive SQL转换成MapReduce然后提交到集群上执行，大大简化了编写MapReduc的程序的复杂性，由于MapReduce这种计算模型执行效率比较慢。所有Spark SQL的应运而生，它是将Spark SQL转换成RDD，然后提交到集群执行，执行效率非常快！</p>
<h3 id="Spark-SQL的特点"><a href="#Spark-SQL的特点" class="headerlink" title="Spark SQL的特点"></a>Spark SQL的特点</h3><p>1）易整合</p>
<img src="/blog/d275/clip_image001.png" class="img">

<p>2）统一的数据访问方式</p>
<img src="/blog/d275/clip_image002.png" class="img">

<p>3）兼容Hive</p>
<img src="/blog/d275/clip_image003.png" class="img">

<p>4）标准的数据连接</p>
<img src="/blog/d275/clip_image004.png" class="img">

<h3 id="什么是DataFrame"><a href="#什么是DataFrame" class="headerlink" title="什么是DataFrame"></a>什么是DataFrame</h3><p>与RDD类似，DataFrame也是一个分布式数据容器。然而DataFrame更像传统数据库的二维表格，除了数据以外，还记录数据的结构信息，即schema。同时，与Hive类似，DataFrame也支持嵌套数据类型（struct、array和map）。从API易用性的角度上看，DataFrame API提供的是一套高层的关系操作，比函数式的RDD API要更加友好，门槛更低。</p>
<img src="/blog/d275/clip_image005.png" class="img">

<p> 上图直观地体现了DataFrame和RDD的区别。左侧的RDD[Person]虽然以Person为类型参数，但Spark框架本身不了解Person类的内部结构。而右侧的DataFrame却提供了详细的结构信息，使得Spark SQL可以清楚地知道该数据集中包含哪些列，每列的名称和类型各是什么。DataFrame是为数据提供了Schema的视图。可以把它当做数据库中的一张表来对待，DataFrame也是懒执行的。性能上比RDD要高，主要原因：</p>
<p>优化的执行计划：查询计划通过Spark catalyst optimiser进行优化。</p>
<img src="/blog/d275/clip_image006.png" class="img">

<p>比如下面一个例子： </p>
<img src="/blog/d275/clip_image007.png" class="img">
<img src="/blog/d275/clip_image008.png" class="img">

<p> 为了说明查询优化，我们来看上图展示的人口数据分析的示例。图中构造了两个DataFrame，将它们join之后又做了一次filter操作。如果原封不动地执行这个执行计划，最终的执行效率是不高的。因为join是一个代价较大的操作，也可能会产生一个较大的数据集。如果我们能将filter下推到 join下方，先对DataFrame进行过滤，再join过滤后的较小的结果集，便可以有效缩短执行时间。而Spark SQL的查询优化器正是这样做的。简而言之，逻辑查询计划优化就是一个利用基于关系代数的等价变换，将高成本的操作替换为低成本操作的过程。 </p>
<h3 id="什么是DataSet"><a href="#什么是DataSet" class="headerlink" title="什么是DataSet"></a>什么是DataSet</h3><p>1）是Dataframe API的一个扩展，是Spark最新的数据抽象。<br>2）用户友好的API风格，既具有类型安全检查也具有Dataframe的查询优化特性。<br>3）Dataset支持编解码器，当需要访问非堆上的数据时可以避免反序列化整个对象，提高了效率。<br>4）样例类被用来在Dataset中定义数据的结构信息，样例类中每个属性的名称直接映射到DataSet中的字段名称。<br>5） Dataframe是Dataset的特列，DataFrame=Dataset[Row] ，所以可以通过as方法将Dataframe转换为Dataset。Row是一个类型，跟Car、Person这些的类型一样，所有的表结构信息我都用Row来表示。<br>6）DataSet是强类型的。比如可以有Dataset[Car]，Dataset[Person].<br>7）DataFrame只是知道字段，但是不知道字段的类型，所以在执行这些操作的时候是没办法在编译的时候检查是否类型失败的，比如你可以对一个String进行减法操作，在执行的时候才报错，而DataSet不仅仅知道字段，而且知道字段类型，所以有更严格的错误检查。就跟JSON对象和类对象之间的类比。</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>Spark共享变量底层实现</title>
    <url>/blog/683.html</url>
    <content><![CDATA[<p>Spark一个非常重要的特性就是共享变量。</p>
<p>默认情况下，如果在一个算子的函数中使用到了某个外部的变量，那么这个变量的值会被拷贝到每个task中，此时每个task只能操作自己的那份变量副本。如果多个task想要共享某个变量，那么这种方式是做不到的。</p>
<p>Spark为此提供了两种共享变量，一种是Broadcast Variable（广播变量），另一种是Accumulator（累加变量）。Broadcast Variable会将用到的变量，仅仅为每个节点拷贝一份，即每个Executor拷贝一份，更大的用途是优化性能，减少网络传输以及内存损耗。Accumulator则可以让多个task共同操作一份变量，主要可以进行累加操作。Broadcast Variable是共享读变量，task不能去修改它，而Accumulator可以让多个task操作一个变量。</p>
<h2 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a><strong>广播变量</strong></h2><p>广播变量允许编程者在每个Executor上保留外部数据的只读变量，而不是给每个任务发送一个副本。 </p>
<p>每个task都会保存一份它所使用的外部变量的副本，当一个Executor上的多个task都使用一个大型外部变量时，对于Executor内存的消耗是非常大的，因此，我们可以将大型外部变量封装为广播变量，此时一个Executor保存一个变量副本，此Executor上的所有task共用此变量，不再是一个task单独保存一个副本，这在一定程度上降低了Spark任务的内存占用。</p>
<img src="/blog/683/clip_image001.jpg" class="img">

<p>task使用外部变量</p>
<img src="/blog/683/clip_image002.jpg" class="img">

<p>使用广播变量</p>
<p>Spark还尝试使用高效的广播算法分发广播变量，以降低通信成本。</p>
<p>Spark提供的Broadcast Variable是只读的，并且在每个Executor上只会有一个副本，而不会为每个task都拷贝一份副本，因此，它的最大作用，就是减少变量到各个节点的网络传输消耗，以及在各个节点上的内存消耗。此外，Spark内部也使用了高效的广播算法来减少网络消耗。</p>
<p>可以通过调用SparkContext的broadcast()方法来针对每个变量创建广播变量。然后在算子的函数内，使用到广播变量时，每个Executor只会拷贝一份副本了，每个task可以使用广播变量的value()方法获取值。</p>
<p>在任务运行时，Executor并不获取广播变量，当task执行到 使用广播变量的代码时，会向Executor的内存中请求广播变量，如下图所示：</p>
<img src="/blog/683/clip_image003.jpg" class="img">

<p>task向Executor请求广播变量</p>
<p>之后Executor会通过BlockManager向Driver拉取广播变量，然后提供给task进行使用，如下图所示：</p>
<img src="/blog/683/clip_image004.jpg" class="img">

<p>Executor从Driver拉取广播变量</p>
<p>广播大变量是Spark中常用的基础优化方法，通过减少内存占用实现任务执行性能的提升。</p>
<h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a><strong>累加器</strong></h2><p>累加器（accumulator）：Accumulator是仅仅被相关操作累加的变量，因此可以在并行中被有效地支持。它们可用于实现计数器（如MapReduce）或总和计数。</p>
<p>Accumulator是存在于Driver端的，集群上运行的task进行Accumulator的累加，随后把值发到Driver端，在Driver端汇总（Spark UI在SparkContext创建时被创建，即在Driver端被创建，因此它可以读取Accumulator的数值），由于Accumulator存在于Driver端，从节点读取不到Accumulator的数值。</p>
<p>Spark提供的Accumulator主要用于多个节点对一个变量进行共享性的操作。Accumulator只提供了累加的功能，但是却给我们提供了多个task对于同一个变量并行操作的功能，但是task只能对Accumulator进行累加操作，不能读取它的值，只有Driver程序可以读取Accumulator的值。</p>
<p>Accumulator的底层原理如下图所示：</p>
<img src="/blog/683/clip_image005.jpg" class="img">

<p>累加器原理</p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>hive管理表和外部表</title>
    <url>/blog/9f73.html</url>
    <content><![CDATA[<p>管理表<br>我们目前所创建的标都是所谓的管理表，有时也会被称为内部表，因为这种表，Hive会控制着数据的生命周期。正如我们所看见的，Hive默认情况下会将这些表的数据存储在由配置项hive.metastore.dir所定义的目录的子目录下。</p>
<p>管理表不方便和其他工作共享数据，例如，假设我们有一份有pig或者其他工具创建并且主要有这一工具使用的数据，同时我们还想使用Hive在这份数据上执行一些查询，可是并没有给与Hive对数据的所有权，我们可以创建一个外部表指向这份数据，而并不需要对其拥有所有权。</p>
<p>外部表<br>因为表是外部的，所以Hive并非认为其完全拥有这份数据。因此，删除该表并不会删除掉这份数据，不过描述表的元数据信息会被删除掉。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SparkSQL基本操作</title>
    <url>/blog/bfb1.html</url>
    <content><![CDATA[<p>首先进入spark-shell</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">$ bin/spark-shell</span><br><span class="line"><span class="type">Using</span> <span class="type">Spark</span>&#x27;s <span class="keyword">default</span> log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line"><span class="type">Setting</span> <span class="keyword">default</span> log level to <span class="string">&quot;WARN&quot;</span>.</span><br><span class="line"><span class="type">To</span> adjust logging level use sc.setLogLevel(newLevel). <span class="type">For</span> <span class="type">SparkR</span>, use setLogLevel(newLevel).</span><br><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//192.168.1.102:4040</span></span><br><span class="line"><span class="type">Spark</span> context available as &#x27;sc&#x27; (master = local[*], app id = local<span class="number">-1569915192693</span>).</span><br><span class="line"><span class="type">Spark</span> session available as &#x27;spark&#x27;.</span><br><span class="line"><span class="type">Welcome</span> to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version <span class="number">2.1</span><span class="number">.1</span></span><br><span class="line">      /_/</span><br><span class="line">         </span><br><span class="line"><span class="type">Using</span> <span class="type">Scala</span> version <span class="number">2.11</span><span class="number">.8</span> (<span class="type">Java</span> <span class="type">HotSpot</span>(<span class="type">TM</span>) <span class="number">64</span>-<span class="type">Bit</span> <span class="type">Server</span> <span class="type">VM</span>, <span class="type">Java</span> <span class="number">1.8</span><span class="number">.0</span>_144)</span><br><span class="line"><span class="type">Type</span> in expressions to have them evaluated.</span><br><span class="line"><span class="type">Type</span> :help <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>
<h2 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h2><ul>
<li>从json文件中创建DataFrame</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;./examples/src/main/resources/people.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint, name: string]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li>对DataFrame创建一个临时表</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceTempView(<span class="string">&quot;people&quot;</span>)</span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select * from people&quot;</span>).show</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<h2 id="方法一-RDDtoDF创建DataFrame"><a href="#方法一-RDDtoDF创建DataFrame" class="headerlink" title="方法一: RDDtoDF创建DataFrame"></a>方法一: RDDtoDF创建DataFrame</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> spark.implicits._</span><br><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> peopleRDD = sc.textFile(<span class="string">&quot;./examples/src/main/resources/people.txt&quot;</span>)</span><br><span class="line">peopleRDD: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = ./examples/src/main/resources/people.txt <span class="type">MapPartitionsRDD</span>[<span class="number">34</span>] at textFile at &lt;console&gt;:<span class="number">27</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = peopleRDD.map&#123;x=&gt;<span class="keyword">val</span> para=x.split(<span class="string">&quot;,&quot;</span>);(para(<span class="number">0</span>),para(<span class="number">1</span>).trim.toInt)&#125;.toDF(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+-------+---+</span><br><span class="line">|   name|age|</span><br><span class="line">+-------+---+</span><br><span class="line">|<span class="type">Michael</span>| <span class="number">29</span>|</span><br><span class="line">|   <span class="type">Andy</span>| <span class="number">30</span>|</span><br><span class="line">| <span class="type">Justin</span>| <span class="number">19</span>|</span><br><span class="line">+-------+---+</span><br></pre></td></tr></table></figure>

<h3 id="方法二-样例类转DataFrame-常用方式"><a href="#方法二-样例类转DataFrame-常用方式" class="headerlink" title="方法二 : 样例类转DataFrame(常用方式)"></a>方法二 : 样例类转DataFrame(常用方式)</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">people</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; peopleRDD.map&#123;x=&gt;<span class="keyword">val</span> para=x.split(<span class="string">&quot;,&quot;</span>);people(para(<span class="number">0</span>),para(<span class="number">1</span>).trim.toInt) &#125;.toDF</span><br><span class="line">res21: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br></pre></td></tr></table></figure>
<h3 id="方法三-通过schema创建DataFrame"><a href="#方法三-通过schema创建DataFrame" class="headerlink" title="方法三: 通过schema创建DataFrame"></a>方法三: 通过schema创建DataFrame</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入所需的类型</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.types._</span><br><span class="line"><span class="comment">// 创建Schema</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> structType: <span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">StructField</span>(<span class="string">&quot;name&quot;</span>, <span class="type">StringType</span>) :: <span class="type">StructField</span>(<span class="string">&quot;age&quot;</span>, <span class="type">IntegerType</span>) :: <span class="type">Nil</span>)</span><br><span class="line">structType: org.apache.spark.sql.types.<span class="type">StructType</span> = <span class="type">StructType</span>(<span class="type">StructField</span>(name,<span class="type">StringType</span>,<span class="literal">true</span>), <span class="type">StructField</span>(age,<span class="type">IntegerType</span>,<span class="literal">true</span>))</span><br><span class="line"><span class="comment">// 导入所需的类型</span></span><br><span class="line">scala&gt; <span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">Row</span></span><br><span class="line"><span class="comment">// 根据给定的类型创建二元组RDD</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> data = peopleRDD.map&#123; x =&gt; <span class="keyword">val</span> para = x.split(<span class="string">&quot;,&quot;</span>);<span class="type">Row</span>(para(<span class="number">0</span>),para(<span class="number">1</span>).trim.toInt)&#125;</span><br><span class="line">data: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">41</span>] at map at &lt;console&gt;:<span class="number">33</span></span><br><span class="line"><span class="comment">// 根据数据及给定的schema创建DataFrame</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> dataFrame = spark.createDataFrame(data, structType)</span><br><span class="line">dataFrame: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: int]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建DataSet"><a href="#创建DataSet" class="headerlink" title="创建DataSet"></a>创建DataSet</h2><h3 id="通过样例类创建DataSet"><a href="#通过样例类创建DataSet" class="headerlink" title="通过样例类创建DataSet"></a>通过样例类创建DataSet</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> caseClassDS = <span class="type">Seq</span>(<span class="type">Person</span>(<span class="string">&quot;Andy&quot;</span>, <span class="number">32</span>)).toDS()</span><br><span class="line">caseClassDS: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; caseClassDS.show</span><br><span class="line">+----+---+</span><br><span class="line">|name|age|</span><br><span class="line">+----+---+</span><br><span class="line">|<span class="type">Andy</span>| <span class="number">32</span>|</span><br><span class="line">+----+---+</span><br></pre></td></tr></table></figure>

<h3 id="从RDD创建DataSet"><a href="#从RDD创建DataSet" class="headerlink" title="从RDD创建DataSet"></a>从RDD创建DataSet</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> peopleRDD = sc.textFile(<span class="string">&quot;examples/src/main/resources/people.txt&quot;</span>)</span><br><span class="line">peopleRDD: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = examples/src/main/resources/people.txt <span class="type">MapPartitionsRDD</span>[<span class="number">1</span>] at textFile at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; peopleRDD.map(line =&gt; &#123;<span class="keyword">val</span> para = line.split(<span class="string">&quot;,&quot;</span>);<span class="type">Person</span>(para(<span class="number">0</span>),para(<span class="number">1</span>).trim.toInt)&#125;).toDS</span><br><span class="line">res1: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; res1.show</span><br><span class="line">+-------+---+</span><br><span class="line">|   name|age|</span><br><span class="line">+-------+---+</span><br><span class="line">|<span class="type">Michael</span>| <span class="number">29</span>|</span><br><span class="line">|   <span class="type">Andy</span>| <span class="number">30</span>|</span><br><span class="line">| <span class="type">Justin</span>| <span class="number">19</span>|</span><br><span class="line">+-------+---+</span><br></pre></td></tr></table></figure>

<h2 id="DataFrame与DataSet的互相转换"><a href="#DataFrame与DataSet的互相转换" class="headerlink" title="DataFrame与DataSet的互相转换"></a>DataFrame与DataSet的互相转换</h2><h3 id="DataFreame转DataSet"><a href="#DataFreame转DataSet" class="headerlink" title="DataFreame转DataSet"></a>DataFreame转DataSet</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;examples/src/main/resources/people.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: bigint, name: string]                </span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; df.as[<span class="type">Person</span>]</span><br><span class="line">res3: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [age: bigint, name: string]</span><br><span class="line"></span><br><span class="line">scala&gt; res3.show</span><br><span class="line">+----+-------+</span><br><span class="line">| age|   name|</span><br><span class="line">+----+-------+</span><br><span class="line">|<span class="literal">null</span>|<span class="type">Michael</span>|</span><br><span class="line">|  <span class="number">30</span>|   <span class="type">Andy</span>|</span><br><span class="line">|  <span class="number">19</span>| <span class="type">Justin</span>|</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<h3 id="DasaSet转DataFrame"><a href="#DasaSet转DataFrame" class="headerlink" title="DasaSet转DataFrame"></a>DasaSet转DataFrame</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = <span class="type">Seq</span>(<span class="type">Person</span>(<span class="string">&quot;Andy&quot;</span>, <span class="number">32</span>)).toDS()</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = ds.toDF</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+----+---+</span><br><span class="line">|name|age|</span><br><span class="line">+----+---+</span><br><span class="line">|<span class="type">Andy</span>| <span class="number">32</span>|</span><br><span class="line">+----+---+</span><br></pre></td></tr></table></figure>
<h2 id="三者的互相转换"><a href="#三者的互相转换" class="headerlink" title="三者的互相转换"></a>三者的互相转换</h2><img src="/blog/bfb1/1569984874237.png" class="1569984874237">

<p>三者的共性</p>
<ol>
<li><code>RDD</code>、<code>DataFrame</code>、<code>Dataset</code>全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利;</li>
<li>三者都有惰性机制，在进行创建、转换，如<code>map</code>方法时，不会立即执行，只有在遇到<code>Action</code>如<code>foreach</code>时，三者才会开始遍历运算;</li>
<li>三者有许多共同的函数，如filter，排序等;</li>
<li>在对<code>DataFrame</code>和<code>Dataset</code>进行操作许多操作都需要导入隐式转换 <code>:import spark.implicits._</code>（在创建好<code>SparkSession</code>对象后尽量直接导入）</li>
</ol>
<p>编译器中的实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from people.scala</span></span><br><span class="line"><span class="keyword">package</span> tech.mapan.bean</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">people</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">BigInt</span></span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from SparkSQLTest.scala</span></span><br><span class="line"><span class="keyword">package</span> tech.mapan</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"><span class="keyword">import</span> tech.mapan.bean.people</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SparkSQLTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * DataFrame、DataSet、rdd之间的转换/ sparkSQL初步应用</span></span><br><span class="line"><span class="comment">    * @param args</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span>.builder().appName(<span class="string">&quot;sparkSQL&quot;</span>).master(<span class="string">&quot;local[*]&quot;</span>).getOrCreate()</span><br><span class="line">    <span class="keyword">import</span> spark.implicits._</span><br><span class="line">    <span class="comment">// 从文件创建DataFrame</span></span><br><span class="line">    <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;./src/main/resources/people.json&quot;</span>)</span><br><span class="line">    df.show</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DataFrame转DataSet</span></span><br><span class="line">    <span class="keyword">val</span> ds = df.as[people]</span><br><span class="line">    ds.show</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DataFrame转rdd</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = df.rdd</span><br><span class="line">    rdd1.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DataSet转rdd</span></span><br><span class="line">    <span class="keyword">val</span> rdd2 = ds.rdd</span><br><span class="line">    rdd2.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时表</span></span><br><span class="line">    ds.createOrReplaceTempView(<span class="string">&quot;persons&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sql查询年龄超过21岁的人。</span></span><br><span class="line">    spark.sql(<span class="string">&quot;SELECT * FROM persons WHERE age &gt; 21&quot;</span>).show</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sql查询所有人年龄的和</span></span><br><span class="line">    spark.sql(<span class="string">&quot;SELECT SUM(age) FROM persons&quot;</span>).show</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    spark.stop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spark</category>
      </categories>
  </entry>
  <entry>
    <title>Hive时间戳的踩坑</title>
    <url>/blog/2a2e.html</url>
    <content><![CDATA[<p>公司的数据处理是用的Spark on Hive, 在处理时间戳的时候，又踩了坑。在一个过滤条件中，带毫秒的时间戳没有得到期待的结果。</p>
<p>比如下面的SQL中，按照理解49ms早于118毫秒的，所以SQL执行结果是 <code>True</code>,但实际结果却是<code>False</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="built_in">cast</span>(<span class="string">&#x27;2022-05-19 21:09:24.49&#x27;</span> <span class="keyword">as</span> <span class="type">timestamp</span>) <span class="operator">&lt;=</span> <span class="built_in">cast</span>(<span class="string">&#x27;2022-05-19 21:09:24.118&#x27;</span> <span class="keyword">as</span> <span class="type">timestamp</span>)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<p>若想要得到期待的结果，需要转换成13位的，带毫秒的时间戳，再进行转换。</p>
<p>可以使用如下的方式（其中ts2ms为自定义UDF函数）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">ts2ms(<span class="built_in">cast</span>(<span class="string">&#x27;2022-05-19 21:09:24.49&#x27;</span> <span class="keyword">as</span> <span class="type">timestamp</span>), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss.SSS&#x27;</span>) <span class="operator">&lt;=</span></span><br><span class="line">ts2ms(<span class="built_in">cast</span>(<span class="string">&#x27;2022-05-19 21:09:24.118&#x27;</span> <span class="keyword">as</span> <span class="type">timestamp</span>), <span class="string">&#x27;yyyy-MM-dd HH:mm:ss.SSS&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>debian设置UFW防火墙</title>
    <url>/blog/fa86.html</url>
    <content><![CDATA[<p>在服务器上部署了许多服务，通过nginx反向代理共用443端口，通过不同的域名来区分不同的服务。</p>
<p>但是搬瓦工默认的防火墙是不开的，也就是说这些服务除了443端口能访问外，原始端口也可以访问。对此我有一些安全上的顾虑，所以考虑到把防火墙打开，只把443端口和ssh的端口放出去。</p>
<p>UFW</p>
<p>ufw是一个主机端的iptables防火墙配置工具，帮助我们简单化配置iptables。</p>
<p>查看iptable规则</p>
<p><code>sudo iptables --list-rule</code></p>
<p>UFW常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ufw #安装</span><br><span class="line">sudo ufw enable #启动</span><br><span class="line">sudo ufw disable #禁用</span><br><span class="line">sudo ufw reload #重新载入</span><br><span class="line">sudo ufw reset #回复初始化设置</span><br><span class="line">sudo ufw status #防火墙状态</span><br></pre></td></tr></table></figure>

<p>UFW防火墙的默认行为是阻止所有传入和转发流量，并允许所有出站流量。</p>
<p>在开启UFW之前，首先把ssh端口加入到允许列表</p>
<p>ssh端口是7722，设置如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 7722/tcp</span><br></pre></td></tr></table></figure>

<p>打开443端口，作为网站默认的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 443/tcp</span><br></pre></td></tr></table></figure>

<p>另外发现在设置好防火墙后，我的docker服务中的其他端口，依然能通过外网访问？</p>
<p>查了<a href="https://askubuntu.com/questions/652556/uncomplicated-firewall-ufw-is-not-blocking-anything-when-using-docker">相关问题</a>，<a href="https://www.zhaokeli.com/article/8613.html">相关问题</a>，发现是docker也会修改防火墙的设置</p>
<p>把docker的配置文件<code>/etc/docker/daemon.json</code> （没有则新建）加一行，重启docker服务即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;iptables&quot; : false &#125;</span><br></pre></td></tr></table></figure>

<p>UFW 删除规则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw status numbered <span class="comment"># 列出所有规则</span></span><br><span class="line"></span><br><span class="line">sudo ufw delete 3 <span class="comment"># 删除3号规则</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Python时区设置</title>
    <url>/blog/31a0.html</url>
    <content><![CDATA[<p>最近在使用Python开发一个serverless的云函数，在自己电脑上运行的好好的，部署到云服务上就和本地运行结果不一致。琢磨了一下是时区不同导致的运行环境不一致。</p>
<p>我是用的是腾讯云的SCF云函数，云服务默认运行环境的时区是UTC，本地环境的运行时区是UTC+8，在我开发的例子的当中需要当前日期作为参数。只需要在代码中加入时区设置即可保持开发环境和运行环境一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main_handler</span>(<span class="params">event, context</span>):</span><br><span class="line"><span class="comment"># 设置时区为上海</span></span><br><span class="line">    os.environ[<span class="string">&#x27;TZ&#x27;</span>] = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">    time.tzset()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>手动申请证书</title>
    <url>/blog/4364.html</url>
    <content><![CDATA[<p>家里的宽带有公网IP，但是80/443端口不能使用。</p>
<p>大学时候的老电脑(i54200M+8G DDR3L)，现在看来配置已经相当落后了，如果二手市场也卖不上价。</p>
<p>之前给安装了Debian11系统，长期运行几个月，在内网中跑一些小程序。</p>
<p>从中也乐此不疲的学到很多新知识。</p>
<p>最近想在非标准端口搭网站，并且启动HTTPS，所以需要给域名申请证书。</p>
<p>而安装的Nginx Proxy Manager，由于没有80/443端口，所以不能自动申请证书。</p>
<p>琢磨了一下，把手动申请证书的过程记下来：</p>
<p>（此处不讲如何安装docker和docker-compose）</p>
<p>docker 安装 acme.sh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm  -itd  \</span><br><span class="line">  -v &quot;$(pwd)/out&quot;:/acme.sh  \</span><br><span class="line">  --net=host \</span><br><span class="line">  --name=acme.sh \</span><br><span class="line">  neilpang/acme.sh daemon</span><br></pre></td></tr></table></figure>
<ol>
<li>注册acme账户</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> acme.sh --register-account -m user@yourdomain.com</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>给 ‘*.yourdomain.com’ 申请证书</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> acme.sh --issue --dns -d <span class="string">&#x27;*.yourdomain.com&#x27;</span> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure></li>
<li><p>按照提示，在域名服务商的<strong>域名解析</strong>处加入一条TXT记录。</p>
</li>
<li><p>给 ‘*.nbee.ml’ 完成申请证书</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> acme.sh --renew -d <span class="string">&#x27;*.yourdomain.com&#x27;</span> --yes-I-know-dns-manual-mode-enough-go-ahead-please</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>即可在out文件夹下获得证书以及密钥等文件。</li>
<li>填写如NPM<br>Certificate Key –&gt; 域名.key<br>Certificate –&gt; fullchain.cer<br>Intermediate Certificate –&gt; 域名.cer</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>搭建gitea服务</title>
    <url>/blog/913d.html</url>
    <content><![CDATA[<p>在Docker中安装gitea</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> gitea &amp;&amp; <span class="built_in">cd</span> gitea &amp;&amp; <span class="built_in">touch</span> docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>在docker-compose.yml中填入下面内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:1.16.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1001</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_TYPE=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=db:5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASSWD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA_CUSTOM=/data/custom</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;2222:22&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:14</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_DB=gitea</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./postgres:/var/lib/postgresql/data</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>最后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>gitea即安装完成，然后访问<code>localhost:3000</code> 即可开启gitea之旅。在主页填写好地址，邮箱，用户等信息即可。</p>
<p>可以把3000端口映射到公网443端口，绑定好域名</p>
<p>另外把2222端口绑定到公网22端口，即可（官网有ssh和gitea复用22端口的方法，我尝试没有成功。但我通过路由器UPnP端口转发搞定了22端口）</p>
]]></content>
  </entry>
  <entry>
    <title>crontab用法</title>
    <url>/blog/6711.html</url>
    <content><![CDATA[<p>最近有个需求每天07:00 和 23:00各运行一个脚本（断网，为了健康夜里就不上网了吧），有现成的可视化框架可以用，那就是青龙面板。但用青龙有点杀鸡用牛刀的感觉，所以就学习一下crontab的用法。</p>
<p>首先编写两个需要运行的脚本 <code>0700.sh</code> 和<code>2300.sh</code>（根据自己需求来），并给予运行权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前的crontab</span></span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑crontab</span></span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用vim命令添加如下两行</span></span><br><span class="line">* 7 * * * bash /path/to/file/0700.sh</span><br><span class="line">* 7 * * * bash /path/to/file/2300.sh</span><br><span class="line"><span class="comment"># 这里建议使用绝对路径</span></span><br></pre></td></tr></table></figure>

<p>测试脚步正常，收工。</p>
]]></content>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/blog/1d91.html</url>
    <content><![CDATA[<p>Docker 不管是在企业生产中，还是个人小项目中，应用都非常的方便且简单快捷，开始学习一些Docker的常见用法：</p>
<p>列出本地的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images -a</span><br></pre></td></tr></table></figure>

<p>搜索mysql的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search mysql --<span class="built_in">limit</span> 10</span><br></pre></td></tr></table></figure>

<p>拉取到本地，版本号可选。若不带版本号，默认是latest</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker pull ubuntu</span><br><span class="line">docker pull redis:6.0.8</span><br></pre></td></tr></table></figure>



<p>列出本地镜像的image_id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images -q</span><br></pre></td></tr></table></figure>



<p>列出docker目前的磁盘占用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker system <span class="built_in">df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          1         0         72.78MB   72.78MB (100%)</span><br><span class="line">Containers      0         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     0         0         0B        0B</span><br></pre></td></tr></table></figure>

<p>删除本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu        latest    ba6acccedd29   2 months ago   72.8MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB</span><br><span class="line">➜  ~ docker rmi hello-world</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f</span><br><span class="line">Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</span><br><span class="line">Deleted: sha256:e07ee1baac5fae6a26f30cabfe54a36d3402f96afda318fe0a96cec4ca393359</span><br><span class="line">➜  ~ docker images         </span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">ubuntu       latest    ba6acccedd29   2 months ago   72.8MB</span><br></pre></td></tr></table></figure>

<p>新建并启动容器</p>
<p>-it 代表 interactive tty</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=myu1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>列出当前运行的docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>使用<code>docker run -it</code>启动的容器，自动进入交互式命令行，退出有两种方式：</p>
<ul>
<li>exit命令（容器停止运行）</li>
<li>快捷键ctrl+p+q（容器继续后台运行）</li>
</ul>
<p>docker run和docker start的区别：</p>
<p>docker run是使用镜像启动一个新的容器，而docker start是启动之前存在的容器。</p>
<p>删除已经停止的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> container_id / name</span><br></pre></td></tr></table></figure>

<p>进入活动状态的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker attach container_id/name</span><br></pre></td></tr></table></figure>

<p>上面命令如果使用exit退出，会使容器停止</p>
<p>想要退出时候保持后台运行，可以按快捷键control+p+q (control按住不放，先后按下p和q)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> container_id</span><br></pre></td></tr></table></figure>

<p>上面命令进入，使用exit退出，不会使容器退出</p>
<p>容器传文件到宿主机（在宿主机执行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> container_id:/file/to/path </span><br></pre></td></tr></table></figure>

<p>把整个容器导出为一个tar包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> container_id &gt; ~/abcd.tar</span><br></pre></td></tr></table></figure>

<p>从导出包导入容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/abcd.tar | docker import - 用户名/镜像名字:版本号</span><br></pre></td></tr></table></figure>

<p>把修改好的container进行commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -m=<span class="string">&quot;add vim for ubuntu&quot;</span> -a=<span class="string">&quot;mapxn&quot;</span> d99969a97223 ubuntu-vim:1.0.1</span><br></pre></td></tr></table></figure>

<p>发布到阿里云的私有仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push registry.cn-shanghai.aliyuncs.com/mpn/dkdk:1.0.1</span><br></pre></td></tr></table></figure>

<p>挂载容器数据卷</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v ~/repo/docker:/tmp:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>跑一个mysql实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> \</span><br><span class="line">-v ~/repo/docker/mysql/log:/var/log/mysql \</span><br><span class="line">-v ~/repo/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">-v ~/repo/docker/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql mysql</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">宿主机</th>
<th align="left">容器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">端口</td>
<td align="left">3306</td>
<td align="left">3306</td>
</tr>
<tr>
<td align="left">日志目录</td>
<td align="left">~/repo/docker/mysql/log</td>
<td align="left">/var/log/mysql</td>
</tr>
<tr>
<td align="left">数据目录</td>
<td align="left">~/repo/docker/mysql/data</td>
<td align="left">/var/lib/mysql</td>
</tr>
<tr>
<td align="left">配置目录</td>
<td align="left">~/repo/docker/mysql/conf</td>
<td align="left">/etc/mysql/conf.d</td>
</tr>
</tbody></table>
<p>配置~/repo/docker/mysql/conf/my.cnf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat my.cnf</span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br></pre></td></tr></table></figure>

<p>重启mysql容器。</p>
<p>运行一个postgresql实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name postgres \</span><br><span class="line">-p 5432:5432 \</span><br><span class="line">-e POSTGRES_PASSWORD=123456 \</span><br><span class="line">-v ~/repo/docker/postgres-data/:/var/lib/postgresql/data \</span><br><span class="line">postgres</span><br></pre></td></tr></table></figure>

<p>查看容器占用的磁盘大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system <span class="built_in">df</span> -v</span><br></pre></td></tr></table></figure>



<p>docker列出虚悬镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span> -f dangling=ture</span><br></pre></td></tr></table></figure>



<p>删除虚悬镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>

<p>查看docker网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>



<p>docker 安装portainer</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8000:8000 \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9443:9443 \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure>



<p>docker 安装tomcat</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">--name tomcat \</span><br><span class="line">tomcat</span><br></pre></td></tr></table></figure>

<p>docker 安装 nginx （开启文件服务器）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/repo/docker/nginx/www</span><br><span class="line">docker run --name nginx -p 8888:80 -d nginx</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/conf.d ~/repo/docker/nginx</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/nginx.conf ~/repo/docker/nginx</span><br><span class="line">docker <span class="built_in">rm</span> -f nginx</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">--name nginx \</span><br><span class="line">-v ~/repo/docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro \</span><br><span class="line">-v ~/repo/docker/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v ~/repo/docker/nginx/www:/home/www \</span><br><span class="line">-p 8888:80 \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>



<p>docker 安装frps</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--restart=always \</span><br><span class="line">--network host \</span><br><span class="line">-v ~/docker/frp:/etc/frp \</span><br><span class="line">--name frps \</span><br><span class="line">-it snowdreamtech/frps</span><br></pre></td></tr></table></figure>



<p>docker 查看正在运行的容器日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs -f</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Hive分区表设置分区文件数</title>
    <url>/blog/a302.html</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.shuffle.partitions<span class="operator">=</span><span class="number">2000</span>; <span class="comment">-- 这里是设置 shuffle 分区数量（并行度）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> target_table <span class="keyword">partition</span> (start_dt)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> working_table</span><br><span class="line">distribute <span class="keyword">by</span> start_dt, <span class="built_in">ceil</span>(rand(<span class="number">1</span>)<span class="operator">*</span><span class="number">100</span>)</span><br><span class="line">;</span><br><span class="line"><span class="comment">-- 这里的100是实际文件数量</span></span><br></pre></td></tr></table></figure>



<p>可以修改100的大小来灵活确定文件的个数。</p>
<p>最终文件数量 = min( shuffle 分区数量 , 实际文件数量 )</p>
]]></content>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/blog/a89.html</url>
    <content><![CDATA[<p>2021年末，换了一台Macbook Pro 14寸的电脑。把之前的博客迁移到新电脑上，博客一年多没更新了，等周末把去年的笔记整理过来。更换了博客的主题，由于之前的EVEN主题不支持arm架构的系统，所以换到了更为流行的NEXT。同时也更换了评论系统，在21年10月，Valine评论被大规模XSS注入，导致网站被遮蔽罩盖住，所以换到Waline评论。之前的评论花了点功夫已经迁移过来了。</p>
<p>新的开始，希望一切都好，我，回来了。</p>
]]></content>
  </entry>
  <entry>
    <title>拉链表的数据质量</title>
    <url>/blog/f729.html</url>
    <content><![CDATA[<p>在使用上游提供的表的时候，我们默认是信任的。但现实往往不如人意，上游表的质量不能保证，需要自己先检验再使用。最近我们的数据出现问题，排查到源头是上游一个拉链表出现了数据重复/重叠。</p>
<p>解决方法是我们下游设置一个Data Quality Rule，每天对上游的这个拉链表进行检测，如果发现重叠/重复，就发邮件给Owner解决。</p>
<p>一个正常的拉链表应该如同<code>user_id = 101</code>的数据这样衔接，而不是像<code>user_id = 102</code> 这样时间范围有重叠，从业务角度来说，一个用户在同一个时间点不能有两个互斥状态（比如一个用户，在同一个时刻即是男又是女）。</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>status_cd</th>
<th>start_ts</th>
<th>end_ts</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td>A</td>
<td><code>2022-01-01 00:00:00</code></td>
<td><code>2022-01-08 00:00:00</code></td>
</tr>
<tr>
<td>101</td>
<td>B</td>
<td><code>2022-01-08 00:00:00</code></td>
<td><code>2022-01-12 00:00:00</code></td>
</tr>
<tr>
<td>101</td>
<td>C</td>
<td><code>2022-01-12 00:00:00</code></td>
<td><code>NULL</code></td>
</tr>
<tr>
<td>102</td>
<td>A</td>
<td><code>2022-01-01 00:00:00</code></td>
<td><code>2022-01-08 00:00:00</code></td>
</tr>
<tr>
<td>102</td>
<td>B</td>
<td><code>2022-01-06 00:00:00</code></td>
<td><code>2022-01-10 00:00:00</code></td>
</tr>
<tr>
<td>102</td>
<td>C</td>
<td><code>2022-01-10 00:00:00</code></td>
<td><code>NULL</code></td>
</tr>
</tbody></table>
<p>检测Overlap：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> t1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">table</span> t2</span><br><span class="line"><span class="keyword">on</span> t1.user_id <span class="operator">=</span> t2.user_id</span><br><span class="line"><span class="keyword">where</span> t1.start_ts <span class="operator">&lt;</span> t2.end_ts</span><br><span class="line"><span class="keyword">and</span> t2.start_ts <span class="operator">&lt;</span> t1.end_ts</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>正常情况下，是没有数据可以被查询出来的，如果有重叠的情况则可以查出重叠的数据。</p>
<p>检测Duplicate：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">     user_id</span><br><span class="line">   , start_ts</span><br><span class="line">   , end_ts</span><br><span class="line">   , <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">having</span> cnt <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>如果某用户有多条起止日期相同的记录，则会被查询出来。</p>
<p>可以用上述SQL设置为Daily DQ Rule来监测上游的数据质量。</p>
]]></content>
      <categories>
        <category>Hive</category>
      </categories>
  </entry>
  <entry>
    <title>数据倾斜调优尝试</title>
    <url>/blog/8d98.html</url>
    <content><![CDATA[<p>在数据处理中，有时候会遇到数据倾斜问题，导致任务运行时间过长，尝试调整一些Spark参数，但是效果不一定明显。那么就可能需要从业务逻辑上进行优化。</p>
<ol>
<li>那么如何判断是否有数据倾斜？</li>
</ol>
<p>可以通过Spark后台的历史运行日志来看。</p>
<p>我们找到实际运行时间最长的Job</p>
<img src="/blog/8d98/image-20210830144529872.png" class="" title="image-20210830144529872.png">

<p>点进看详细的运行信息</p>
<p>如图：</p>
<img src="/blog/8d98/image-20210830142519309.png" class="image-20210830142519309">

<p>这个Stage运行时长16min，一共有2001个task，其中duration代表了实际运行时间。</p>
<p>这个task重点可以看Duration和Shuffle Read Size</p>
<table>
<thead>
<tr>
<th align="left">Metric</th>
<th align="left">Min</th>
<th align="left">25th percentile</th>
<th align="left">Median</th>
<th align="left">75th percentile</th>
<th align="center">Max</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Duration</td>
<td align="left">0 ms</td>
<td align="left">0.2 s</td>
<td align="left">0.8 s</td>
<td align="left">1 s</td>
<td align="center">2.3 h</td>
</tr>
<tr>
<td align="left">GC Time</td>
<td align="left">0 ms</td>
<td align="left">0 ms</td>
<td align="left">0 ms</td>
<td align="left">0.2 s</td>
<td align="center">2.3 min</td>
</tr>
<tr>
<td align="left">Shuffle Read Size / Records</td>
<td align="left">0.0 B / 0</td>
<td align="left">7.8 KB / 85</td>
<td align="left">42.2 KB / 161</td>
<td align="left">241.3 KB / 599</td>
<td align="center">357.3 MB / 1555208</td>
</tr>
<tr>
<td align="left">Shuffle Write Size / Records</td>
<td align="left">0.0 B / 0</td>
<td align="left">59.0 B / 1</td>
<td align="left">59.0 B / 1</td>
<td align="left">59.0 B / 1</td>
<td align="center">59.0 B / 1</td>
</tr>
</tbody></table>
<p>解读：按照Metric的量进行排序，数据在5个采样点（0%，25%，50%，75%，100%）的分布情况。</p>
<p>我们可以认为这个stage就发生了数据倾斜。</p>
<ol start="2">
<li>如何优化数据倾斜？</li>
</ol>
<p>首先需要判断发生倾斜的部分在哪一段，这样才可以更好的应对。<br>还是这个job，在Sprak运行后台找到Duration最长的stage</p>
<img src="/blog/8d98/image-20210915152438683.png" class="image-20210915152438683">

<p>根据describe中的代码片段找到具体这段代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> fmx_spf <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      f.<span class="operator">*</span></span><br><span class="line">    , s.adj_direction</span><br><span class="line">    , s.adj_rate</span><br><span class="line">    , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> s.adj_direction <span class="operator">=</span> <span class="string">&#x27;INCREASE&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="operator">+</span> <span class="built_in">CAST</span>(s.adj_rate <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>))<span class="operator">/</span><span class="number">100</span></span><br><span class="line">           <span class="keyword">WHEN</span> s.adj_direction <span class="operator">=</span> <span class="string">&#x27;DECREASE&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="operator">-</span> <span class="built_in">CAST</span>(s.adj_rate <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">8</span>, <span class="number">2</span>))<span class="operator">/</span><span class="number">100</span></span><br><span class="line">           <span class="keyword">ELSE</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">AS</span> spf_rate</span><br><span class="line">    , s.adj_tiers</span><br><span class="line">    , sox_rule_match(json_split(s.adj_rules)</span><br><span class="line">                   , CONCAT_WS(<span class="string">&#x27;,&#x27;</span>, list_ids)</span><br><span class="line">                   , site_group</span><br><span class="line">                   , numeric1</span><br><span class="line">                   , coupon_cd</span><br><span class="line">                   , <span class="built_in">CAST</span>(item_price_amt <span class="keyword">AS</span> string)</span><br><span class="line">                   , CONCAT(site_id, <span class="string">&#x27;-&#x27;</span>, meta_categ_id)</span><br><span class="line">                   , customer_status</span><br><span class="line">                   , cmpgn_id</span><br><span class="line">                   , ebay_plus_type_desc</span><br><span class="line">                   , item_cndtn_id</span><br><span class="line">                   , item_cndtn_name</span><br><span class="line">                   , own_invtry_ind</span><br><span class="line">                   , pl_flag</span><br><span class="line">    ) <span class="keyword">AS</span> matched_spf_rule_str</span><br><span class="line"><span class="keyword">FROM</span> prs_w.fmx_vrtcl_comm_dedup f</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> spf_temp s</span><br><span class="line">  <span class="keyword">ON</span> f.epn_pblshr_id <span class="operator">=</span> s.publisher_id</span><br><span class="line"> <span class="keyword">AND</span> f.roi_click_event_dt <span class="operator">&gt;=</span> s.start_date <span class="keyword">AND</span> f.roi_click_event_dt <span class="operator">&lt;</span> <span class="built_in">coalesce</span>(s.end_date, <span class="string">&#x27;2099-12-31 00:00:00&#x27;</span>) </span><br><span class="line"> <span class="keyword">AND</span> sox_rule_match(json_split(s.adj_rules)</span><br><span class="line">                 , CONCAT_WS(<span class="string">&#x27;,&#x27;</span>,list_ids)</span><br><span class="line">                 , site_group</span><br><span class="line">                 , numeric1</span><br><span class="line">                 , coupon_cd</span><br><span class="line">                 , <span class="built_in">CAST</span>(item_price_amt <span class="keyword">AS</span> string)</span><br><span class="line">                 , CONCAT(site_id, <span class="string">&#x27;-&#x27;</span>, meta_categ_id)</span><br><span class="line">                 , customer_status</span><br><span class="line">                 , cmpgn_id</span><br><span class="line">                 , ebay_plus_type_desc</span><br><span class="line">                 , item_cndtn_id</span><br><span class="line">                 , item_cndtn_name</span><br><span class="line">                 , own_invtry_ind</span><br><span class="line">                 , pl_flag</span><br><span class="line">     ) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">CACHE <span class="keyword">TABLE</span> fmx_spf;</span><br></pre></td></tr></table></figure>

<p>如果是join，就看关联条件epn_pblshr_id和roi_click_event_dt。</p>
<p>熟悉业务的话，很容易猜到，发生倾斜的部分是epn_pblshr_id</p>
<p>进行一下验证：</p>
<p>其中表<code>prs_w.famx_gmb_numeric_snapshot</code> 是这段SQL的主表</p>
<p>对其进行按照publisher_id分组看看数据分布：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">      epn_pblshr_id</span><br><span class="line">    , <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> prs_w.famx_gmb_numeric_snapshot</span><br><span class="line"><span class="keyword">where</span> trans_dt <span class="keyword">between</span> <span class="string">&#x27;2021-08-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2021-08-31&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cnt <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>运行结果（部分）：</p>
<table>
<thead>
<tr>
<th>no</th>
<th>epn_pblshr_id</th>
<th>cnt</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5575376664</td>
<td>1554352</td>
</tr>
<tr>
<td>2</td>
<td>5575532731</td>
<td>1292900</td>
</tr>
<tr>
<td>3</td>
<td>5575133559</td>
<td>1087001</td>
</tr>
<tr>
<td>4</td>
<td>5574735181</td>
<td>839112</td>
</tr>
<tr>
<td>5</td>
<td>5575403537</td>
<td>595610</td>
</tr>
<tr>
<td>6</td>
<td>5574651234</td>
<td>510958</td>
</tr>
<tr>
<td>7</td>
<td>5574630565</td>
<td>426040</td>
</tr>
<tr>
<td>8</td>
<td>5575403800</td>
<td>405502</td>
</tr>
<tr>
<td>9</td>
<td>5574631662</td>
<td>357304</td>
</tr>
<tr>
<td>10</td>
<td>5574858753</td>
<td>353657</td>
</tr>
<tr>
<td>11</td>
<td>5575407436</td>
<td>341465</td>
</tr>
<tr>
<td>12</td>
<td>5575578768</td>
<td>324448</td>
</tr>
<tr>
<td>13</td>
<td>5574672411</td>
<td>301772</td>
</tr>
<tr>
<td>14</td>
<td>5575086808</td>
<td>270397</td>
</tr>
<tr>
<td>15</td>
<td>5574635388</td>
<td>222064</td>
</tr>
<tr>
<td>16</td>
<td>5575402240</td>
<td>201475</td>
</tr>
<tr>
<td>17</td>
<td>5575322144</td>
<td>197538</td>
</tr>
<tr>
<td>18</td>
<td>5575383302</td>
<td>196567</td>
</tr>
<tr>
<td>19</td>
<td>5575420559</td>
<td>186998</td>
</tr>
<tr>
<td>20</td>
<td>5575400987</td>
<td>173364</td>
</tr>
<tr>
<td>21</td>
<td>5574933636</td>
<td>152722</td>
</tr>
<tr>
<td>22</td>
<td>5575635657</td>
<td>139925</td>
</tr>
<tr>
<td>23</td>
<td>5575082068</td>
<td>110783</td>
</tr>
<tr>
<td>24</td>
<td>5575115467</td>
<td>98180</td>
</tr>
<tr>
<td>25</td>
<td>5575418208</td>
<td>97703</td>
</tr>
</tbody></table>
<p>其中超过10w的只有23个Publisher，超过1w的有124个。</p>
<p>在<code>trans_dt between &#39;2021-08-01&#39; and &#39;2021-08-31&#39;</code>日期范围内一共有8746个publisher。</p>
<p>8月交易数量14740150条，其中：</p>
<p>超过10w交易量的前23个publisher有10241954条，占比69.4%</p>
<p>超过1w交易量的前124个publisher有13422869条，占比91.0%</p>
<p>换句话说，这前一百多个publisher占据了绝大多数的数据量。</p>
<ol start="3">
<li>尝试</li>
</ol>
<img src="/blog/8d98/image-20220307101318915.png" class="image-20220307101318915">

<p>如上图，1和2是倾斜的数据，3，4，5，6是正常的数据，按照这个原理可以对这些数据进行分别处理。</p>
<p>为了把这些数据量大的publisher给分散到不同的task中处理，可以对倾斜的key进行特殊处理</p>
<p>SQL的逻辑是<strong>事实表</strong>左关联<strong>合同表</strong>，取出每条交易符合合同的佣金比率等指标。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- PART 1: 准备</span></span><br><span class="line"><span class="comment">-- 取出交易量大于20000的publisher.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> epn_skewed_pblshr_list <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">     epn_pblshr_id</span><br><span class="line"><span class="keyword">FROM</span> prs_w.famx_gmb_numeric_snapshot</span><br><span class="line"><span class="keyword">WHERE</span> trans_dt <span class="keyword">BETWEEN</span> <span class="string">&#x27;$&#123;DATA_START_DT&#125;&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;$&#123;DATA_END_DT&#125;&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="number">20000</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">CACHE <span class="keyword">TABLE</span> epn_skewed_pblshr_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 生成一个0-98的列,下面方便进行笛卡尔积扩容.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> number_list <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">0</span><span class="operator">+</span>idx <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> SPLIT(SPACE(<span class="number">98</span>), <span class="string">&#x27; &#x27;</span>)  <span class="keyword">AS</span> x) t</span><br><span class="line"><span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> POSEXPLODE(x) pe <span class="keyword">AS</span> idx, ele</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- PART 2: 处理右表</span></span><br><span class="line"><span class="comment">-- 合同表做两部分处理：</span></span><br><span class="line"><span class="comment">-- 倾斜部分(交易量很大的publisher)进行笛卡尔积 -- 扩容99倍，这部分数据，每一个publisher的id前都加上0-98的前缀</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> spf_temp_skewed <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      CONCAT(t3.num, <span class="string">&#x27;_&#x27;</span>, t1.publisher_id) <span class="keyword">AS</span> publisher_id</span><br><span class="line">    , t1.start_date</span><br><span class="line">    , t1.end_date</span><br><span class="line">    , t1.adj_direction</span><br><span class="line">    , t1.adj_rate</span><br><span class="line">    , t1.adj_rules</span><br><span class="line">    , t1.adj_tiers</span><br><span class="line"><span class="keyword">FROM</span> prs_w.epn_pblshr_payout_adj_rules_w t1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> epn_skewed_pblshr_list t2</span><br><span class="line"><span class="keyword">ON</span> t1.publisher_id <span class="operator">=</span> t2.epn_pblshr_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> number_list t3</span><br><span class="line"><span class="keyword">ON</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> mtdt_dt <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(mtdt_dt) <span class="keyword">FROM</span> prs_w.epn_pblshr_payout_adj_rules_w)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非倾斜部分(交易量&lt;20000 的publisher) --为了保持id一致，这部分打上99的前缀</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> spf_temp_unskewed <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      CONCAT(<span class="number">99</span>, <span class="string">&#x27;_&#x27;</span>, t1.publisher_id) <span class="keyword">AS</span> publisher_id</span><br><span class="line">    , t1.start_date</span><br><span class="line">    , t1.end_date</span><br><span class="line">    , t1.adj_direction</span><br><span class="line">    , t1.adj_rate</span><br><span class="line">    , t1.adj_rules</span><br><span class="line">    , t1.adj_tiers</span><br><span class="line"><span class="keyword">FROM</span> prs_w.epn_pblshr_payout_adj_rules_w t1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> epn_skewed_pblshr_list t2</span><br><span class="line"><span class="keyword">ON</span> t1.publisher_id <span class="operator">=</span> t2.epn_pblshr_id</span><br><span class="line"><span class="keyword">WHERE</span> t1.mtdt_dt <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(mtdt_dt) <span class="keyword">FROM</span> prs_w.epn_pblshr_payout_adj_rules_w)</span><br><span class="line"><span class="keyword">AND</span> t2.epn_pblshr_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这两部分union到一起，之所以不用nuion all，是因为这两部分不会重复,所以不需要再进行去重</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> spf_temp <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      publisher_id</span><br><span class="line">    , start_date</span><br><span class="line">    , end_date</span><br><span class="line">    , adj_direction</span><br><span class="line">    , adj_rate</span><br><span class="line">    , adj_rules</span><br><span class="line">    , adj_tiers</span><br><span class="line"><span class="keyword">FROM</span> spf_temp_skewed</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      publisher_id</span><br><span class="line">    , start_date</span><br><span class="line">    , end_date</span><br><span class="line">    , adj_direction</span><br><span class="line">    , adj_rate</span><br><span class="line">    , adj_rules</span><br><span class="line">    , adj_tiers</span><br><span class="line"><span class="keyword">FROM</span> spf_temp_unskewed</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- PART 3: 处理左表</span></span><br><span class="line"><span class="comment">-- 交易明细表部分</span></span><br><span class="line"><span class="comment">-- 左关联倾斜publishr的list，如果关联上则说明是倾斜的交易，打上一个随机(0-98)的前缀,如果没有关联上则打99的前缀</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TEMPORARY <span class="keyword">VIEW</span> famx_gmb_numeric_snapshot_v <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">      f.click_event_dt</span><br><span class="line">    , f.item_id</span><br><span class="line">    , f.ck_trans_id</span><br><span class="line">    , <span class="keyword">CASE</span> <span class="keyword">WHEN</span> k.epn_pblshr_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> CONCAT(<span class="built_in">CAST</span>(RAND(<span class="number">1</span>)<span class="operator">*</span><span class="number">99</span> <span class="keyword">AS</span> <span class="type">INT</span>), <span class="string">&#x27;_&#x27;</span>, f.epn_pblshr_id) <span class="keyword">ELSE</span> CONCAT(<span class="number">99</span>, <span class="string">&#x27;_&#x27;</span>, f.epn_pblshr_id) <span class="keyword">END</span> <span class="keyword">AS</span> epn_pblshr_id</span><br><span class="line">    , f.sap_categ_id</span><br><span class="line">    , f.gmb_usd_amt</span><br><span class="line">    , f.site_id</span><br><span class="line">    , f.meta_categ_id</span><br><span class="line">    , f.meta_categ_name</span><br><span class="line">    , f.vertical_name</span><br><span class="line">    , f.gmb_lc_amt</span><br><span class="line">    , f.gmb_plan_rate_amt</span><br><span class="line">    , f.item_price_amt</span><br><span class="line">    , f.refund_ind</span><br><span class="line">    , f.site_group</span><br><span class="line">    , f.cntry_desc</span><br><span class="line">    , f.created_time</span><br><span class="line">    , f.roi_click_event_dt</span><br><span class="line">    , f.customer_status</span><br><span class="line">    , f.list_ids</span><br><span class="line">    , f.coupon_cd</span><br><span class="line">    , f.coupon_usd_amt</span><br><span class="line">    , f.subsidy_ind</span><br><span class="line">    , f.charity_ind</span><br><span class="line">    , f.numeric1</span><br><span class="line">    , f.own_prchs_ind</span><br><span class="line">    , f.item_cndtn_id</span><br><span class="line">    , f.item_cndtn_name</span><br><span class="line">    , f.own_invtry_ind</span><br><span class="line">    , f.gmb_non_vat_usd_amt</span><br><span class="line">    , f.vat_gmb_amt</span><br><span class="line">    , f.pl_flag</span><br><span class="line">    , f.trans_dt</span><br><span class="line"><span class="keyword">FROM</span> prs_w.famx_gmb_numeric_snapshot f</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> epn_skewed_pblshr_list k</span><br><span class="line"><span class="keyword">ON</span> f.epn_pblshr_id <span class="operator">=</span> k.epn_pblshr_id</span><br><span class="line"><span class="keyword">WHERE</span> f.trans_dt <span class="keyword">BETWEEN</span> <span class="string">&#x27;$&#123;DATA_START_DT&#125;&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;$&#123;DATA_END_DT&#125;&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>这样处理之后<code>famx_gmb_numeric_snapshot_v</code> 的数据量没有变多，但是publisher_id分布的均匀了，而需要左关联的合同表<code>spf_temp</code> 这交易量超过20000条的这些publisher，合同记录被扩大了99倍。</p>
<p>以空间换时间，<code>join</code>和<code>group by</code>的性能会得到一定的提升。</p>
<p>（最后经过验证，这样操作并不影响数据的准确性。）</p>
<ol start="4">
<li>优化后的结果</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Metric</th>
<th align="left">Min</th>
<th align="left">25th percentile</th>
<th align="left">Median</th>
<th align="left">75th percentile</th>
<th align="left">Max</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Duration</td>
<td align="left">27 s</td>
<td align="left">34 s</td>
<td align="left">38 s</td>
<td align="left">42 s</td>
<td align="left">1.1 min</td>
</tr>
<tr>
<td align="left">GC Time</td>
<td align="left">0.4 s</td>
<td align="left">1 s</td>
<td align="left">2 s</td>
<td align="left">2 s</td>
<td align="left">7 s</td>
</tr>
<tr>
<td align="left">Input Size / Records</td>
<td align="left">832.2 KB / 7110</td>
<td align="left">856.0 KB / 7308</td>
<td align="left">862.4 KB / 7365</td>
<td align="left">868.9 KB / 7425</td>
<td align="left">892.3 KB / 7650</td>
</tr>
<tr>
<td align="left">Shuffle Write Size / Records</td>
<td align="left">58.0 B / 1</td>
<td align="left">59.0 B / 1</td>
<td align="left">59.0 B / 1</td>
<td align="left">59.0 B / 1</td>
<td align="left">59.0 B / 1</td>
</tr>
</tbody></table>
<ol start="4">
<li><p>缺点</p>
<ol>
<li><p>代码会变的复杂，不利于阅读和理解，建议加上清晰的注释。</p>
</li>
<li><p>后续维护麻烦，如果有新的feature开发，修改的地方会变多。</p>
</li>
</ol>
</li>
<li><p>总结</p>
</li>
</ol>
<p>实际上，在进行笛卡尔积扩容，打随机前缀等操作也会产生一定的性能损耗，如果<strong>节省的时间</strong>和<strong>消耗的时间</strong>差不多的话，就没有必要做这个优化。如果这个优化减少的时间远大于消耗的时间，则可以考虑做这个优化。</p>
<p>优化需要根据集群性能，业务逻辑，数据量，多方面来综合考量。</p>
<p>从Spark3.0开始，原生支持倾斜join了，由于公司的Spark还未升级到Spark 3版本，上述优化是非常有效的。</p>
<p><a href="https://spark.apache.org/docs/3.1.2/sql-performance-tuning.html#optimizing-skew-join">https://spark.apache.org/docs/3.1.2/sql-performance-tuning.html#optimizing-skew-join</a></p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>默认值</th>
<th>开始适用的版本</th>
</tr>
</thead>
<tbody><tr>
<td>spark.sql.adaptive.skewJoin.enabled</td>
<td>true</td>
<td>3.0.0</td>
</tr>
<tr>
<td>spark.sql.adaptive.skewJoin.skewedPartitionFactor</td>
<td>10</td>
<td>3.0.0</td>
</tr>
<tr>
<td>spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes</td>
<td>256MB</td>
<td>3.0.0</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>根据时间确认当年第几周</title>
    <url>/blog/8998.html</url>
    <content><![CDATA[<p>使用weekofyear函数,传进去一个日期，判断这是当年第几周，一周的定义是从周一到周日，也可以是从周日到周六，根据业务情况来使用。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">      CAL_DT</span><br><span class="line">    , DAY_OF_WEEK_ID</span><br><span class="line">    , day_of_week</span><br><span class="line">    , weekofyear(CAL_DT) <span class="keyword">as</span> week_of_year</span><br><span class="line">    , week_of_year_id</span><br><span class="line"><span class="keyword">from</span> dw_cal_dt</span><br><span class="line"><span class="keyword">where</span> cal_dt <span class="keyword">between</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2022-01-10&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>CAL_DT</th>
<th>DAY_OF_WEEK_ID</th>
<th>day_of_week</th>
<th>week_of_year</th>
<th>week_of_year_id</th>
</tr>
</thead>
<tbody><tr>
<td>2022-01-01</td>
<td>7</td>
<td>Sat</td>
<td>52</td>
<td>1</td>
</tr>
<tr>
<td>2022-01-02</td>
<td>1</td>
<td>Sun</td>
<td>52</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-03</td>
<td>2</td>
<td>Mon</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-04</td>
<td>3</td>
<td>Tue</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-05</td>
<td>4</td>
<td>Wed</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-06</td>
<td>5</td>
<td>Thu</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-07</td>
<td>6</td>
<td>Fri</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-08</td>
<td>7</td>
<td>Sat</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2022-01-09</td>
<td>1</td>
<td>Sun</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2022-01-10</td>
<td>2</td>
<td>Mon</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<hr>
<p>如果一周的定义是周一到周日：</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>用途</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),7) as Monday;</code></td>
<td>取当前周的周一</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),6) as Tuesday;</code></td>
<td>取当前周的周二</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),5) as Wednesday;</code></td>
<td>取当前周的周三</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),4) as Thursday;</code></td>
<td>取当前周的周四</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),3) as Friday;</code></td>
<td>取当前周的周五</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),2) as Saturday;</code></td>
<td>取当前周的周六</td>
<td></td>
</tr>
<tr>
<td><code>select date_sub(next_day(&quot;2022-02-21&quot;,&quot;mo&quot;),1) as Sunday;</code></td>
<td>取当前周的周日</td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>踩坑Hive的动态写入</title>
    <url>/blog/5c9d.html</url>
    <content><![CDATA[<p>在Spark on hive中，创建表有三种方式</p>
<ul>
<li>CREATE TABLE USING DATA_SOURCE</li>
<li>CREATE TABLE USING HIVE FORMAT</li>
<li>CREATE TABLE LIKE</li>
</ul>
<p>方式1创建的是 data source 表，方式2 创建的是hive serde 表，方式3创建的表和like的表保持一致。</p>
<p>那么data source 表和 hive serde 表在使用上有什么区别呢？</p>
<h3 id="hive-serde-表"><a href="#hive-serde-表" class="headerlink" title="hive serde 表"></a>hive serde 表</h3><p> hive serde表，开启动态分区，使用动态写入时候，必须要开启下面的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>严格模式要求至少有一个静态分区，如果我们写入的表只有一个分区字段，是需要开启非严格模式的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode<span class="operator">=</span>nonstrict;</span><br></pre></td></tr></table></figure>

<p>如果不开启动态分区，直接动态写入是会报错的。</p>
<h3 id="data-source-表"><a href="#data-source-表" class="headerlink" title="data source 表"></a>data source 表</h3><p>data source 表和 hive serve，开启动态分区的参数有一些区别：</p>
<p>默认情况下是static模式，使用如下参数开启动态分区：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.sources.partitionOverwriteMode<span class="operator">=</span><span class="keyword">DYNAMIC</span>;</span><br></pre></td></tr></table></figure>

<p>如果不开启动态分区，使用动态写入不会报错，而且被写入的表，所有分区都会先被<strong>全部删除</strong>！然后<strong>动态</strong>写入查询的内容。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.sources.partitionOverwriteMode<span class="operator">=</span><span class="keyword">static</span>;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> pama.text_002 <span class="keyword">partition</span>(dt)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pama.text_001</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>举个例子，上面语句执行完毕后，pama.text_002表中所有的分区会被删除，然后把pama.text_001的内容写入pama.text_002。然而这是一个深坑。</p>
<p>所谓动态分区，即不指定分区的详细信息，分区信息由<strong>查询内容</strong>决定。</p>
<p>如果我开启了静态分区模式，在使用动态语句插入时候，为什么还会被<strong>动态</strong>执行且不报异常？</p>
<p>这是一个bug还是一个feature？</p>
<table>
<thead>
<tr>
<th><code>spark.sql.sources.partitionOverwriteMode</code></th>
<th>STATIC</th>
<th>When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. In static mode, Spark deletes all the partitions that match the partition specification(e.g. PARTITION(a=1,b)) in the INSERT statement, before overwriting. In dynamic mode, Spark doesn’t delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of Spark prior to 2.3. Note that this config doesn’t affect Hive serde tables, as they are always overwritten with dynamic mode. This can also be set as an output option for a data source using key partitionOverwriteMode (which takes precedence over this setting), e.g. dataframe.write.option(“partitionOverwriteMode”, “dynamic”).save(path).</th>
</tr>
</thead>
</table>
<p>参考：<a href="https://spark.apache.org/docs/3.2.0/configuration.html#dynamic-allocation">https://spark.apache.org/docs/3.2.0/configuration.html#dynamic-allocation</a></p>
]]></content>
  </entry>
  <entry>
    <title>Shell解析json</title>
    <url>/blog/a5ac.html</url>
    <content><![CDATA[<p>在一些自动化脚本中，有时候会调用一些组件的 RESTful API，这些API返回的数据格式是JSON。这时候就需要用通过shell对JSON进行简单的解析。</p>
<p>下面是一个SHELL下的JSON解析函数，支持JSON数组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">jsonval</span></span>() &#123;</span><br><span class="line">    temp=`<span class="built_in">echo</span> <span class="variable">$json</span> | sed <span class="string">&#x27;s^\:\ \[&#123;^\:\ \&quot;\&quot;\,^g;s^\:\ &#123;^\:\ \&quot;\&quot;\,^g;s^\:\[&#123;^\:\ \&quot;\&quot;\,^g;s^\:&#123;^\:\ \&quot;\&quot;\,^g&#x27;</span>|sed <span class="string">&#x27;y/\&#123;\&#125;\[\]/\ \ \ \ /&#x27;</span>|awk -v k=<span class="string">&quot;text&quot;</span> <span class="string">&#x27;&#123;n=split($0,a,&quot;,&quot;); for (i=1; i&lt;=n; i++) print a[i]&#125;&#x27;</span>|sed <span class="string">&#x27;s/\&quot;\:\&quot;/\|/g;s/\&quot;\:\ \&quot;/\|/g;s/\&quot;\:\ /\|/g&#x27;</span>|sed <span class="string">&#x27;s/\&quot;//g&#x27;</span>|grep -w <span class="variable">$1</span>|<span class="built_in">head</span> -1`;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;temp&#125;</span>|awk -F <span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>$json</code> 这个变量是我们需要解析的json串，使用方法为 <code>jsonval KEY;</code></p>
<p>需要注意的是，这只是一个简单的解析，目前支持JSON数组，仅能解析最细粒度的KEY:VALUE。如果全局唯一的KEY，如果KEY不唯一，则返回第一次出现这个KEY所对应的VALUE。</p>
]]></content>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Double类型乘法精确度</title>
    <url>/blog/91d3.html</url>
    <content><![CDATA[<p>在写Hive的UDF时候，发现了一个double类型的精确度问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1.3</span>;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line"></span><br><span class="line">        d = a * b * c;</span><br><span class="line"></span><br><span class="line">        System.out.println(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_251.jdk/Contents/Home/bin/java ...</span><br><span class="line">1.7160000000000002</span><br></pre></td></tr></table></figure>

<p>而实际上1.1 x 1.2 x 1.3 = 1.716</p>
<p>这个结果并不符合预期，原因是由于浮点数是无法在计算机中准确表示的，例如0.1在计算机中只是表示成了一个近似值，因此，浮点数的运算结果具有不可预知性。</p>
<p>解决方案：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provide precise multiplication operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v1 Multiplicand</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v2 multiplier</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Product of two parameters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pama</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">mul</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v1));</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(Double.toString(v2));</span><br><span class="line">    <span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个乘法的方法，需要做乘法时候，调用这个方法即可。</p>
]]></content>
  </entry>
  <entry>
    <title>Shell查找包含某关键字的文件</title>
    <url>/blog/1a6a.html</url>
    <content><![CDATA[<p>如何在shell环境下查找包含某些关键字内容的文件？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -iE <span class="string">&quot;关键字A|关键字B|关键字C&quot;</span> path/*</span><br></pre></td></tr></table></figure>

<p><code>path/*</code> 是路径</p>
]]></content>
  </entry>
  <entry>
    <title>launchctl的简单使用</title>
    <url>/blog/9add.html</url>
    <content><![CDATA[<p>在 Linux 上有一个大家用惯的 systemd，在 MacOS 上有一个与之相对应的工具，launchd。</p>
<p>Linux 下，systemd 的 pid 是 1，系统启动后，它是第一个被拉起来的，其它进程都是它的子进程。</p>
<p>在MacOS 下面也有一个这样的超级进程，所有的其它进程都是它产生的，挂为它的子进程、孙子进程…… 它就是 launchd。launchd 对应的管理工具就是 launchctl。</p>
<p>plist配置模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;tech.mapan.macos.alist&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class="line">        &lt;true/&gt;</span><br><span class="line">        &lt;key&gt;ProcessType&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;Background&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class="line">        &lt;true/&gt;</span><br><span class="line">        &lt;key&gt;WorkingDirectory&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;path/to/alist/working&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;string&gt;path/to/alist&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;server&lt;/string&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>



<p>其中Label应该与plsit的文件名一致，例如本例子的文件名应该是<code>~/Library/LaunchAgents/tech.mapan.macos.alist.plist</code></p>
<ul>
<li><p><code>RunAtLoad</code> 代表开机自启动</p>
</li>
<li><p><code>WorkingDirectory</code> 代表工作目录</p>
</li>
<li><p><code>ProgramArguments</code>  代表运行命令</p>
<p>本例中的命令等价于在<code>/Users/mapan/alist</code>目录下 执行 <code>/Users/mapan/bin/alist server</code>命令。</p>
</li>
</ul>
<p>配置好plist文件后重启电脑后即可生效。</p>
<p>如果遇到问题可以使用<code>LaunchControl</code>这个可视化工具进行排查。</p>
<p>安装方式：<code>brew install --cask launchcontrol</code></p>
<p>ps: 这个工具是收费软件，但可以试用，试用版对于调试看报错信息足够了。</p>
]]></content>
  </entry>
  <entry>
    <title>docker自定义容器ip的方法</title>
    <url>/blog/8d39.html</url>
    <content><![CDATA[<p>Docker在个人vps玩家中是非常好用的容器工具。只需要创建一个Nginx容器，接管80和443端口，所有服务都通过Nginx进行反代。</p>
<p>这样即主机只需要开放三个端口，80/443/22(建议改为ssh非标端口)</p>
<p>Docker 创建一个名为mynet的网络</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker network create --driver bridge --subnet <span class="number">172.20</span>.<span class="number">0.0</span>/<span class="number">24</span> --gateway <span class="number">172.20</span>.<span class="number">0.1</span> mynet</span><br></pre></td></tr></table></figure>



<p>在docker compose文件中，使用如下方式即可指定一个地址为<code>172.20.0.8:6379</code>的redis容器，这个地址即可通过Nginx反代到别的端口</p>
<p>而port无需手动指定映射，主机的46379端口并不会开放。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mynet</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis7</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:7</span></span><br><span class="line">    <span class="comment"># ports:</span></span><br><span class="line">    <span class="comment">#   - &quot;46379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./build/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./build/redis/data:/data</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">172.20</span><span class="number">.0</span><span class="number">.8</span></span><br></pre></td></tr></table></figure>



<p>这样启动的容器，重启也不会改变容器的ip地址。</p>
<p>若是使用docker命令,则类似下面这样，创建了一个<code>172.20.0.3</code>地址的portainer容器。再使用Nginx对该内网地址进行反代即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name=portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">--network mynet \</span><br><span class="line">--ip 172.20.0.3 \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-v portainer_data:/data \</span><br><span class="line">portainer/portainer-ce:2.16.2</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SparkSQL踩坑</title>
    <url>/blog/a1cd.html</url>
    <content><![CDATA[<p>在开发中，遇到了一个奇怪的Join结果。简化之后的模型如下，目测执行的结果第一个为<code>true</code>，第二个为<code>false</code>，而实际的结果却是两个True。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace temp <span class="keyword">view</span> test1 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">      <span class="string">&#x27;23843968833490313&#x27;</span> <span class="keyword">as</span> s1</span><br><span class="line">    , <span class="built_in">cast</span>(<span class="string">&#x27;23843968833490313&#x27;</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">18</span>,<span class="number">0</span>)) <span class="keyword">as</span> s2</span><br><span class="line">    , <span class="built_in">cast</span>(<span class="string">&#x27;23843968833490312&#x27;</span> <span class="keyword">as</span> <span class="type">decimal</span>(<span class="number">18</span>,<span class="number">0</span>)) <span class="keyword">as</span> s4</span><br><span class="line">;</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">      s1 <span class="operator">=</span> s2</span><br><span class="line">    , s1 <span class="operator">=</span> s4</span><br><span class="line"><span class="keyword">from</span> test1</span><br><span class="line">;</span><br></pre></td></tr></table></figure>


<p>究其原因是在不同类型的比较中，Spark会把其先转为Double类型再进行比较，而Double类型的精度有限，这样就会出现让人匪夷所思的现象。在实际复杂的Join中，往往会忽视数据类型的检查。</p>
<p>所以在实际开发中，一定要保证join两边的数据类型一致，特别是join条件两边存在表达式的情况，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tableA </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> <span class="built_in">coalesce</span>(tableA.id1 , tableA.id2) <span class="operator">=</span> tableB.id</span><br><span class="line">;</span><br></pre></td></tr></table></figure>


<p>建议写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tableA </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> <span class="built_in">cast</span>(<span class="built_in">coalesce</span>(tableA.id1 , tableA.id2) <span class="keyword">AS</span> decmial(<span class="number">18</span>,<span class="number">0</span>)) <span class="operator">=</span> tableB.id</span><br><span class="line">;</span><br></pre></td></tr></table></figure>


<p>在有表达式的地方，加上类型转换。</p>
<p>如果能在建表之初，根据业务含义和开发规范合适的选择字段的类型，则可以在很大程度上避免这类情况的发生。</p>
<p>比如xxx_ID 统一使用<code>Decimal(位数,0)</code> ，xxFlag统一使用<code>Boolean</code>等，而不是String和这类情况混用。</p>
]]></content>
      <categories>
        <category>ETL</category>
      </categories>
  </entry>
</search>
